<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"reoger.tk","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="android四大组件activity的生命周期 activity的四种启动模式Standard（默认）、singleTop（栈顶复用）、singleTask（栈内复用）、singleInstance（单实例）。当然，不但可以通过在AndroidManifest.xml中声明launchMode，也可以通过指定Activity的Flags来设置启动模式。例如：FLAG_ACTIVITY_NEW_T">
<meta property="og:type" content="article">
<meta property="og:title" content="android面试准备">
<meta property="og:url" content="http://reoger.tk/2017/08/28/android%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/index.html">
<meta property="og:site_name" content="reoger的记录">
<meta property="og:description" content="android四大组件activity的生命周期 activity的四种启动模式Standard（默认）、singleTop（栈顶复用）、singleTask（栈内复用）、singleInstance（单实例）。当然，不但可以通过在AndroidManifest.xml中声明launchMode，也可以通过指定Activity的Flags来设置启动模式。例如：FLAG_ACTIVITY_NEW_T">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gss1.bdstatic.com/9vo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike92%2C5%2C5%2C92%2C30/sign=c070b79dcb177f3e0439f45f11a650a2/1c950a7b02087bf41b6972c2f0d3572c11dfcf17.jpg">
<meta property="og:image" content="http://img.my.csdn.net/uploads/201211/29/1354170699_6619.png">
<meta property="og:image" content="https://developer.android.google.cn/images/service_lifecycle.png">
<meta property="og:image" content="http://reoger.tk/2017/08/28/android%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/img/view%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6.png">
<meta property="og:image" content="http://ovec6nnof.bkt.clouddn.com/hanlder.png">
<meta property="article:published_time" content="2017-08-28T05:35:40.000Z">
<meta property="article:modified_time" content="2020-04-12T14:55:47.927Z">
<meta property="article:author" content="reoger">
<meta property="article:tag" content="android，review">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gss1.bdstatic.com/9vo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike92%2C5%2C5%2C92%2C30/sign=c070b79dcb177f3e0439f45f11a650a2/1c950a7b02087bf41b6972c2f0d3572c11dfcf17.jpg">

<link rel="canonical" href="http://reoger.tk/2017/08/28/android%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>android面试准备 | reoger的记录</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">reoger的记录</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">--以后的你会感激现在那么努力的自己</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>日程表</a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://reoger.tk/2017/08/28/android%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="reoger">
      <meta itemprop="description" content="reoger">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="reoger的记录">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          android面试准备
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-08-28 13:35:40" itemprop="dateCreated datePublished" datetime="2017-08-28T13:35:40+08:00">2017-08-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-12 22:55:47" itemprop="dateModified" datetime="2020-04-12T22:55:47+08:00">2020-04-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">面试</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="android四大组件"><a href="#android四大组件" class="headerlink" title="android四大组件"></a>android四大组件</h1><h2 id="activity的生命周期"><a href="#activity的生命周期" class="headerlink" title="activity的生命周期"></a>activity的生命周期</h2><p><img src="https://gss1.bdstatic.com/9vo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike92%2C5%2C5%2C92%2C30/sign=c070b79dcb177f3e0439f45f11a650a2/1c950a7b02087bf41b6972c2f0d3572c11dfcf17.jpg" alt="activity的生命周期图"></p>
<h2 id="activity的四种启动模式"><a href="#activity的四种启动模式" class="headerlink" title="activity的四种启动模式"></a>activity的四种启动模式</h2><p>Standard（默认）、singleTop（栈顶复用）、singleTask（栈内复用）、singleInstance（单实例）。<br>当然，不但可以通过在AndroidManifest.xml中声明launchMode，也可以通过指定Activity的Flags来设置启动模式。例如：<br>FLAG_ACTIVITY_NEW_TASK 相当于singleTask模式；<br>FLAG_ACTIVITY_SINGLE_TOP 相当于singleTop模式；<br>FLAG_ACTIVITY_CLEAR_TOP 标记的activity在同一个任务栈中所有位于它上面的activity都要出栈；<br>FLAY_ACTIVITY_EXCLUDE_FROM_RECENTS 标记的activity不会出现在历史的activity列表中。</p>
<h2 id="activity的四种状态"><a href="#activity的四种状态" class="headerlink" title="activity的四种状态"></a>activity的四种状态</h2><p>runing、paused、stopped、kille</p>
<h2 id="activity的启动方式"><a href="#activity的启动方式" class="headerlink" title="activity的启动方式"></a>activity的启动方式</h2><p>显式和隐式启动。其中隐式启动的匹配规则：<br>intentFilter中过滤信息有action、category、data。<br>Intent中的action能够和过滤规则中的任何一个action相同即可；<br>Intent中所有的category都必须和过滤过则中的某一个category相同；<br>Intent中的data能够和过滤规则中的任何一个data相同即可。<br>在隐式启动的时候，可以用packageManager的resolveActivity或者Activity的resolveActivity方法先判断是否有activity相匹配，避免异常发生。</p>
<h2 id="activity的启动流程"><a href="#activity的启动流程" class="headerlink" title="activity的启动流程"></a>activity的启动流程</h2><p>参考<a href="http://blog.csdn.net/singwhatiwanna/article/details/18154335" target="_blank" rel="noopener">这里</a></p>
<h2 id="activity异常停止时保存数据的方法"><a href="#activity异常停止时保存数据的方法" class="headerlink" title="activity异常停止时保存数据的方法"></a>activity异常停止时保存数据的方法</h2><p>可以在onSaveInstanceState（在onStop之前被调用）中将要保存的数据保存起来，可以通过Bundle进行临时保存，然后在onCreate中的bundle中取出来进行恢复，但是oncreate中进行数据恢复要注意判空，也可以在onRestoreInstanceState（）取出数据进行恢复（这里就不要判空，因为只要回调这个方法就一定不为空）。<a href="http://blog.csdn.net/reoger/article/details/51354658" target="_blank" rel="noopener">参考。</a></p>
<h2 id="Activity、Windows、View三者的区别和联系。"><a href="#Activity、Windows、View三者的区别和联系。" class="headerlink" title="Activity、Windows、View三者的区别和联系。"></a>Activity、Windows、View三者的区别和联系。</h2><p>Activity是控制单元，通过attach方法创建window对象；window是承载模型，负责承载视图；view是要显示的视图，必须依附于window；<br>Window是一个抽象类，他的具体实现是phoneWindow，Android中所有的视图都是通过window来呈现的，不管是activity、Dialog还是Toast，他们的视图实际上都是附加在window上的，因为window实际是view的直接管理者。<br>最后总结一句话：activity像一个工匠（控制单元），window向窗户（承载模型），View像窗花（显示视图）。</p>
<h2 id="activity间通过Intent传递数据的大小限制"><a href="#activity间通过Intent传递数据的大小限制" class="headerlink" title="activity间通过Intent传递数据的大小限制"></a>activity间通过Intent传递数据的大小限制</h2><p>肯定是有限制的，大约大1m（1020k）左右。但是官方并没有给出说明。 </p>
<h2 id="Fragment的生命周期"><a href="#Fragment的生命周期" class="headerlink" title="Fragment的生命周期"></a>Fragment的生命周期</h2><p><img src="http://img.my.csdn.net/uploads/201211/29/1354170699_6619.png" alt="fragment生命周期图"></p>
<h2 id="添加fragment的步骤。"><a href="#添加fragment的步骤。" class="headerlink" title="添加fragment的步骤。"></a>添加fragment的步骤。</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;步骤1、创建待添加的的fragment实例</span><br><span class="line">MyFragment m &#x3D; new MyFragment();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;步骤2、开始一个事务</span><br><span class="line">FragmentManager fragmentManager &#x3D; getFragmentManager(); &#x2F;&#x2F;获取fragment对象</span><br><span class="line">FragmentTransaction fragmentTransaction &#x3D; fragmentManager.beginTransaction(); &#x2F;&#x2F;利用fragment开启事务</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;步骤3、向容器内加入碎片,可以通过add或者replace方法实现。</span><br><span class="line">fragmentTransaction.add(R.id.fragment, m);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;步骤4、提交事务</span><br><span class="line">fragmentTransaction.commit();</span><br></pre></td></tr></table></figure>

<h2 id="添加Fragment时方法"><a href="#添加Fragment时方法" class="headerlink" title="添加Fragment时方法"></a>添加Fragment时方法</h2><p>一般有两种方法添加碎片，即通过replace和add方法，下面是两种方法的区别：<br>通过add方法添加的fragment，每个fragment都只能添加一次。因此如果想达到切换的效果需要通过fragment的hide和show方法结合使用。将要显示的show出来，将其他hide起来，这个过程fragment生命周期没有变化。<br>通过replace方法添加fragment，每个fragmnet可以添加任意次，因为每一次添加都会先将之前的fragmemnt移除，然后在添加。因此切换fragment，每次都会执行上一和fragment的onDstoryView，新的Fragemnt的onCreateView、onStart、onResume方法。</p>
<h2 id="Activity和Fragment之间的区别。"><a href="#Activity和Fragment之间的区别。" class="headerlink" title="Activity和Fragment之间的区别。"></a>Activity和Fragment之间的区别。</h2><p>1．  Fragment显得更加灵活，可以在xml文件中添加<fragment>，动态的替换一部分界面，activity则不行；<br>2．  Fragment不需要在manfest中申明，而activity需要。</p>
<h2 id="Activity与Fragment通信方案。"><a href="#Activity与Fragment通信方案。" class="headerlink" title="Activity与Fragment通信方案。"></a>Activity与Fragment通信方案。</h2><ol>
<li>handler：该方案存在的缺点：<br>Fragment对具体的Activity存在耦合，不利于Fragment复用<br>不利于维护，若想删除相应的Activity，Fragment也得改动<br>没法获取Activity的返回数据</li>
<li>广播方案，缺点：<br>用广播解决此问题有点大材小用了，个人感觉广播的意图是用在一对多，接收广播者是未知的情况<br>广播性能肯定会差<br>传播数据有限制（必须得实现序列化接口才可以）</li>
<li>EventBus方案：<br>EventBus是用反射机制实现的，性能上会有问题<br>EventBus难于维护代码<br>没法获取Activity的返回数据</li>
<li>接口方案<br>假如项目很大了，Activity与Fragment的数量也会增加</li>
</ol>
<h2 id="Service的生命周期。"><a href="#Service的生命周期。" class="headerlink" title="Service的生命周期。"></a>Service的生命周期。</h2><p>Service的生命周期分为两种，一种是直接利用startCommand启动，另一种是通过bindService来启动。具体如图所示。值得注意的是，在已经启动的service，我们重新启动的时候，不会执行onCreate方法，而是直接执行onStartCommand方法。<br><img src="https://developer.android.google.cn/images/service_lifecycle.png" alt="服务生命周期"><br>左图显示了使用 startService() 所创建的服务的生命周期，右图显示了使用 bindService() 所创建的服务的生命周期。</p>
<h2 id="Service和Thread的区别"><a href="#Service和Thread的区别" class="headerlink" title="Service和Thread的区别"></a>Service和Thread的区别</h2><p>Service是安卓中系统的组件，它运行在独立进程的主线程中，不可以执行耗时操作。Thread是程序执行的最小单元，分配CPU的基本单位，可以开启子线程执行耗时操作;<br>Service在不同Activity中可以获取自身实例，可以方便的对Service进行操作。Thread在不同的Activity中难以获取自身实例，如果Activity被销毁，Thread实例就很难再获取得到。</p>
<h2 id="Broadcast-Receiver的种类"><a href="#Broadcast-Receiver的种类" class="headerlink" title="Broadcast Receiver的种类"></a>Broadcast Receiver的种类</h2><ul>
<li>普通广播</li>
<li>有序广播</li>
<li>本地广播</li>
<li>Sticky广播</li>
</ul>
<h2 id="注册广播有几种方式？他们有什么区别？"><a href="#注册广播有几种方式？他们有什么区别？" class="headerlink" title="注册广播有几种方式？他们有什么区别？"></a>注册广播有几种方式？他们有什么区别？</h2><p>广播注册分为静态注册和动态注册，其中的静态注册的广播在应用安装时由系统自动完成注册，具体来说是由PMS来完成整个注册过程。<br>静态注册属于常驻型广播，也就是说当应用程序关闭后，如果有信息广播来，程序也会被系统调用自动运行（在android 3.1以后就可能不成立了，加入了一个<a href="http://www.jianshu.com/p/92ccb8ca2ea5" target="_blank" rel="noopener">flag位</a>）。动态注册不是常驻型广播，也就是说广播跟随程序的生命周期。</p>
<h2 id="Broadcast-Receiver实现机制"><a href="#Broadcast-Receiver实现机制" class="headerlink" title="Broadcast Receiver实现机制"></a>Broadcast Receiver实现机制</h2><ol>
<li>自定义广播类继承BroadcastReceiver，复写onReceiver()</li>
<li>通过Binder机制向AMS进行注册广播</li>
<li>广播发送者通过Binder机制向AMS发送广播</li>
<li>AMS查找符合相应条件的广播发送到BroadcastReceiver相应的循环队列中<br>消息队列执行拿到广播，回调BroadcastReceiver的onReceiver()</li>
</ol>
<h2 id="LocalBroadcastManager特点"><a href="#LocalBroadcastManager特点" class="headerlink" title="LocalBroadcastManager特点"></a>LocalBroadcastManager特点</h2><ul>
<li>本地广播只能在自身App内传播，不必担心泄漏隐私数据</li>
<li>本地广播不允许其他App对你的App发送该广播，不必担心安全漏洞被利用</li>
<li>本地广播比全局广播更高效</li>
<li>以上三点都是源于其内部是用Handler实现的</li>
</ul>
<h2 id="ContentProvider是如何实现数据共享的。"><a href="#ContentProvider是如何实现数据共享的。" class="headerlink" title="ContentProvider是如何实现数据共享的。"></a>ContentProvider是如何实现数据共享的。</h2><p>在android中如果想就将自己应用的数据（一般多位数据库中的数据）提供给第三方应用，那么我们只能通过ContentPrivider来实现。<br>ContentProvider是应用程序之间共享的接口，使用的时候首先自定义一个类继承ContentProvider，然后覆写query、insert、update、delete等方法，因为其是四大组件之一，因此必须在AndroidManifest文件中进行注册，把自己的数据通过uri的形式共享出去。第三方可以通过ContentResplver来访问该Provider。</p>
<h2 id="Application的生命周期？"><a href="#Application的生命周期？" class="headerlink" title="Application的生命周期？"></a>Application的生命周期？</h2><p>onCreate() –&gt; 创建application  –&gt; onTerminate() –&gt; 结束。<br>其中，在application中，可能会回调<code>onConfigurationChanged()</code>（在设备配置发生改变的时候调用）、<code>onLowMemory()</code>（手机内存低时调用））、<code>OnTrimMemory()</code>（在操作系统清理内存的时候时候调用）。</p>
<h1 id="View相关面试题"><a href="#View相关面试题" class="headerlink" title="View相关面试题"></a>View相关面试题</h1><h2 id="简述View的事件分发机制。"><a href="#简述View的事件分发机制。" class="headerlink" title="简述View的事件分发机制。"></a>简述View的事件分发机制。</h2><p>当一个点击事件产生后，他的传递过程应该是：Activity –&gt; windos –&gt; View;<br>顶级View接到事件后，就会按照事件分发机制去分发事件，具体如下图所示。<br>值得注意的是，ViewGroup默认不拦截任何事件，而子View中没有OnIntercepterTouchEvent方法，一旦有事件传递给他，那么他的onTouchEvent就会马上调用。某个View一旦决定拦截事件，那么这一个事件序列都只能由他来处理。<br>简单来说：点击事件分发过程如下 dispatchTouchEvent—-&gt;OnTouchListener的onTouch方法—-&gt;onTouchEvent–&gt;OnClickListener的onClick方法。也就是说，我们平时调用的setOnClickListener，优先级是最低的，所以，onTouchEvent或OnTouchListener的onTouch方法如果返回true，则不响应onClick方法。<br><img src="./img/view%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6.png" alt="Touch事件传递机制流程图"></p>
<h2 id="view测量的宽-高和实际上的宽-高是一样的吗？"><a href="#view测量的宽-高和实际上的宽-高是一样的吗？" class="headerlink" title="view测量的宽/高和实际上的宽/高是一样的吗？"></a>view测量的宽/高和实际上的宽/高是一样的吗？</h2><p>不一定一样，虽然在大部分情况下是一样的，但是在某些情况下会导致两者的值不相同。<br>在View的默认实现中，View的测量宽/高和最终的宽/高是相等的，只不过测量宽/高形成于measure过程，而最终宽/高形成与View的layout过程，即两者的赋值时机不同，测量宽/高的赋值时机要稍微早一点。当我们重写layout方法时，可以导致测量的宽/高和实际的宽/高不同（虽然没有什么具体的含义，但是证明了view测量的宽/高和实际的宽/高是可以不相同的）。</p>
<h2 id="在activity启动的时候就需要获取某个View的宽-高，该怎么做？"><a href="#在activity启动的时候就需要获取某个View的宽-高，该怎么做？" class="headerlink" title="在activity启动的时候就需要获取某个View的宽/高，该怎么做？"></a>在activity启动的时候就需要获取某个View的宽/高，该怎么做？</h2><p>注意，我们一定不能在onCreate、onStart、onResume中去获取。因为View的measure过程和Activity的生命周期方法不是同步的执行的，因此无法保证Activity在某个生命周期方法中这个View已经测量完毕了。<br>我们可以在onWindowFocusChanged方法中获取；我们也可以通过view.post(runnable)将runnable投递到消息队列的尾部，然后等待Looper调用此runnable获取View的高和宽；我们也可以使用ViewTreeObserver的众多回调来获取View的高，例如使用onGlodalLayoutListener这个接口。最后，我们当然也可以手动对view进行measure来得到View的宽/高。</p>
<h2 id="自定义View要注意哪些地方？"><a href="#自定义View要注意哪些地方？" class="headerlink" title="自定义View要注意哪些地方？"></a>自定义View要注意哪些地方？</h2><p>让view支持wrap_content；<br>直接继承View或者ViewGroup的控件，如果不在onMeasure中对wrap_content做特殊的处理，那么当外界在布局中使用wrap_content时就无法达到预期的效果。<br>让view支持padding和margin；<br>直接继承view的话，如果不在draw方法中处理paddding，那么padding属性是无法起作用的。另外，直接继承ViewGroup的控件需要在onMeasure和onLayout中考虑padding、<br>和子元素margin对其造成的影响，不然将会导致这两个属性失效。<br>  尽量不要在View中使用handler，view中如果有线程或者动画，一定要及时停止，否则可能会造成内存泄露；<br>  View带有滑动嵌套的时候，要注意处理滑动冲突。</p>
<h2 id="自定义view的步骤。"><a href="#自定义view的步骤。" class="headerlink" title="自定义view的步骤。"></a>自定义view的步骤。</h2><p>简单来说，主要有三大步骤：</p>
<ul>
<li>onMeasure</li>
<li>onLayout</li>
<li>onDraw<br>具体详细，可以参考<a href="http://blog.csdn.net/qq_30379689/article/details/54588736" target="_blank" rel="noopener">博客</a></li>
</ul>
<h1 id="动画相关"><a href="#动画相关" class="headerlink" title="动画相关"></a>动画相关</h1><h2 id="Android中的三种动画。"><a href="#Android中的三种动画。" class="headerlink" title="Android中的三种动画。"></a>Android中的三种动画。</h2><p>Android中的动画有三种：View动画、帧动画和属性动画。<br> View动画的作用对象是View，他支持4中动画效果：分别是平移动画（TranslateAnimation）、缩放动画（ScaleAnimation）、旋转动画（RotateAnimation）和透明度动画（AlphaAnimation）。<br>帧动画是顺序播放一组预先定义好的图片，类似于电影播放。<br>属性动画是在API 11新加入的特性，属性动画可以对任何对象做动画，甚至可以没有对象。除了动画对象进行了扩展以外，属性动画的动画效果也进行了加强，不像View动画只支持四种动画。</p>
<h2 id="可以对任意属性做动画吗？"><a href="#可以对任意属性做动画吗？" class="headerlink" title="可以对任意属性做动画吗？"></a>可以对任意属性做动画吗？</h2><p>可以。如果想对Object的属性abd做动画，如果想让动画生效，要同时满足两个条件：<br>object必须要提供setAbd方法，如果动画的时候没有传递初始值，那么还要提供getAbd方法，因为系统要去取abd属性的初始值（如果这个条件不满足，程序直接Crash）；<br>object的setAbd对属性adc所做的改变必须能够通过某种方法反映出来，比如会带来UI的改变之类的（如果这条不满足，动画无效果但不会Crash）。<br>针对上面的两个条件，google官方告诉我们三种解决方案：<br>给你的对象加上get和set方法，如果有权限的话；<br>用一个类来包装原始对象，间接为其提供get和set方法；<br>采用ValueAnimator，监听动画过程，自己实现属性的改变。</p>
<h2 id="使用动画的注意事项。"><a href="#使用动画的注意事项。" class="headerlink" title="使用动画的注意事项。"></a>使用动画的注意事项。</h2><p>在开发的过程中尽量少用帧动画，避免OOM；<br>在activity退出时及时停止动画，避免内存泄露；<br>在android3.0以下的系统中使用属性动画需做好适配工作；<br>在view动画中，view只是对view的影像做动画，并没有真正的改变view的状态；<br>使用动画的时候，建议开启硬件加速（在声明文件中添加android:hardwareAccelerated=”true”属性即可），提高动画的流畅性。</p>
<h2 id="怎么为activity设置切换效果，怎么给ViewGroup子元素添加子元素的出场动画？"><a href="#怎么为activity设置切换效果，怎么给ViewGroup子元素添加子元素的出场动画？" class="headerlink" title="怎么为activity设置切换效果，怎么给ViewGroup子元素添加子元素的出场动画？"></a>怎么为activity设置切换效果，怎么给ViewGroup子元素添加子元素的出场动画？</h2><p>Activity有默认的切换效果，但是这个效果我们可以自定义的，主要用到overriderPendingTransition()这个方法，这个方法必须在startActivity或者finish()之后调用才能生效。至于Fragment的切换效果，我们可以通过setCustormAnimation方法来添加切换动画。<br>至于在ViewGroup中为子元素出场添加动画，可以在xml中对布局的LayoutAnimation引用相应的动画资源文件即可，或者我们也可以在java中利用LayoutAnimationController将获取到的动画资源文件设置到viewGroup中即可。</p>
<h2 id="动画中的差值器和估值器怎么理解？"><a href="#动画中的差值器和估值器怎么理解？" class="headerlink" title="动画中的差值器和估值器怎么理解？"></a>动画中的差值器和估值器怎么理解？</h2><p>时间插值器（TimeInterpolator）的作用是根据时间流逝的百分比来计算出当前属性值改变的百分比，系统预置的有LinearInterpolator（线性插值器：匀速动画），<br>AccelerateDecelerateInterpolator（加速减速插值器：动画两头慢中间快），<br>DecelerateInterpolator(减速插值器：动画越来越慢）。<br>估值器（TypeEvaluator）的作用是根据当前属性改变的百分比来计算改变后的属性值。系统预置有IntEvaluator 、FloatEvaluator 、ArgbEvaluator。<br>具体来说 对于一个作用在view上改变其宽度属性、持续40ms的属性动画来说，就是当时间t=20ms时，时间流逝了50%，那么view的宽度属性应该改变了多少呢？这个就由Interpolator和Evaluator的算法来决定。</p>
<h2 id="滑动冲突是如何产生的，该如何避免？"><a href="#滑动冲突是如何产生的，该如何避免？" class="headerlink" title="滑动冲突是如何产生的，该如何避免？"></a>滑动冲突是如何产生的，该如何避免？</h2><p>在界面中只有有内外两层同时可以滑动，这个时候就产生了滑动冲突。例如，scrollView嵌套一个listView，因为listView和scrollView都是可以滑动的，这个时候就出现了滑动冲突。<br>常见的解决滑动冲突的方法有两种：外部拦截和内部拦截。<br>外部拦截法是指点击事件都先经过父容器的拦截处理（ACTION_DOWN不能被消耗），如果父容器需要此事件就拦截，如果不需要此事件就不拦截，这样就可以解决滑动冲突问题，这种方法比较符合点击事件的分发机制。外部拦截法需要重写父容器中的onIntercepetTouchEvent方法，在内部做相应的拦截即可。<br>外部拦截法是指父容器不拦截任何事件，所有的事件都传递给子元素，如果子元素需要此事件就直接消耗掉，否则就交给父容器进行处理，这种方法和Android分发机制不一致，需要配合requetDisallowInterceptTounchEvent方法才能正常工作，使用起来较外部拦截法稍显复杂。</p>
<h1 id="通信机制"><a href="#通信机制" class="headerlink" title="通信机制"></a>通信机制</h1><h2 id="IPC指什么？android中实现IPC有哪些"><a href="#IPC指什么？android中实现IPC有哪些" class="headerlink" title="IPC指什么？android中实现IPC有哪些"></a>IPC指什么？android中实现IPC有哪些</h2><p>IPC(Inter-Process Communication)，含义为进程间通信或者跨进程通信，是指两个进程之间进行数据交换的过程。<br>Android中主要通过Bundler(用于android四大组键间的进程间通信)、文件共享、AIDL、Messenger、ContentProvider和Socket来进行进程间通信。</p>
<h2 id="Binder指什么？"><a href="#Binder指什么？" class="headerlink" title="Binder指什么？"></a>Binder指什么？</h2><p>直观的说，binder是android中的一个类，他实现了IBinder接口。从IPC角度来说，Binder是Android中的一种跨进程通信方式；从android应用层来说，Binder是客户端和服务端进行通信的媒介，当bindService的时候，服务端会返回一个包含了服务端业务调用的Binder对象，通过这个Binder对象，客户端就可以获取服务端提供的服务或者数据，这里的服务包括普通服务和基于AIDL的服务。</p>
<h2 id="Binder机制"><a href="#Binder机制" class="headerlink" title="Binder机制"></a>Binder机制</h2><p>参考<a href="http://www.mamicode.com/info-detail-1513074.html" target="_blank" rel="noopener">这里</a>.</p>
<h2 id="进程间通信中可以使用sharedPreferences吗？"><a href="#进程间通信中可以使用sharedPreferences吗？" class="headerlink" title="进程间通信中可以使用sharedPreferences吗？"></a>进程间通信中可以使用sharedPreferences吗？</h2><p>不能。虽然从本质上来将，sharedPreferences也属于文件的一种，但是由于喜用对他的读/写有一定的缓存策略，即在内存中会有一份sharedPreferences文件的缓存，因此在多进程模式下，系统对他的读/写就变得不可靠，当面对高并发的读/写访问，sharedPreferences有很大的几率会丢失数据，因此，不建议在进程间中使用sharedPreferences。</p>
<h2 id="AIDL支持的数据类型有哪些？"><a href="#AIDL支持的数据类型有哪些？" class="headerlink" title="AIDL支持的数据类型有哪些？"></a>AIDL支持的数据类型有哪些？</h2><p>除short以外的基本数据类型（int、long、char、boolean、double等）;<br>String和CharSequence;<br>ArrayList、HashMap：里面的每个元素都必须被AIDL支持。<br>Parcelable： 所有实现了Parcelable接口的对象。<br>AIDL： 所有的AIDL接口本身也可以在AIDL文件中使用。</p>
<h2 id="handler原理"><a href="#handler原理" class="headerlink" title="handler原理"></a>handler原理</h2><p> Handler创建的时会采用当前线程Looper来构建内部的消息循环系统，如果当前线程没有Looper，那么就会报错。Handler创建完毕后，这个时候其内部的Looper以及MessageQueue就可以和Handler一起协同工作了，然后通过Handler的post方法将一个Runnable投递到Handler内部的Looper去处理，也可以通过Handler的send方法发送一个消息，这个消息同样会在Looper中去处理。其实post方法最终也是通过send方法完成的。Send方法被调用时，MessageQueue的enqueueMessage方法将这个消息放入消息队列中，然后Looper发现有新消息到来时，就会处理这个消息，最终消息中的Runnable或者Handler的handlerMessage方法就会被调用。注意，Looper是运行在创建Handler所在的线程中，这样依赖Handler中的业务逻辑就被切换到创建Handler所在的线程去执行了。<br><img src="http://ovec6nnof.bkt.clouddn.com/hanlder.png" alt="handler原理"></p>
<h2 id="AsyncTask的工作原理。"><a href="#AsyncTask的工作原理。" class="headerlink" title="AsyncTask的工作原理。"></a>AsyncTask的工作原理。</h2><p> AsyncTask是对Thread和Handler的组合包装，方便我们在后台线程中执行操作，然后将结构发送给主线程，从而在主线程中进行UI更新等操作。<br>  实现原理，AsyncTask中有两个线程和一个Handler，其中一个线程池（SerialExecuor）用于任务的排队，另一个线程池（THREAD_POOL_EXECUTOR）用于真正的执行任务。InternalHandler用于将要执行的环境从线程池切换到主线程。关于AsynchTask有以下几点需要注意：AsyncTask的对象必须在主线程中创建；execute方法必须在UI线程中调用；一个axyncTask对象只能执行一次，即执行一次execute方法；在android 1.6之前AsyncTask是串行执行任务的，而在android 1.6的时候开始采用线程池里处理并行任务，但在android 3.0以后，为了避免并发错误，asyncTask又采用了一个线程来穿行执行任务，同时也提供一个串行执行任务的方法executeOnExecutor方法。</p>
<h2 id="HandlerThread是什么？简述原理并举出一个应用的例子。"><a href="#HandlerThread是什么？简述原理并举出一个应用的例子。" class="headerlink" title="HandlerThread是什么？简述原理并举出一个应用的例子。"></a>HandlerThread是什么？简述原理并举出一个应用的例子。</h2><p>HandlerThread是一种可以使用Handler的Thread。他的实现也很简单，就是在run方法中通过Looper.prepare()来创建消息队列，并通过Looper.loop()来开启消息循环，这样在实际的使用中就允许在HandlerThread中创建Handler了。<br>HandlerThread在Android中的一个具体的使用场景是IntentService。IntentService封装了HandlerThread和Handler。</p>
<h2 id="IntentService使用和原理。"><a href="#IntentService使用和原理。" class="headerlink" title="IntentService使用和原理。"></a>IntentService使用和原理。</h2><p>IntentService是一种特殊的Service，他继承了Service并且他是一个抽象类，因此必须创建他的子类才能使用IntentService。IntentService可用于执行后台耗时的任务，当任务执行后他会自动停止，同时由于IntentService是服务的原因，这导致他的优先级比单纯的线程要高很多，所以IntentService比较适合执行一些高优先级的后台任务。<br>原理上来说，IntentService封装了Handler和Handler。在onCreate方法中创建一个HadnlerThread，然后使用它的Looper来构建一个Handler对象mServicehandler,这样通过mServiceHandler发送的消息最终都会在HandlerThread中执行。而在OnStart方法中，IntentService仅仅只是通过mServiceHandler发送了一个消息，这个消息会在HandlerThread中被处理。</p>
<h1 id="android中的线程与线程池"><a href="#android中的线程与线程池" class="headerlink" title="android中的线程与线程池"></a>android中的线程与线程池</h1><h2 id="Android中的线程池有什么优点？"><a href="#Android中的线程池有什么优点？" class="headerlink" title="Android中的线程池有什么优点？"></a>Android中的线程池有什么优点？</h2><p>可以重用线程池中的线程，避免因为线程的创建和销毁所带来的性能开销；<br>能有效控制线程池的最大并发数，避免大量的线程之间因互相抢夺资源而导致的阻塞现象；<br>能够对线程进行简单的管理，并提供定时执行已经指定间隔循环执行等功能。<br><a href="http://blog.csdn.net/Reoger/article/details/77145627" target="_blank" rel="noopener">ThreadPoolExecutor</a>是线程池的真正实现。</p>
<h1 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h1><h2 id="什么是ANR，产生的条件有那些"><a href="#什么是ANR，产生的条件有那些" class="headerlink" title="什么是ANR，产生的条件有那些"></a>什么是ANR，产生的条件有那些</h2><p>ANR即Application not responding，应用程序无响应。<br>产生条件：在Ui线程中5s无响应，在broadcastReceiver中10s无相应，或者在service中20s无相应都会导致ANR。<br>解决方法：运行在主线程里的任何方法都尽可能少做事情，耗时的操作应该放在子线程中进行操作，然后通过hander或者其他方法来通知主线程。<br>应用程序应该避免在broadcastReceiver里做耗时的操作或者计算，代替的是，如果想用Internt广播需要执行一个耗时的动作的话，应用程序应该启动一个servicer。</p>
<h2 id="造成ANR的主要原因"><a href="#造成ANR的主要原因" class="headerlink" title="造成ANR的主要原因"></a>造成ANR的主要原因</h2><p>主线程被IO操作阻塞</p>
<ul>
<li>Activity的所有生命周期回调都是执行在主线程的</li>
<li>Service默认执行在主线程中</li>
<li>BoardcastReceiver的回调onReceive()执行在主线程中</li>
<li>AsyncTask的回调除了doInBackground，其他都是在主线程中<br>没有使用子线程Looper的Handler的handlerMessage，post(Runnable)都是执行在主线程中</li>
</ul>
<h2 id="OOM指什么？什么时候会出现OOM。"><a href="#OOM指什么？什么时候会出现OOM。" class="headerlink" title="OOM指什么？什么时候会出现OOM。"></a>OOM指什么？什么时候会出现OOM。</h2><p>OOM指Out of memory（内存溢出），当前占用内存加上我们申请的内存资源超过了Dalvik虚拟机的最大内存限制就会抛出Out of memory异常<br>出现OOM的大部分情况都是内存泄露引起的、也有可能是操作系统本身内存就不足了。<br>这里只介绍内存泄露。</p>
<h2 id="内存泄露出现与避免"><a href="#内存泄露出现与避免" class="headerlink" title="内存泄露出现与避免"></a>内存泄露出现与避免</h2><p>总的来说，出现内存泄露的原因是本来应该被GC回收的资源，因为某种原因不能被回收，而导致内存越来越小，进而导致内存泄露，最终可能会导致OOM。<br>  出现内存泄露一般来自于两个原因：没有即使释放分配的内存（Cursor没有及时关闭）；<br>当应用不再需要这个对象，却没有释放该对象的所有引用。<br>检测内存泄露可以通过android studio的monitors工具，生成hprof文件，我们可以通过分析这个文件来分析内存泄露。当然，在android studio中分析内存泄露不是很直观，专业一点的工具就是MAT，我们可以将我们得到的hporf文件导入到MAT中进行分析。<br>当然，我们也可以通过在android项目中使用leakCanary来检测内存泄露。当应用程序出现内存泄露的时候，leakCanary会在通知栏通知我们，而且会提示我们内存泄露的相关信息，可以让我们迅速定给到内存泄露的的位置和原因。</p>
<h2 id="具体说明什么时候出现内存泄露"><a href="#具体说明什么时候出现内存泄露" class="headerlink" title="具体说明什么时候出现内存泄露"></a>具体说明什么时候出现内存泄露</h2><ol>
<li>Static 变量没有及时清空<br>但在类中定义了静态的Activity变量，把当前运行的Activity实例赋值给给这个静态常量。如果这个静态变量在activity的生命周期结束后没有清空，即会导致内存泄露；</li>
<li>注册了没有及时解注册<br>如动态注册中，如果我们在activity中注册了广播，在activity销毁之前就应该解注册，否则就会出现内存泄露；</li>
<li>资源或者属性动画没有及时关闭<br>在一类属性动画中，可以无线循环播放，如果在activity中播放此类动画且在activity生命周期中没有停止动画，那么动画会一直播放下去，尽管我们已经看不到效果了。至于资源回收典型的例子就是数据的Cursor了，当操作完数据库没有及时关闭Cursor也可能会导致内存泄露；</li>
<li>静态类或者内部类导致的内存泄露<br>这类导致的内存泄露究其原因也是因为static变量没有及时回收，这里不做介绍；</li>
<li>Handler或者AsyncTask导致的内存泄露<br>我们试想一种情况，在我们的activity结束之后，handler又给Ui线程发送了一个消息，或者是在activity结束之后，我们的AsynchTask任务才执行完。这两种情况都会导致activity实例无法被回收，导致内存泄露。</li>
</ol>
<h2 id="如何处理应用可能存在的crash"><a href="#如何处理应用可能存在的crash" class="headerlink" title="如何处理应用可能存在的crash"></a>如何处理应用可能存在的crash</h2><p>一般实现Thread类中UncaughtExceptionHandler对象，在发生崩溃时，系统会调用UncaughtExceptionHandler的uncaughtException方法，在uncaughtException方法中可以捕获到异常信息，可以选择把异常信息存储到SD卡中，然后在合适的时机通过网络将crash信息上传到服务器，这样就可以分析crash的原因了。当然，在crash发生时，我们可以先弹出一个对话框告诉用户crash了，然后在退出。</p>
<h1 id="新技术"><a href="#新技术" class="headerlink" title="新技术"></a>新技术</h1><h2 id="kotlin语言的优势"><a href="#kotlin语言的优势" class="headerlink" title="kotlin语言的优势"></a>kotlin语言的优势</h2><ul>
<li>简洁性<br>例如在<code>kotlin</code>中的数据类会自动获得所需的<code>getter、setters、toString</code>。</li>
<li>安全性<br>对象不能为空，避免出现空指针异常。</li>
<li>更优雅，遵循Effective Java设计</li>
</ul>
<ol>
<li>类默认不可继承</li>
<li>更有效的使用构建器模式</li>
<li>默认提供单利模版</li>
<li>重载必须使用<code>Override</code></li>
</ol>
<ul>
<li>完全兼容Java</li>
</ul>
<h1 id="开源库源码解析"><a href="#开源库源码解析" class="headerlink" title="开源库源码解析"></a>开源库源码解析</h1><h2 id="gile相关问题"><a href="#gile相关问题" class="headerlink" title="gile相关问题"></a><strong>gile相关问题</strong></h2><h2 id="如何使用OkHttp进行异步网络请求，并根据请求结果刷新UI"><a href="#如何使用OkHttp进行异步网络请求，并根据请求结果刷新UI" class="headerlink" title="如何使用OkHttp进行异步网络请求，并根据请求结果刷新UI"></a>如何使用OkHttp进行异步网络请求，并根据请求结果刷新UI</h2><p>##介绍一下OkHttp的整个异步请求流程<br>  前面两个问题都比较简单，具体可以参考<a href="http://reoger.tk/categories/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/">博客</a>中的解答。</p>
<p>##OkHttp对于网络请求都有哪些优化，如何实现的</p>
<h2 id="OkHttp框架中都用到了哪些设计模式"><a href="#OkHttp框架中都用到了哪些设计模式" class="headerlink" title="OkHttp框架中都用到了哪些设计模式"></a>OkHttp框架中都用到了哪些设计模式</h2><p>建造者模式、</p>
<h2 id="Okhttp的优势与劣势"><a href="#Okhttp的优势与劣势" class="headerlink" title="Okhttp的优势与劣势"></a>Okhttp的优势与劣势</h2><p>Android 开发中是可以直接使用现成的api进行网络请求的。是Square公司开源的针对Java和Android程序，封装的一个高性能http请求库，它的职责跟HttpUrlConnection 是一样的，支持同步、异步，而且 OkHttp 又封装了线程池，封装了数据转换，封装了参数使用、错误处理等，api使用起来更加方便。可以把它理解成是一个封装之后的类似HttpUrlConnection的东西，但是在使用的时候仍然需要自己再做一层封装，这样才能像使用一个框架一样更加顺手。</p>
<h2 id="Volley-VS-OkHttp"><a href="#Volley-VS-OkHttp" class="headerlink" title="Volley VS OkHttp"></a>Volley VS OkHttp</h2><p>volley不支持Post大数据，所以不适合上传文件。<br>okhttp支持同步、异步，封装了线程池，参数使用、错误处理等。<br>volley封装的扩展性强，支持HttpClient、HttpUrlConnection， 甚至支持OkHttp，而且Volley里面也封装了ImageLoader。<br>Okhttp基于NIO和OKio，所以性能上要比Volley更快，功能更加齐全，只是使用需要进一步的封装。</p>
<hr>
<h2 id="Gilde相关问题"><a href="#Gilde相关问题" class="headerlink" title="Gilde相关问题"></a><strong>Gilde相关问题</strong></h2><h1 id="更多的android面试资料"><a href="#更多的android面试资料" class="headerlink" title="更多的android面试资料"></a>更多的android面试资料</h1><ul>
<li><a href="https://github.com/GeniusVJR/LearningNotes" target="_blank" rel="noopener">https://github.com/GeniusVJR/LearningNotes</a></li>
<li><a href="https://github.com/Reoger/android-interview-questions-cn" target="_blank" rel="noopener">https://github.com/Reoger/android-interview-questions-cn</a></li>
<li><a href="http://www.jianshu.com/p/13786463635d" target="_blank" rel="noopener">http://www.jianshu.com/p/13786463635d</a></li>
<li><a href="https://mp.weixin.qq.com/s/bvB2U0-6ZJ1j06iVV4NmjQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/bvB2U0-6ZJ1j06iVV4NmjQ</a></li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/android%EF%BC%8Creview/" rel="tag"># android，review</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2017/08/19/gilde%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/" rel="prev" title="glide原理解读">
      <i class="fa fa-chevron-left"></i> glide原理解读
    </a></div>
      <div class="post-nav-item">
    <a href="/2017/08/30/%E6%96%87%E6%A1%A3%E6%9F%A5%E7%9C%8B%E5%99%A8/" rel="next" title="文档查看器">
      文档查看器 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#android四大组件"><span class="nav-number">1.</span> <span class="nav-text">android四大组件</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#activity的生命周期"><span class="nav-number">1.1.</span> <span class="nav-text">activity的生命周期</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#activity的四种启动模式"><span class="nav-number">1.2.</span> <span class="nav-text">activity的四种启动模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#activity的四种状态"><span class="nav-number">1.3.</span> <span class="nav-text">activity的四种状态</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#activity的启动方式"><span class="nav-number">1.4.</span> <span class="nav-text">activity的启动方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#activity的启动流程"><span class="nav-number">1.5.</span> <span class="nav-text">activity的启动流程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#activity异常停止时保存数据的方法"><span class="nav-number">1.6.</span> <span class="nav-text">activity异常停止时保存数据的方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Activity、Windows、View三者的区别和联系。"><span class="nav-number">1.7.</span> <span class="nav-text">Activity、Windows、View三者的区别和联系。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#activity间通过Intent传递数据的大小限制"><span class="nav-number">1.8.</span> <span class="nav-text">activity间通过Intent传递数据的大小限制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Fragment的生命周期"><span class="nav-number">1.9.</span> <span class="nav-text">Fragment的生命周期</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#添加fragment的步骤。"><span class="nav-number">1.10.</span> <span class="nav-text">添加fragment的步骤。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#添加Fragment时方法"><span class="nav-number">1.11.</span> <span class="nav-text">添加Fragment时方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Activity和Fragment之间的区别。"><span class="nav-number">1.12.</span> <span class="nav-text">Activity和Fragment之间的区别。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Activity与Fragment通信方案。"><span class="nav-number">1.13.</span> <span class="nav-text">Activity与Fragment通信方案。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Service的生命周期。"><span class="nav-number">1.14.</span> <span class="nav-text">Service的生命周期。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Service和Thread的区别"><span class="nav-number">1.15.</span> <span class="nav-text">Service和Thread的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Broadcast-Receiver的种类"><span class="nav-number">1.16.</span> <span class="nav-text">Broadcast Receiver的种类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#注册广播有几种方式？他们有什么区别？"><span class="nav-number">1.17.</span> <span class="nav-text">注册广播有几种方式？他们有什么区别？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Broadcast-Receiver实现机制"><span class="nav-number">1.18.</span> <span class="nav-text">Broadcast Receiver实现机制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LocalBroadcastManager特点"><span class="nav-number">1.19.</span> <span class="nav-text">LocalBroadcastManager特点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ContentProvider是如何实现数据共享的。"><span class="nav-number">1.20.</span> <span class="nav-text">ContentProvider是如何实现数据共享的。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Application的生命周期？"><span class="nav-number">1.21.</span> <span class="nav-text">Application的生命周期？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#View相关面试题"><span class="nav-number">2.</span> <span class="nav-text">View相关面试题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#简述View的事件分发机制。"><span class="nav-number">2.1.</span> <span class="nav-text">简述View的事件分发机制。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#view测量的宽-高和实际上的宽-高是一样的吗？"><span class="nav-number">2.2.</span> <span class="nav-text">view测量的宽&#x2F;高和实际上的宽&#x2F;高是一样的吗？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#在activity启动的时候就需要获取某个View的宽-高，该怎么做？"><span class="nav-number">2.3.</span> <span class="nav-text">在activity启动的时候就需要获取某个View的宽&#x2F;高，该怎么做？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#自定义View要注意哪些地方？"><span class="nav-number">2.4.</span> <span class="nav-text">自定义View要注意哪些地方？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#自定义view的步骤。"><span class="nav-number">2.5.</span> <span class="nav-text">自定义view的步骤。</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#动画相关"><span class="nav-number">3.</span> <span class="nav-text">动画相关</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Android中的三种动画。"><span class="nav-number">3.1.</span> <span class="nav-text">Android中的三种动画。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#可以对任意属性做动画吗？"><span class="nav-number">3.2.</span> <span class="nav-text">可以对任意属性做动画吗？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用动画的注意事项。"><span class="nav-number">3.3.</span> <span class="nav-text">使用动画的注意事项。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#怎么为activity设置切换效果，怎么给ViewGroup子元素添加子元素的出场动画？"><span class="nav-number">3.4.</span> <span class="nav-text">怎么为activity设置切换效果，怎么给ViewGroup子元素添加子元素的出场动画？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#动画中的差值器和估值器怎么理解？"><span class="nav-number">3.5.</span> <span class="nav-text">动画中的差值器和估值器怎么理解？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#滑动冲突是如何产生的，该如何避免？"><span class="nav-number">3.6.</span> <span class="nav-text">滑动冲突是如何产生的，该如何避免？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#通信机制"><span class="nav-number">4.</span> <span class="nav-text">通信机制</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#IPC指什么？android中实现IPC有哪些"><span class="nav-number">4.1.</span> <span class="nav-text">IPC指什么？android中实现IPC有哪些</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Binder指什么？"><span class="nav-number">4.2.</span> <span class="nav-text">Binder指什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Binder机制"><span class="nav-number">4.3.</span> <span class="nav-text">Binder机制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#进程间通信中可以使用sharedPreferences吗？"><span class="nav-number">4.4.</span> <span class="nav-text">进程间通信中可以使用sharedPreferences吗？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AIDL支持的数据类型有哪些？"><span class="nav-number">4.5.</span> <span class="nav-text">AIDL支持的数据类型有哪些？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#handler原理"><span class="nav-number">4.6.</span> <span class="nav-text">handler原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AsyncTask的工作原理。"><span class="nav-number">4.7.</span> <span class="nav-text">AsyncTask的工作原理。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HandlerThread是什么？简述原理并举出一个应用的例子。"><span class="nav-number">4.8.</span> <span class="nav-text">HandlerThread是什么？简述原理并举出一个应用的例子。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IntentService使用和原理。"><span class="nav-number">4.9.</span> <span class="nav-text">IntentService使用和原理。</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#android中的线程与线程池"><span class="nav-number">5.</span> <span class="nav-text">android中的线程与线程池</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Android中的线程池有什么优点？"><span class="nav-number">5.1.</span> <span class="nav-text">Android中的线程池有什么优点？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#性能优化"><span class="nav-number">6.</span> <span class="nav-text">性能优化</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是ANR，产生的条件有那些"><span class="nav-number">6.1.</span> <span class="nav-text">什么是ANR，产生的条件有那些</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#造成ANR的主要原因"><span class="nav-number">6.2.</span> <span class="nav-text">造成ANR的主要原因</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#OOM指什么？什么时候会出现OOM。"><span class="nav-number">6.3.</span> <span class="nav-text">OOM指什么？什么时候会出现OOM。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内存泄露出现与避免"><span class="nav-number">6.4.</span> <span class="nav-text">内存泄露出现与避免</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#具体说明什么时候出现内存泄露"><span class="nav-number">6.5.</span> <span class="nav-text">具体说明什么时候出现内存泄露</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#如何处理应用可能存在的crash"><span class="nav-number">6.6.</span> <span class="nav-text">如何处理应用可能存在的crash</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#新技术"><span class="nav-number">7.</span> <span class="nav-text">新技术</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#kotlin语言的优势"><span class="nav-number">7.1.</span> <span class="nav-text">kotlin语言的优势</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#开源库源码解析"><span class="nav-number">8.</span> <span class="nav-text">开源库源码解析</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#gile相关问题"><span class="nav-number">8.1.</span> <span class="nav-text">gile相关问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#如何使用OkHttp进行异步网络请求，并根据请求结果刷新UI"><span class="nav-number">8.2.</span> <span class="nav-text">如何使用OkHttp进行异步网络请求，并根据请求结果刷新UI</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#OkHttp框架中都用到了哪些设计模式"><span class="nav-number">8.3.</span> <span class="nav-text">OkHttp框架中都用到了哪些设计模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Okhttp的优势与劣势"><span class="nav-number">8.4.</span> <span class="nav-text">Okhttp的优势与劣势</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Volley-VS-OkHttp"><span class="nav-number">8.5.</span> <span class="nav-text">Volley VS OkHttp</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Gilde相关问题"><span class="nav-number">8.6.</span> <span class="nav-text">Gilde相关问题</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#更多的android面试资料"><span class="nav-number">9.</span> <span class="nav-text">更多的android面试资料</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">reoger</p>
  <div class="site-description" itemprop="description">reoger</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">56</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">33</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/reoger" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;reoger" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:reoger112@gmail.com" title="E-Mail → mailto:reoger112@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2018 – 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">reoger</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
