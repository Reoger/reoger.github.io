<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"reoger.tk","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="glide是一个快速，高效的开源媒体管理和Android的图像加载框架，将媒体解码，内存，磁盘缓存和资源池封装成一个简单易于使用的接口。  相对于同为图片加载的ImageLoader、Picasso来说，他支持的图片格式更加齐全（包括video、GIF、SVG等），支持缩略请求，内存管理也更加优秀。所以现在对其源码进行一个比较简单的分析。 源码导入本次源码解析均基于3.7.0的版本。在build">
<meta property="og:type" content="article">
<meta property="og:title" content="glide原理解读">
<meta property="og:url" content="http://reoger.tk/2017/08/19/gilde%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/index.html">
<meta property="og:site_name" content="reoger的记录">
<meta property="og:description" content="glide是一个快速，高效的开源媒体管理和Android的图像加载框架，将媒体解码，内存，磁盘缓存和资源池封装成一个简单易于使用的接口。  相对于同为图片加载的ImageLoader、Picasso来说，他支持的图片格式更加齐全（包括video、GIF、SVG等），支持缩略请求，内存管理也更加优秀。所以现在对其源码进行一个比较简单的分析。 源码导入本次源码解析均基于3.7.0的版本。在build">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://ovec6nnof.bkt.clouddn.com/19-11-17.jpg">
<meta property="article:published_time" content="2017-08-19T10:50:00.000Z">
<meta property="article:modified_time" content="2020-04-12T14:57:22.548Z">
<meta property="article:author" content="reoger">
<meta property="article:tag" content="source,glide">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://ovec6nnof.bkt.clouddn.com/19-11-17.jpg">

<link rel="canonical" href="http://reoger.tk/2017/08/19/gilde%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>glide原理解读 | reoger的记录</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">reoger的记录</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">--以后的你会感激现在那么努力的自己</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>日程表</a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://reoger.tk/2017/08/19/gilde%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="reoger">
      <meta itemprop="description" content="reoger">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="reoger的记录">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          glide原理解读
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-08-19 18:50:00" itemprop="dateCreated datePublished" datetime="2017-08-19T18:50:00+08:00">2017-08-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-12 22:57:22" itemprop="dateModified" datetime="2020-04-12T22:57:22+08:00">2020-04-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/" itemprop="url" rel="index"><span itemprop="name">源码解读</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <blockquote>
<p>glide是一个快速，高效的开源媒体管理和Android的图像加载框架，将媒体解码，内存，磁盘缓存和资源池封装成一个简单易于使用的接口。</p>
</blockquote>
<p>相对于同为图片加载的ImageLoader、Picasso来说，他支持的图片格式更加齐全（包括video、GIF、SVG等），支持缩略请求，内存管理也更加优秀。所以现在对其源码进行一个比较简单的分析。</p>
<h1 id="源码导入"><a href="#源码导入" class="headerlink" title="源码导入"></a>源码导入</h1><p>本次源码解析均基于<code>3.7.0</code>的版本。在<code>build.gradle</code>中添加如下的依赖：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compile &#39;com.github.bumptech.glide:glide:3.7.0&#39;</span><br></pre></td></tr></table></figure>
<p>点击同步，然后我们就可以开始我们的源码解析之旅了。<br>如果想看更多的版本信息，可以去他的<a href="https://github.com/bumptech/glide" target="_blank" rel="noopener">github主页</a>进行查看选择。</p>
<h1 id="简单使用示例"><a href="#简单使用示例" class="headerlink" title="简单使用示例"></a>简单使用示例</h1><p>相信使用过gilde来加载图片，对于gilde的使用都很清楚吧。下面是加载一张图片到ImageView中的关键代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ImageView imageView &#x3D; (ImageView) findViewById(R.id.imageView);</span><br><span class="line">Glide.with(this).load(R.mipmap.ic_launcher).into(imageView);</span><br></pre></td></tr></table></figure>
<p>  下面我就上面的简单的使用进行源码分析。</p>
<h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Glide.with(this).load(R.mipmap.ic_launcher).into(imageView);</span><br></pre></td></tr></table></figure>

<h2 id="总体设计图"><a href="#总体设计图" class="headerlink" title="总体设计图"></a>总体设计图</h2><p><img src="http://ovec6nnof.bkt.clouddn.com/19-11-17.jpg" alt="资料来源网络"><br><a algin="center" >资料来源于网络</a></p>
<h2 id="Glide-with"><a href="#Glide-with" class="headerlink" title="Glide.with()"></a>Glide.with()</h2><p>我们首先来看Glide中的第一步，with方法的实现。源码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public static RequestManager with(Context context) &#123;</span><br><span class="line">        RequestManagerRetriever retriever &#x3D; RequestManagerRetriever.get();</span><br><span class="line">        return retriever.get(context);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">public static RequestManager with(Activity activity) &#123;</span><br><span class="line">        RequestManagerRetriever retriever &#x3D; RequestManagerRetriever.get();</span><br><span class="line">        return retriever.get(activity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">public static RequestManager with(FragmentActivity activity) &#123;</span><br><span class="line">        RequestManagerRetriever retriever &#x3D; RequestManagerRetriever.get();</span><br><span class="line">        return retriever.get(activity);</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">@TargetApi(Build.VERSION_CODES.HONEYCOMB)</span><br><span class="line">public static RequestManager with(android.app.Fragment fragment) &#123;</span><br><span class="line">        RequestManagerRetriever retriever &#x3D; RequestManagerRetriever.get();</span><br><span class="line">        return retriever.get(fragment);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"> public static RequestManager with(Fragment fragment) &#123;</span><br><span class="line">        RequestManagerRetriever retriever &#x3D; RequestManagerRetriever.get();</span><br><span class="line">        return retriever.get(fragment);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，with有很多中重载，我们可以在with中传入Context，Activity、Fragment等等参数。但是在这些重载方法中，实现的逻辑大都差不多，首先是构建一个RequestManagerRetriever对象，然后调用get方法。那么我们先来看看RequestManagerRetriever.get();构建出来的对象的作用是什么。<br>继续看源码<code>RequestManagerRetriever.get()</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;** The singleton instance of RequestManagerRetriever. *&#x2F;</span><br><span class="line">private static final RequestManagerRetriever INSTANCE &#x3D; new RequestManagerRetriever();</span><br><span class="line"></span><br><span class="line">public static RequestManagerRetriever get() &#123;</span><br><span class="line">    return INSTANCE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Visible for testing.</span><br><span class="line">RequestManagerRetriever() &#123;</span><br><span class="line">    handler &#x3D; new Handler(Looper.getMainLooper(), this &#x2F;* Callback *&#x2F;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过上面的源码我们可以看到，<code>RequestManagerRetriever.get()</code>返回的就是一个静态的RequestManagerRetriever对象，这个对象初始化的时候就是只是创建了一个Handler。那么这个Handler什么时候触发，我们后面在讲。<br>我们注意到在<code>with()</code>方法中，我们最后返回的是<code>retriever.get(activity)</code>或者<code>retriever.get(fragment)</code>，具体实现如下代码所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public RequestManager get(FragmentActivity activity) &#123;</span><br><span class="line">    if (Util.isOnBackgroundThread()) &#123;&#x2F;&#x2F;如果是在后台线程</span><br><span class="line">        return get(activity.getApplicationContext());</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        assertNotDestroyed(activity);</span><br><span class="line">        FragmentManager fm &#x3D; activity.getSupportFragmentManager();</span><br><span class="line">        return supportFragmentGet(activity, fm);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public RequestManager get(Context context) &#123;</span><br><span class="line">    if (context &#x3D;&#x3D; null) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;You cannot start a load on a null Context&quot;);</span><br><span class="line">    &#125; else if (Util.isOnMainThread() &amp;&amp; !(context instanceof Application)) &#123;</span><br><span class="line">        if (context instanceof FragmentActivity) &#123;</span><br><span class="line">            return get((FragmentActivity) context);</span><br><span class="line">        &#125; else if (context instanceof Activity) &#123;</span><br><span class="line">            return get((Activity) context);</span><br><span class="line">        &#125; else if (context instanceof ContextWrapper) &#123;</span><br><span class="line">            return get(((ContextWrapper) context).getBaseContext());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return getApplicationManager(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以发现，如果当前是在后台线程的话，get()方法会返回一个<code>get(activity.getApplicationContext())</code>。我们继续来看<code>getApplicationManager(context)</code>的实现逻辑：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">private RequestManager getApplicationManager(Context context) &#123;</span><br><span class="line">    &#x2F;&#x2F; Either an application context or we&#39;re on a background thread.</span><br><span class="line">    if (applicationManager &#x3D;&#x3D; null) &#123;</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            if (applicationManager &#x3D;&#x3D; null) &#123;</span><br><span class="line">                &#x2F;&#x2F; Normally pause&#x2F;resume is taken care of by the fragment we add to the fragment or activity.</span><br><span class="line">                &#x2F;&#x2F; However, in this case since the manager attached to the application will not receive lifecycle</span><br><span class="line">                &#x2F;&#x2F; events, we must force the manager to start resumed using ApplicationLifecycle.</span><br><span class="line">                applicationManager &#x3D; new RequestManager(context.getApplicationContext(),</span><br><span class="line">                        new ApplicationLifecycle(), new EmptyRequestManagerTreeNode());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return applicationManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，getApplicationManager方法通过使用双重锁的单例模式通过<code>RequestManager</code>来实例化一个<code>applicationManager</code>,并将当作返回值。关于这个<code>applicationManager</code>我们稍后在做讨论。<br>在当前线程不是在主线程时，而且在<code>get()</code>方法中传入的不是Application对象时，会根据传入的对象来调用<code>RequestManagerRetriever</code>中重载的<code>get()</code>方法。<br>以传入的对象是Activity为例子，那么调用的就是<code>get((Activity) context)</code>，下面是该方法的实现逻辑：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">@TargetApi(Build.VERSION_CODES.HONEYCOMB)</span><br><span class="line">public RequestManager get(Activity activity) &#123;</span><br><span class="line">    if (Util.isOnBackgroundThread() || Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.HONEYCOMB) &#123;</span><br><span class="line">        return get(activity.getApplicationContext());</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        assertNotDestroyed(activity);&#x2F;&#x2F;判断activity是否已经销毁了</span><br><span class="line">        android.app.FragmentManager fm &#x3D; activity.getFragmentManager();</span><br><span class="line">        return fragmentGet(activity, fm);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@TargetApi(Build.VERSION_CODES.HONEYCOMB)</span><br><span class="line">RequestManager fragmentGet(Context context, android.app.FragmentManager fm) &#123;</span><br><span class="line">    RequestManagerFragment current &#x3D; getRequestManagerFragment(fm);</span><br><span class="line">    RequestManager requestManager &#x3D; current.getRequestManager();</span><br><span class="line">    if (requestManager &#x3D;&#x3D; null) &#123;</span><br><span class="line">        requestManager &#x3D; new RequestManager(context, current.getLifecycle(), current.getRequestManagerTreeNode());</span><br><span class="line">        current.setRequestManager(requestManager);</span><br><span class="line">    &#125;</span><br><span class="line">    return requestManager;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1)</span><br><span class="line">RequestManagerFragment getRequestManagerFragment(final android.app.FragmentManager fm) &#123;</span><br><span class="line">    RequestManagerFragment current &#x3D; (RequestManagerFragment) fm.findFragmentByTag(FRAGMENT_TAG);</span><br><span class="line">    if (current &#x3D;&#x3D; null) &#123;</span><br><span class="line">        current &#x3D; pendingRequestManagerFragments.get(fm);</span><br><span class="line">        if (current &#x3D;&#x3D; null) &#123;</span><br><span class="line">            current &#x3D; new RequestManagerFragment();</span><br><span class="line">            pendingRequestManagerFragments.put(fm, current);</span><br><span class="line">            fm.beginTransaction().add(current, FRAGMENT_TAG).commitAllowingStateLoss();</span><br><span class="line">            handler.obtainMessage(ID_REMOVE_FRAGMENT_MANAGER, fm).sendToTarget();</span><br><span class="line">            &#x2F;&#x2F;这里handler发送了一个消息，这里就是handler发送消息的时机</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return current;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;这里就是handler回调的时机，主要用于移除容器中的对象。</span><br><span class="line">@Override</span><br><span class="line">public boolean handleMessage(Message message) &#123;</span><br><span class="line">    boolean handled &#x3D; true;</span><br><span class="line">    Object removed &#x3D; null;</span><br><span class="line">    Object key &#x3D; null;</span><br><span class="line">    switch (message.what) &#123;</span><br><span class="line">        case ID_REMOVE_FRAGMENT_MANAGER:</span><br><span class="line">            android.app.FragmentManager fm &#x3D; (android.app.FragmentManager) message.obj;</span><br><span class="line">            key &#x3D; fm;</span><br><span class="line">            removed &#x3D; pendingRequestManagerFragments.remove(fm);</span><br><span class="line">            break;</span><br><span class="line">        case ID_REMOVE_SUPPORT_FRAGMENT_MANAGER:</span><br><span class="line">            FragmentManager supportFm &#x3D; (FragmentManager) message.obj;</span><br><span class="line">            key &#x3D; supportFm;</span><br><span class="line">            removed &#x3D; pendingSupportRequestManagerFragments.remove(supportFm);</span><br><span class="line">            break;</span><br><span class="line">        default:</span><br><span class="line">            handled &#x3D; false;</span><br><span class="line">    &#125;</span><br><span class="line">    if (handled &amp;&amp; removed &#x3D;&#x3D; null &amp;&amp; Log.isLoggable(TAG, Log.WARN)) &#123;</span><br><span class="line">        Log.w(TAG, &quot;Failed to remove expected request manager fragment, manager: &quot; + key);</span><br><span class="line">    &#125;</span><br><span class="line">    return handled;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总的来说，这里逻辑还是比较简单。首先在<code>get()</code>方法中，判断是否在后台线程且判断以下当前的版本。如果不是在后台线程且当前版本低于11，那么就会先判断当前activity是否销毁了，然后调用<code>ragmentGet(activity, fm)</code>方法。在<code>ragmentGet(activity, fm)</code>方法中，首先会调用<code>getRequestManagerFragment(fm)</code>来创建<code>RequestManagerFragment</code>对象，在<code>getRequestManagerFragment</code>方法中，首先创建一个<code>RequestManagerFragment</code>，然后将该对象放入到一个名为<code>pendingRequestManagerFragments的hashMap</code>对象中，然后通过<code>handler</code>发送一个消息。<br>在<code>handleMessage</code>中，收到这个消息之后，就会将<code>RequestManagerFragment</code>从<code>pendingRequestManagerFragments的hashMap</code>中移除。</p>
<p>这里有没有想这么一个问题，为什么要存在<code>pendingRequestManagerFragments</code>这么一个容器呢？当我们创建一个<code>RequestManagerFragment</code>之后，马上将其添加到<code>pendingRequestManagerFragments</code>中，然后运行<code>commitAllowingStateLoss</code>方法之后，又马上通过<code>Handler</code>发送一个消息让其从<code>pendingRequestManagerFragments</code>容器中移除，竟然如此，那何不如直接new一个<code>RequestManagerFragment</code>，然后直接提交就好了，何必用这个容器呢？以我的理解，这个<code>gilde</code>开发者为了增加gilde的可靠性而设计的，梳理第25-36行的逻辑如下：首先通过<code>findFragmentByTag</code>来查找<code>RequestManagerFragment</code>，若其返回空，继续下面的逻辑，否则直接返回找到的<code>RequestManagerFragment</code>对象。在<code>findFragmentByTag</code>返回空的情况下，会继续用<code>get()</code>方法来从容器中查找<code>RequestManagerFragment</code>对象，如果还是空就重新创建一个<code>RequestManagerFragment</code>，并将其添加到<code>pendingRequestManagerFragments</code>容器中,然后执行<code>commitAllowingStateLoss</code>方法，随后通过handler发送消息将<code>pendingRequestManagerFragments</code>容器中的该条记录移除。那么为什么要用<code>pendingRequestManagerFragments</code>呢？道理很简单，避免快速多次调用<code>getRequestManagerFragment</code>时，重复创建<code>RequestManagerFragment</code>对象。试想一下，当我们运行完第30行的时候，第二个<code>getRequestManagerFragment</code>请求已经到了，这个时候，第二个请求需要的<code>RequestManagerFragment</code>，就可以通过<code>get()</code>方法获取，而不要去重新创建。当运行完第31行时，第二个<code>getRequestManagerFragment</code>就可以直接通过<code>findFragmentByTag</code>方法获取。这种情况是可能产生的，设想这样一种情况：当我们在Activity A和B都同时有<code>Gilde.with()</code>,我们在进入activity A后秒切ACtivity B就可能会导致上面所说的情况，只是可能性比较低，但毕竟是可能的，所以<code>gilde</code>开发团队就用了一个容器来存储当前的<code>RequestManagerFragment</code>对象，进一步提高其性能。<br>关于<code>commitAllowingStateLoss</code>方法，这里我们不做详细的讨论，具体可参考<a href="https://jucongyuan.com/2015/02/25/%E4%BB%8E%E6%BA%90%E7%A0%81%E7%9C%8Bcommit%E5%92%8CcommitAllowingStateLoss%E6%96%B9%E6%B3%95%E5%8C%BA%E5%88%AB/" target="_blank" rel="noopener">这里</a>。<br>然后在<code>fragmentGet</code>方法中也会调用<code>RequestManager</code>方法。似曾相识是吧，没错，我们在<code>getApplicationManager</code>方法中也调用了这个方法！！那么下面来看看这个方法究竟做了写什么吧。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">public RequestManager(Context context, Lifecycle lifecycle, RequestManagerTreeNode treeNode) &#123;</span><br><span class="line">    this(context, lifecycle, treeNode, new RequestTracker(), new ConnectivityMonitorFactory());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">RequestManager(Context context, final Lifecycle lifecycle, RequestManagerTreeNode treeNode,</span><br><span class="line">        RequestTracker requestTracker, ConnectivityMonitorFactory factory) &#123;</span><br><span class="line">    this.context &#x3D; context.getApplicationContext();</span><br><span class="line">    this.lifecycle &#x3D; lifecycle;</span><br><span class="line">    this.treeNode &#x3D; treeNode;</span><br><span class="line">    this.requestTracker &#x3D; requestTracker;</span><br><span class="line">    this.glide &#x3D; Glide.get(context); &#x2F;&#x2F;创建一个Glide对象</span><br><span class="line">    this.optionsApplier &#x3D; new OptionsApplier();</span><br><span class="line"></span><br><span class="line">    ConnectivityMonitor connectivityMonitor &#x3D; factory.build(context,</span><br><span class="line">            new RequestManagerConnectivityListener(requestTracker));</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; If we&#39;re the application level request manager, we may be created on a background thread. In that case we</span><br><span class="line">    &#x2F;&#x2F; cannot risk synchronously pausing or resuming requests, so we hack around the issue by delaying adding</span><br><span class="line">    &#x2F;&#x2F; ourselves as a lifecycle listener by posting to the main thread. This should be entirely safe.</span><br><span class="line">    if (Util.isOnBackgroundThread()) &#123;</span><br><span class="line">        new Handler(Looper.getMainLooper()).post(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                lifecycle.addListener(RequestManager.this);&#x2F;&#x2F;将生命周期进行绑定</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        lifecycle.addListener(this);&#x2F;&#x2F;绑定生命周期</span><br><span class="line">    &#125;</span><br><span class="line">    lifecycle.addListener(connectivityMonitor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;单例模式创建Gilde对象</span><br><span class="line"> public static Glide get(Context context) &#123;</span><br><span class="line">        if (glide &#x3D;&#x3D; null) &#123;</span><br><span class="line">            synchronized (Glide.class) &#123;</span><br><span class="line">                if (glide &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    Context applicationContext &#x3D; context.getApplicationContext();</span><br><span class="line">                    List&lt;GlideModule&gt; modules &#x3D; new ManifestParser(applicationContext).parse();</span><br><span class="line"></span><br><span class="line">                    GlideBuilder builder &#x3D; new GlideBuilder(applicationContext);</span><br><span class="line">                    for (GlideModule module : modules) &#123;</span><br><span class="line">                        module.applyOptions(applicationContext, builder);</span><br><span class="line">                    &#125;</span><br><span class="line">                    glide &#x3D; builder.createGlide();</span><br><span class="line">                    for (GlideModule module : modules) &#123;</span><br><span class="line">                        module.registerComponents(applicationContext, glide);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return glide;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;在这里进行一系列的初始化，    </span><br><span class="line"> Glide createGlide() &#123;</span><br><span class="line">        if (sourceService &#x3D;&#x3D; null) &#123;</span><br><span class="line">            final int cores &#x3D; Math.max(1, Runtime.getRuntime().availableProcessors());</span><br><span class="line">            sourceService &#x3D; new FifoPriorityThreadPoolExecutor(cores);</span><br><span class="line">        &#125;</span><br><span class="line">        if (diskCacheService &#x3D;&#x3D; null) &#123;</span><br><span class="line">            diskCacheService &#x3D; new FifoPriorityThreadPoolExecutor(1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        MemorySizeCalculator calculator &#x3D; new MemorySizeCalculator(context);</span><br><span class="line">        if (bitmapPool &#x3D;&#x3D; null) &#123;</span><br><span class="line">            if (Build.VERSION.SDK_INT &gt;&#x3D; Build.VERSION_CODES.HONEYCOMB) &#123;</span><br><span class="line">                int size &#x3D; calculator.getBitmapPoolSize();</span><br><span class="line">                bitmapPool &#x3D; new LruBitmapPool(size);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                bitmapPool &#x3D; new BitmapPoolAdapter();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (memoryCache &#x3D;&#x3D; null) &#123;</span><br><span class="line">            memoryCache &#x3D; new LruResourceCache(calculator.getMemoryCacheSize());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (diskCacheFactory &#x3D;&#x3D; null) &#123;</span><br><span class="line">            diskCacheFactory &#x3D; new InternalCacheDiskCacheFactory(context);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (engine &#x3D;&#x3D; null) &#123;</span><br><span class="line">            engine &#x3D; new Engine(memoryCache, diskCacheFactory, diskCacheService, sourceService);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (decodeFormat &#x3D;&#x3D; null) &#123;</span><br><span class="line">            decodeFormat &#x3D; DecodeFormat.DEFAULT;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return new Glide(engine, memoryCache, bitmapPool, context, decodeFormat);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>不难看出，在<code>RequestManager</code>构造方法中，对生命周期进行了绑定，并绑定了监听。然后通过<code>Glide.get(context);</code>创建一个Gilde对象，在<code>Glide.get(）</code>方法中，<br>这里<code>createGlide</code>方法中，我们通过<code>new Gidle</code>创建了一个Gilde对象,简单介绍以下其中的四个参数,他们都是在createGlide中生成的。</p>
<ul>
<li>MemoryCache 内存缓存</li>
<li>BitmapPool 图片池</li>
<li>DecodeFormat 图片格式</li>
<li>Engine 引擎类<br>我们对其值的获取和计算也进行一个简单的了解：我们首先来看memoryCacher的大小是由<code>calculator.getMemoryCacheSize()</code>计算，来看其实现：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;首先是其调用MemorySizeCalculator的构造方法，最终会回调到如下构造方法中</span><br><span class="line"> MemorySizeCalculator(Context context, ActivityManager activityManager, ScreenDimensions screenDimensions) &#123;</span><br><span class="line">        this.context &#x3D; context;</span><br><span class="line">        final int maxSize &#x3D; getMaxSize(activityManager);</span><br><span class="line"></span><br><span class="line">        final int screenSize &#x3D; screenDimensions.getWidthPixels() * screenDimensions.getHeightPixels()</span><br><span class="line">                * BYTES_PER_ARGB_8888_PIXEL;(宽*高*4)</span><br><span class="line"></span><br><span class="line">        int targetPoolSize &#x3D; screenSize * BITMAP_POOL_TARGET_SCREENS;(宽*高*4*4)</span><br><span class="line">        int targetMemoryCacheSize &#x3D; screenSize * MEMORY_CACHE_TARGET_SCREENS;(宽*高*4*2)</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;判断是否超过最大值,否则就等比缩小</span><br><span class="line">        if (targetMemoryCacheSize + targetPoolSize &lt;&#x3D; maxSize) &#123;</span><br><span class="line">            memoryCacheSize &#x3D; targetMemoryCacheSize;</span><br><span class="line">            bitmapPoolSize &#x3D; targetPoolSize;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            int part &#x3D; Math.round((float) maxSize &#x2F; (BITMAP_POOL_TARGET_SCREENS + MEMORY_CACHE_TARGET_SCREENS));</span><br><span class="line">            memoryCacheSize &#x3D; part * MEMORY_CACHE_TARGET_SCREENS;</span><br><span class="line">            bitmapPoolSize &#x3D; part * BITMAP_POOL_TARGET_SCREENS;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#x2F;&#x2F;该方法主要用于计算最大内存。如果是低配手机就每个进程可用的最大内存乘以0.33,否则就每个进程可用的最大内存乘以0.4</span><br><span class="line">private static int getMaxSize(ActivityManager activityManager) &#123;</span><br><span class="line">        final int memoryClassBytes &#x3D; activityManager.getMemoryClass() * 1024 * 1024;</span><br><span class="line">        &#x2F;&#x2F;每个进程可用的最大内存</span><br><span class="line">        final boolean isLowMemoryDevice &#x3D; isLowMemoryDevice(activityManager);</span><br><span class="line">        return Math.round(memoryClassBytes</span><br><span class="line">                * (isLowMemoryDevice ? LOW_MEMORY_MAX_SIZE_MULTIPLIER : MAX_SIZE_MULTIPLIER));</span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;这里直接返回已经在构造函数中计算好的内容缓存。</span><br><span class="line">   public int getMemoryCacheSize() &#123;</span><br><span class="line">        return memoryCacheSize;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
从上面的代码可以分析出来，内容缓存memoryCacheSize的大小一般为屏幕的宽<em>高</em>4*2，当然，也有可能等比例缩小。<br>然后图片池BitmapPool的计算就比较简单了。在<code>createGlide</code>中计算BitmapPool的方法为：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> if (bitmapPool &#x3D;&#x3D; null) &#123;</span><br><span class="line">        if (Build.VERSION.SDK_INT &gt;&#x3D; Build.VERSION_CODES.HONEYCOMB) &#123;</span><br><span class="line">            int size &#x3D; calculator.getBitmapPoolSize();</span><br><span class="line">            bitmapPool &#x3D; new LruBitmapPool(size);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            bitmapPool &#x3D; new BitmapPoolAdapter();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
可以看出来，<code>bitmapPool</code>在android3.0以后用<code>calculator.getBitmapPoolSize()</code>进行计算，这个值在前面的<code>MemorySizeCalculator</code>已经计算出来了，而在MemorySizeCalculator中只是将其返回。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public int getBitmapPoolSize() &#123;</span><br><span class="line">      return bitmapPoolSize;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
可以分析出来，图片池用的是targetPoolSize(即一般是缓存大小是屏幕的宽<em>高</em>4*4)。<br>接下来是DecodeFormat 图片格式<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;GlideBuilder中的createGlide方法</span><br><span class="line">decodeFormat &#x3D; DecodeFormat.DEFAULT;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;public enum DecodeFormat </span><br><span class="line"> public static final DecodeFormat DEFAULT &#x3D; PREFER_RGB_565;</span><br></pre></td></tr></table></figure>
即默认的图片格式是PREFER_RGB_565；</li>
</ul>
<p>最后一个Engine引擎类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;GlideBuilder中的createGlide方法</span><br><span class="line">if (engine &#x3D;&#x3D; null) &#123;</span><br><span class="line">engine &#x3D; new Engine(memoryCache, diskCacheFactory, diskCacheService, sourceService);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>engine里面的主要参数：</strong></p>
<ul>
<li>内存缓存 memoryCache</li>
<li>本地缓存 diskCacheFactory</li>
<li>处理源资源的线程池 sourceService</li>
<li>处理本地缓存的线程池 diskCacheService<br>第一个参数就是我们前面已经计算出来的<code>memoryCache</code>，这里就不在介绍，加下来介绍第二个参数diskCacheFactory：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;GlideBuilder中的createGlide方法</span><br><span class="line">  if (diskCacheFactory &#x3D;&#x3D; null) &#123;</span><br><span class="line">            diskCacheFactory &#x3D; new InternalCacheDiskCacheFactory(context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;InternalCacheDiskCacheFactory中的方法</span><br><span class="line">public InternalCacheDiskCacheFactory(Context context) &#123;</span><br><span class="line">        this(context, DiskCache.Factory.DEFAULT_DISK_CACHE_DIR, DiskCache.Factory.DEFAULT_DISK_CACHE_SIZE);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;DiskCache接口中的内容</span><br><span class="line"> interface Factory &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;250 MB of cache. </span><br><span class="line">    int DEFAULT_DISK_CACHE_SIZE &#x3D; 250 * 1024 * 1024;</span><br><span class="line">    String DEFAULT_DISK_CACHE_DIR &#x3D; &quot;image_manager_disk_cache&quot;;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;Returns a new disk cache, or &#123;@code null&#125; if no disk cache could be created.</span><br><span class="line">    DiskCache build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的代码我们不难看出：<strong>默认大小为250m,默认目录:image_manager_disk_cache</strong>。</p>
<p>接下来，我们继续看：<br>sourceService 处理源资源的线程池</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;GlideBuilder中的createGlide方法</span><br><span class="line">if (sourceService &#x3D;&#x3D; null) &#123;</span><br><span class="line">        final int cores &#x3D; Math.max(1, Runtime.getRuntime().availableProcessors());</span><br><span class="line">        sourceService &#x3D; new FifoPriorityThreadPoolExecutor(cores);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#x2F;&#x2F;下面的方法都是在FifoPriorityThreadPoolExecutor类中，且该类继承ThreadPoolExecutor</span><br><span class="line">public FifoPriorityThreadPoolExecutor(int poolSize) &#123;</span><br><span class="line">    this(poolSize, UncaughtThrowableStrategy.LOG);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public FifoPriorityThreadPoolExecutor(int poolSize, UncaughtThrowableStrategy uncaughtThrowableStrategy) &#123;</span><br><span class="line">    this(poolSize, poolSize, 0, TimeUnit.MILLISECONDS, new DefaultThreadFactory(),</span><br><span class="line">        uncaughtThrowableStrategy);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public FifoPriorityThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAlive, TimeUnit timeUnit,</span><br><span class="line">        ThreadFactory threadFactory, UncaughtThrowableStrategy uncaughtThrowableStrategy) &#123;</span><br><span class="line">    super(corePoolSize, maximumPoolSize, keepAlive, timeUnit, new PriorityBlockingQueue&lt;Runnable&gt;(), threadFactory);</span><br><span class="line">    this.uncaughtThrowableStrategy &#x3D; uncaughtThrowableStrategy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过上面的源码，我们不难分析出diskCacheService其实一个线程池，里面的核心线程数为可用的处理器的个数。</p>
<p>最后是处理本地缓存的线程池 diskCacheService的实现，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;GlideBuilder中的createGlide方法</span><br><span class="line">if (diskCacheService &#x3D;&#x3D; null) &#123;</span><br><span class="line">        diskCacheService &#x3D; new FifoPriorityThreadPoolExecutor(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>核心线程数为1，最多的线程也为1。至于FifoPriorityThreadPoolExecutor方法的实现，可以参考前面的代码。</p>
<p>到这里，我们的with方法的实现就解析的差不多了。最后总结一下<code>with</code>方法的实现逻辑：<br>with方法可以传入不同的参数，根据不同的参数和线程环境来绑定不同的生命周期。如果在子线程且SDK&gt;=11即android3.0以后，则绑定的是Application的生命周期;如传入的是Activity且在主线程，则将gilde和activity的生命周期绑定（通过创建一个无界面的Fragment，让请求和Activity的生命周期同步），然后添加监听。</p>
<h2 id="load方法"><a href="#load方法" class="headerlink" title="load方法"></a>load方法</h2><p>通过的，load方法也有很多的重载。load在RequestManager类中的实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public DrawableTypeRequest&lt;String&gt; load(String string) &#123;</span><br><span class="line">    return (DrawableTypeRequest&lt;String&gt;) fromString().load(string);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public DrawableTypeRequest&lt;Uri&gt; load(Uri uri) &#123;</span><br><span class="line">    return (DrawableTypeRequest&lt;Uri&gt;) fromUri().load(uri);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public DrawableTypeRequest&lt;File&gt; load(File file) &#123;</span><br><span class="line">    return (DrawableTypeRequest&lt;File&gt;) fromFile().load(file);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public DrawableTypeRequest&lt;Integer&gt; load(Integer resourceId) &#123;</span><br><span class="line">    return (DrawableTypeRequest&lt;Integer&gt;) fromResource().load(resourceId);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Deprecated</span><br><span class="line">public DrawableTypeRequest&lt;URL&gt; load(URL url) &#123;</span><br><span class="line">    return (DrawableTypeRequest&lt;URL&gt;) fromUrl().load(url);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Deprecated</span><br><span class="line">public DrawableTypeRequest&lt;byte[]&gt; load(byte[] model, final String id) &#123;</span><br><span class="line">    return (DrawableTypeRequest&lt;byte[]&gt;) load(model).signature(new StringSignature(id));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public DrawableTypeRequest&lt;byte[]&gt; load(byte[] model) &#123;</span><br><span class="line">    return (DrawableTypeRequest&lt;byte[]&gt;) fromBytes().load(model);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public &lt;T&gt; DrawableTypeRequest&lt;T&gt; load(T model) &#123;</span><br><span class="line">    return (DrawableTypeRequest&lt;T&gt;) loadGeneric(getSafeClass(model)).load(model);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，load也有很多的重载方法，具体的作用和参数就不做说明了。通过源码我们可以看到，无论是那个load的重载，最终都会返回一个<code>DrawableTypeRequest</code> 对象(继承自DrawableRequestBuilder类）<br>我们不可能将所有的load方法分析一篇，这里我就以load(URL url)这个方法为例进行说明，至于其他的load方法，可以自行去理解。<br>首先，我们在<code>RequestManager.java</code>中，我们我们看到load的实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">@Deprecated</span><br><span class="line">public DrawableTypeRequest&lt;URL&gt; load(URL url) &#123;</span><br><span class="line">    return (DrawableTypeRequest&lt;URL&gt;) fromUrl().load(url);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Deprecated</span><br><span class="line">public DrawableTypeRequest&lt;URL&gt; fromUrl() &#123;</span><br><span class="line">    return loadGeneric(URL.class);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private &lt;T&gt; DrawableTypeRequest&lt;T&gt; loadGeneric(Class&lt;T&gt; modelClass) &#123;</span><br><span class="line">    ModelLoader&lt;T, InputStream&gt; streamModelLoader &#x3D; Glide.buildStreamModelLoader(modelClass, context);</span><br><span class="line">    ModelLoader&lt;T, ParcelFileDescriptor&gt; fileDescriptorModelLoader &#x3D;</span><br><span class="line">            Glide.buildFileDescriptorModelLoader(modelClass, context);</span><br><span class="line">    if (modelClass !&#x3D; null &amp;&amp; streamModelLoader &#x3D;&#x3D; null &amp;&amp; fileDescriptorModelLoader &#x3D;&#x3D; null) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;Unknown type &quot; + modelClass + &quot;. You must provide a Model of a type for&quot;</span><br><span class="line">                + &quot; which there is a registered ModelLoader, if you are using a custom model, you must first call&quot;</span><br><span class="line">                + &quot; Glide#register with a ModelLoaderFactory for your custom model class&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return optionsApplier.apply(</span><br><span class="line">            new DrawableTypeRequest&lt;T&gt;(modelClass, streamModelLoader, fileDescriptorModelLoader, context,</span><br><span class="line">                    glide, requestTracker, lifecycle, optionsApplier));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过上面的源码，我们发现加载图片UR这一个load方法中的逻辑是非常简单的，只是简单的调用<code>fromUrl().load(url)</code>方法（先调用<code>fromUrl()</code>,后调用<code>load(url)</code>，典型的build模式）。而<code>fromUrl()</code>的代码也是非常简单的，只是调用了<code>loadGeneric(URL.class)</code>这么一个方法。然后继续来看<code>loadGeneric(URL.class)</code>方法，这个方法也比较简单，用<code>Glide.buildStreamModelLoader</code>和<code>Glide.buildFileDescriptorModelLoader()</code>来获得<code>ModeiLoade</code>对象，这里面的具体实现就不做详细的讨论了，比较复杂，或许等我以后弄清楚了会加上。<br>在<code>loadGeneric(URL.class)</code>方法中，我们返回的是<code>DrawableTypeRequest</code>对象，所以最后创建了一个<code>DrawableTypeRequest</code>对象，并将相关参数应用到这个<code>DrawableTypeRequest</code>对象上，那么我们对<code>DrawableTypeRequest</code>这个对象就有必要进行以下分析了。<br>以下是<code>DrawableTypeRequest.java</code>的源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">public class DrawableTypeRequest&lt;ModelType&gt; extends DrawableRequestBuilder&lt;ModelType&gt; implements DownloadOptions &#123;</span><br><span class="line">    private final ModelLoader&lt;ModelType, InputStream&gt; streamModelLoader;</span><br><span class="line">    private final ModelLoader&lt;ModelType, ParcelFileDescriptor&gt; fileDescriptorModelLoader;</span><br><span class="line">    private final RequestManager.OptionsApplier optionsApplier;</span><br><span class="line"></span><br><span class="line">    private static &lt;A, Z, R&gt; FixedLoadProvider&lt;A, ImageVideoWrapper, Z, R&gt; buildProvider(Glide glide,</span><br><span class="line">            ModelLoader&lt;A, InputStream&gt; streamModelLoader,</span><br><span class="line">            ModelLoader&lt;A, ParcelFileDescriptor&gt; fileDescriptorModelLoader, Class&lt;Z&gt; resourceClass,</span><br><span class="line">            Class&lt;R&gt; transcodedClass,</span><br><span class="line">            ResourceTranscoder&lt;Z, R&gt; transcoder) &#123;</span><br><span class="line">        if (streamModelLoader &#x3D;&#x3D; null &amp;&amp; fileDescriptorModelLoader &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (transcoder &#x3D;&#x3D; null) &#123;</span><br><span class="line">            transcoder &#x3D; glide.buildTranscoder(resourceClass, transcodedClass);</span><br><span class="line">        &#125;</span><br><span class="line">        DataLoadProvider&lt;ImageVideoWrapper, Z&gt; dataLoadProvider &#x3D; glide.buildDataProvider(ImageVideoWrapper.class,</span><br><span class="line">                resourceClass);</span><br><span class="line">        ImageVideoModelLoader&lt;A&gt; modelLoader &#x3D; new ImageVideoModelLoader&lt;A&gt;(streamModelLoader,</span><br><span class="line">                fileDescriptorModelLoader);</span><br><span class="line">        return new FixedLoadProvider&lt;A, ImageVideoWrapper, Z, R&gt;(modelLoader, transcoder, dataLoadProvider);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DrawableTypeRequest(Class&lt;ModelType&gt; modelClass, ModelLoader&lt;ModelType, InputStream&gt; streamModelLoader,</span><br><span class="line">            ModelLoader&lt;ModelType, ParcelFileDescriptor&gt; fileDescriptorModelLoader, Context context, Glide glide,</span><br><span class="line">            RequestTracker requestTracker, Lifecycle lifecycle, RequestManager.OptionsApplier optionsApplier) &#123;</span><br><span class="line">        super(context, modelClass,</span><br><span class="line">                buildProvider(glide, streamModelLoader, fileDescriptorModelLoader, GifBitmapWrapper.class,</span><br><span class="line">                        GlideDrawable.class, null),</span><br><span class="line">                glide, requestTracker, lifecycle);</span><br><span class="line">        this.streamModelLoader &#x3D; streamModelLoader;</span><br><span class="line">        this.fileDescriptorModelLoader &#x3D; fileDescriptorModelLoader;</span><br><span class="line">        this.optionsApplier &#x3D; optionsApplier;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Attempts to always load the resource as a &#123;@link android.graphics.Bitmap&#125;, even if it could actually be animated.</span><br><span class="line">     *</span><br><span class="line">     * @return A new request builder for loading a &#123;@link android.graphics.Bitmap&#125;</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public BitmapTypeRequest&lt;ModelType&gt; asBitmap() &#123;</span><br><span class="line">        return optionsApplier.apply(new BitmapTypeRequest&lt;ModelType&gt;(this, streamModelLoader,</span><br><span class="line">                fileDescriptorModelLoader, optionsApplier));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Attempts to always load the resource as a &#123;@link com.bumptech.glide.load.resource.gif.GifDrawable&#125;.</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     *     If the underlying data is not a GIF, this will fail. As a result, this should only be used if the model</span><br><span class="line">     *     represents an animated GIF and the caller wants to interact with the GIfDrawable directly. Normally using</span><br><span class="line">     *     just an &#123;@link com.bumptech.glide.DrawableTypeRequest&#125; is sufficient because it will determine whether or</span><br><span class="line">     *     not the given data represents an animated GIF and return the appropriate animated or not animated</span><br><span class="line">     *     &#123;@link android.graphics.drawable.Drawable&#125; automatically.</span><br><span class="line">     * &lt;&#x2F;p&gt;</span><br><span class="line">     *</span><br><span class="line">     * @return A new request builder for loading a &#123;@link com.bumptech.glide.load.resource.gif.GifDrawable&#125;.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public GifTypeRequest&lt;ModelType&gt; asGif() &#123;</span><br><span class="line">        return optionsApplier.apply(new GifTypeRequest&lt;ModelType&gt;(this, streamModelLoader, optionsApplier));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * &#123;@inheritDoc&#125;</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public &lt;Y extends Target&lt;File&gt;&gt; Y downloadOnly(Y target) &#123;</span><br><span class="line">        return getDownloadOnlyRequest().downloadOnly(target);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * &#123;@inheritDoc&#125;</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public FutureTarget&lt;File&gt; downloadOnly(int width, int height) &#123;</span><br><span class="line">        return getDownloadOnlyRequest().downloadOnly(width, height);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private GenericTranscodeRequest&lt;ModelType, InputStream, File&gt; getDownloadOnlyRequest() &#123;</span><br><span class="line">        return optionsApplier.apply(new GenericTranscodeRequest&lt;ModelType, InputStream, File&gt;(File.class, this,</span><br><span class="line">                streamModelLoader, InputStream.class, File.class, optionsApplier));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过注释，我们大概也可以猜到这个类是用来做什么的。<br><code>DrawableTypeRequest</code>是一个用于创建加载请求的类，该加载方法可以直接加载动画的GIF或者Bitmap drawable格式的图片。他提供了两个的方法<code>asBitmap()</code>和<code>asGif()</code>来强制指定加载静态图片和GIF图片。通过观察这两个方法的实现，发现他们的实现其实是通过创建<code>BitmapTypeRequest</code>和<code>GifTypeRequest</code>来实现的，当然默认的实现还是通过创建<code>DrawableTypeRequest</code>实现的。<br>但是我们发现，在<code>DrawableTypeRequest</code>这个类中，并没有<code>load</code>这个方法，而在<code>RequestManager.java</code>中的<code>loadGeneric</code>方法中，最后返回的是<code>DrawableTypeRequest</code>对象，这就说明在<code>DrawableTypeRequest</code>肯定存在load方法的实现，我们在上面的代码中无法直接看到其方法的存在，那其实现很可能存在其父类中。通过上面的代码可知，<code>RequestManager</code>的父类是<code>DrawableRequestBuilder</code>。至于其父类<code>DrawableRequestBuilder</code>的实现，这里就不全部贴出来了，只贴出<code>load</code>方法的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line"> public DrawableRequestBuilder&lt;ModelType&gt; load(ModelType model) &#123;</span><br><span class="line">     super.load(model);</span><br><span class="line">     return this;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>当然，在<code>DrawableRequestBuilder</code>中，<code>load()</code>只是其中的一个方法而已，在这个类中，还定义了<code>gilde</code>常用的一些API方法，例如<code>error()</code>,<code>placeholder()</code>,<code>crossFade()</code>等等，至于其实现，可以参照源码去了解。下面继续来对<code>load()</code>方法进一步的深入，可以看到<code>load</code>方法调用了父类的<code>load</code>方法，接下来我们查看 其父类<code>GenericRequesBuilder.java</code>中<code>load</code>方法的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public GenericRequestBuilder&lt;ModelType, DataType, ResourceType, TranscodeType&gt; load(ModelType model) &#123;</span><br><span class="line">     this.model &#x3D; model;</span><br><span class="line">     isModelSet &#x3D; true;</span><br><span class="line">     return this;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，最终<code>load()</code>方法的实现很简单，只是设置了加载的类型，然后就返回了<code>this</code>，当然，这个<code>this</code>最终就变成了<code>DrawableTypeRequest</code>对象。到此,<code>load</code>方法基本流程已经差不多了，下面将分析<code>into()</code>方法的实现。</p>
<h2 id="into"><a href="#into" class="headerlink" title="into()"></a>into()</h2><p>前面的三个方法最终都是为了最后这个into方法做准备，所以搞懂<code>into</code>方法，对gilde源码的理解是非常非常重要的，下面我们进行<code>into</code>方法的解析。<br>首先，我们直接调用的<code>into</code>方法的实现是在<code>DrawableRequestBuilder</code>中实现的，具体实现的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * &#123;@inheritDoc&#125;</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> *     Note - If no transformation is set for this load, a default transformation will be applied based on the</span><br><span class="line"> *     value returned from &#123;@link android.widget.ImageView#getScaleType()&#125;. To avoid this default transformation,</span><br><span class="line"> *     use &#123;@link #dontTransform()&#125;.</span><br><span class="line"> * &lt;&#x2F;p&gt;</span><br><span class="line"> *</span><br><span class="line"> * @param view &#123;@inheritDoc&#125;</span><br><span class="line"> * @return &#123;@inheritDoc&#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Override</span><br><span class="line">public Target&lt;GlideDrawable&gt; into(ImageView view) &#123;</span><br><span class="line">    return super.into(view);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出了，在<code>DrawableRequestBuilder</code>中，其实并没有对<code>into</code>方法进行实现，只是简单的将其实现抛给了父类<code>into</code>方法。前面就分析过，<code>GenericRequestBuilder</code>就是<code>DrawableRequestBuilder</code>的父类，下面就<code>into</code>方法的实现进行解析。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public Target&lt;TranscodeType&gt; into(ImageView view) &#123;</span><br><span class="line">        Util.assertMainThread();&#x2F;&#x2F;判断是否在主线程</span><br><span class="line">        if (view &#x3D;&#x3D; null) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;You must pass in a non null View&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (!isTransformationSet &amp;&amp; view.getScaleType() !&#x3D; null) &#123;</span><br><span class="line">            switch (view.getScaleType()) &#123;</span><br><span class="line">                case CENTER_CROP:</span><br><span class="line">                    applyCenterCrop();</span><br><span class="line">                    break;</span><br><span class="line">                case FIT_CENTER:</span><br><span class="line">                case FIT_START:</span><br><span class="line">                case FIT_END:</span><br><span class="line">                    applyFitCenter();</span><br><span class="line">                    break;</span><br><span class="line">                &#x2F;&#x2F;$CASES-OMITTED$</span><br><span class="line">                default:</span><br><span class="line">                    &#x2F;&#x2F; Do nothing.</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return into(glide.buildImageViewTarget(view, transcodeClass));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>参考资料：</p>
<ul>
<li><a href="http://www.10tiao.com/html/169/201704/2650822526/1.html" target="_blank" rel="noopener">http://www.10tiao.com/html/169/201704/2650822526/1.html</a></li>
<li><a href="http://blog.csdn.net/yulyu/article/details/60331803" target="_blank" rel="noopener">http://blog.csdn.net/yulyu/article/details/60331803</a></li>
<li><a href="http://www.lightskystreet.com/2015/10/12/glide_source_analysis/" target="_blank" rel="noopener">http://www.lightskystreet.com/2015/10/12/glide_source_analysis/</a></li>
<li><a href="http://blog.csdn.net/guolin_blog/article/details/53939176" target="_blank" rel="noopener">http://blog.csdn.net/guolin_blog/article/details/53939176</a></li>
<li><a href="http://blog.csdn.net/guolin_blog/article/details/54895665" target="_blank" rel="noopener">http://blog.csdn.net/guolin_blog/article/details/54895665</a></li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/source-glide/" rel="tag"># source,glide</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2017/08/19/hello-world/" rel="prev" title="Hello World">
      <i class="fa fa-chevron-left"></i> Hello World
    </a></div>
      <div class="post-nav-item">
    <a href="/2017/08/28/android%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/" rel="next" title="android面试准备">
      android面试准备 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#源码导入"><span class="nav-number">1.</span> <span class="nav-text">源码导入</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#简单使用示例"><span class="nav-number">2.</span> <span class="nav-text">简单使用示例</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#源码分析"><span class="nav-number">3.</span> <span class="nav-text">源码分析</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#总体设计图"><span class="nav-number">3.1.</span> <span class="nav-text">总体设计图</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Glide-with"><span class="nav-number">3.2.</span> <span class="nav-text">Glide.with()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#load方法"><span class="nav-number">3.3.</span> <span class="nav-text">load方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#into"><span class="nav-number">3.4.</span> <span class="nav-text">into()</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">reoger</p>
  <div class="site-description" itemprop="description">reoger</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">56</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">33</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/reoger" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;reoger" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:reoger112@gmail.com" title="E-Mail → mailto:reoger112@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2018 – 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">reoger</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
