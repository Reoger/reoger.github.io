<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"reoger.tk","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="ImageLoader是最早开源的 Android 图片缓存库, 强大的缓存机制, 早期使用这个图片加载框架的android应用非常多， 至今仍然有不少Android 开发者在使用。  ImagerLoader特征 支持本地、网络图片，且支持图片下载的进度监听 支持个性化配置ImagerLoader，如线程池，内存缓存策略，图片显示选项等 三层缓存加快图片的加载速度 支持图片压缩  开始使用鉴于">
<meta property="og:type" content="article">
<meta property="og:title" content="imageLoader解析">
<meta property="og:url" content="http://reoger.tk/2017/09/02/imageLoader%E8%A7%A3%E6%9E%90/index.html">
<meta property="og:site_name" content="reoger的记录">
<meta property="og:description" content="ImageLoader是最早开源的 Android 图片缓存库, 强大的缓存机制, 早期使用这个图片加载框架的android应用非常多， 至今仍然有不少Android 开发者在使用。  ImagerLoader特征 支持本地、网络图片，且支持图片下载的进度监听 支持个性化配置ImagerLoader，如线程池，内存缓存策略，图片显示选项等 三层缓存加快图片的加载速度 支持图片压缩  开始使用鉴于">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/2178834-16069ef078012739.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/2178834-96999153d13488db.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://ovec6nnof.bkt.clouddn.com/imagerLoader%E4%B8%AD%E7%9A%84dispalyer%E9%80%BB%E8%BE%91.svg">
<meta property="article:published_time" content="2017-09-02T11:00:47.000Z">
<meta property="article:modified_time" content="2017-09-11T07:32:08.000Z">
<meta property="article:author" content="reoger">
<meta property="article:tag" content="图片加载">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://upload-images.jianshu.io/upload_images/2178834-16069ef078012739.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">

<link rel="canonical" href="http://reoger.tk/2017/09/02/imageLoader%E8%A7%A3%E6%9E%90/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>imageLoader解析 | reoger的记录</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">reoger的记录</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">--以后的你会感激现在那么努力的自己</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://reoger.tk/2017/09/02/imageLoader%E8%A7%A3%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="reoger">
      <meta itemprop="description" content="reoger">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="reoger的记录">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          imageLoader解析
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-09-02 19:00:47" itemprop="dateCreated datePublished" datetime="2017-09-02T19:00:47+08:00">2017-09-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2017-09-11 15:32:08" itemprop="dateModified" datetime="2017-09-11T15:32:08+08:00">2017-09-11</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/" itemprop="url" rel="index"><span itemprop="name">源码解读</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <blockquote>
<p><code>ImageLoader</code>是最早开源的 <code>Android</code> 图片缓存库, 强大的缓存机制, 早期使用这个图片加载框架的android应用非常多， 至今仍然有不少<code>Android</code> 开发者在使用。</p>
</blockquote>
<h1 id="ImagerLoader特征"><a href="#ImagerLoader特征" class="headerlink" title="ImagerLoader特征"></a>ImagerLoader特征</h1><ol>
<li>支持本地、网络图片，且支持图片下载的进度监听</li>
<li>支持个性化配置ImagerLoader，如线程池，内存缓存策略，图片显示选项等</li>
<li>三层缓存加快图片的加载速度</li>
<li>支持图片压缩</li>
</ol>
<h1 id="开始使用"><a href="#开始使用" class="headerlink" title="开始使用"></a>开始使用</h1><p>鉴于这篇是对ImageLoader源码来进行解析，我们首先回顾一下<code>ImageLoader</code>的使用。<br>可以通过<a href="https://github.com/nostra13/Android-Universal-Image-Loader/raw/master/downloads/universal-image-loader-1.9.5.jar" target="_blank" rel="noopener">这里</a>下载<code>universal-imager-loader</code>的jar包，并将其导入到自己的项目中。<br>然后可以在<code>Application</code>或者<code>Activity</code>中初始化<code>ImageLoade</code>，参考如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class YourApplication extends Application &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onCreate() &#123;</span><br><span class="line">        super.onCreate();</span><br><span class="line">        &#x2F;&#x2F;创建默认的ImageLoader配置参数  </span><br><span class="line">        ImageLoaderConfiguration configuration &#x3D; ImageLoaderConfiguration  </span><br><span class="line">                .createDefault(this);  </span><br><span class="line">          </span><br><span class="line">        &#x2F;&#x2F;Initialize ImageLoader with configuration.  </span><br><span class="line">        ImageLoader.getInstance().init(configuration);  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，如果涉及到网络操作和磁盘缓存的话，有或者是在<code>Application</code>中进行初始化的话，记得要在<code>Manifest</code>中进行申明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;manifest&gt;  </span><br><span class="line">    &lt;uses-permission android:name&#x3D;&quot;android.permission.INTERNET&quot; &#x2F;&gt;  </span><br><span class="line">    &lt;!-- Include next permission if you want to allow UIL to cache images on SD card --&gt;  </span><br><span class="line">    &lt;uses-permission android:name&#x3D;&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; &#x2F;&gt;  </span><br><span class="line">    ...  </span><br><span class="line">    &lt;application android:name&#x3D;&quot;YourApplication&quot;&gt;  </span><br><span class="line">        ...  </span><br><span class="line">    &lt;&#x2F;application&gt;  </span><br><span class="line">&lt;&#x2F;manifest&gt;</span><br></pre></td></tr></table></figure>
<p>接下来我们就可以愉快的来加载图片了，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ImageLoader.getInstance().displayImage(imageUri, imageView);</span><br></pre></td></tr></table></figure>
<p>当然，如果你想添加监听，可以这么写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ImageLoader.getInstance().loadImage(imageUrl, new SimpleImageLoadingListener()&#123;  </span><br><span class="line">  </span><br><span class="line">            @Override  </span><br><span class="line">            public void onLoadingComplete(String imageUri, View view,  </span><br><span class="line">                    Bitmap loadedImage) &#123;  </span><br><span class="line">                super.onLoadingComplete(imageUri, view, loadedImage);  </span><br><span class="line">                mImageView.setImageBitmap(loadedImage);  </span><br><span class="line">            &#125;  </span><br><span class="line">              </span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>
<p>至于更多的用法这里就不介绍了，如果有需要，可以参看这篇<a href="http://blog.csdn.net/abc6368765/article/details/52510761" target="_blank" rel="noopener">博客</a>，了解更多关于ImageLoader的用法。下面就开始了源码的解析之路。</p>
<h1 id="ImageLoaderConfiguration配置实现"><a href="#ImageLoaderConfiguration配置实现" class="headerlink" title="ImageLoaderConfiguration配置实现"></a>ImageLoaderConfiguration配置实现</h1><p>我们首先还是从<code>imageLoader</code>的配置开始开始源码的探究之旅把。在上面的使用实例中，我们使用<code>createDefault()</code>方法来初始化配置，那么<code>imageLoader</code>的默认配置究竟是些什么呢？下面直接上代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">public static ImageLoaderConfiguration createDefault(Context context) &#123;</span><br><span class="line">    return new Builder(context).build();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public ImageLoaderConfiguration build() &#123;</span><br><span class="line">    initEmptyFieldsWithDefaultValues();</span><br><span class="line">    return new ImageLoaderConfiguration(this);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void initEmptyFieldsWithDefaultValues() &#123;</span><br><span class="line">    if (taskExecutor &#x3D;&#x3D; null) &#123;</span><br><span class="line">        taskExecutor &#x3D; DefaultConfigurationFactory</span><br><span class="line">                .createExecutor(threadPoolSize, threadPriority, tasksProcessingType);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        customExecutor &#x3D; true;</span><br><span class="line">    &#125;</span><br><span class="line">    if (taskExecutorForCachedImages &#x3D;&#x3D; null) &#123;</span><br><span class="line">        taskExecutorForCachedImages &#x3D; DefaultConfigurationFactory</span><br><span class="line">                .createExecutor(threadPoolSize, threadPriority, tasksProcessingType);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        customExecutorForCachedImages &#x3D; true;</span><br><span class="line">    &#125;</span><br><span class="line">    if (diskCache &#x3D;&#x3D; null) &#123;</span><br><span class="line">        if (diskCacheFileNameGenerator &#x3D;&#x3D; null) &#123;</span><br><span class="line">            diskCacheFileNameGenerator &#x3D; DefaultConfigurationFactory.createFileNameGenerator();</span><br><span class="line">        &#125;</span><br><span class="line">        diskCache &#x3D; DefaultConfigurationFactory</span><br><span class="line">                .createDiskCache(context, diskCacheFileNameGenerator, diskCacheSize, diskCacheFileCount);</span><br><span class="line">    &#125;</span><br><span class="line">    if (memoryCache &#x3D;&#x3D; null) &#123;</span><br><span class="line">        memoryCache &#x3D; DefaultConfigurationFactory.createMemoryCache(context, memoryCacheSize);</span><br><span class="line">    &#125;</span><br><span class="line">    if (denyCacheImageMultipleSizesInMemory) &#123;</span><br><span class="line">        memoryCache &#x3D; new FuzzyKeyMemoryCache(memoryCache, MemoryCacheUtils.createFuzzyKeyComparator());</span><br><span class="line">    &#125;</span><br><span class="line">    if (downloader &#x3D;&#x3D; null) &#123;</span><br><span class="line">        downloader &#x3D; DefaultConfigurationFactory.createImageDownloader(context);</span><br><span class="line">    &#125;</span><br><span class="line">    if (decoder &#x3D;&#x3D; null) &#123;</span><br><span class="line">        decoder &#x3D; DefaultConfigurationFactory.createImageDecoder(writeLogs);</span><br><span class="line">    &#125;</span><br><span class="line">    if (defaultDisplayImageOptions &#x3D;&#x3D; null) &#123;</span><br><span class="line">        defaultDisplayImageOptions &#x3D; DisplayImageOptions.createSimple();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line">private ImageLoaderConfiguration(final Builder builder) &#123;</span><br><span class="line">    resources &#x3D; builder.context.getResources();&#x2F;&#x2F;程序本地资源访问器</span><br><span class="line">    maxImageWidthForMemoryCache &#x3D; builder.maxImageWidthForMemoryCache;&#x2F;&#x2F;内存缓存的图片最大宽度 </span><br><span class="line">    maxImageHeightForMemoryCache &#x3D; builder.maxImageHeightForMemoryCache;&#x2F;&#x2F;内存缓存的图片最大高度 </span><br><span class="line">    maxImageWidthForDiskCache &#x3D; builder.maxImageWidthForDiskCache;&#x2F;&#x2F;磁盘缓存的图片最大宽度 </span><br><span class="line">    maxImageHeightForDiskCache &#x3D; builder.maxImageHeightForDiskCache;&#x2F;&#x2F;磁盘缓存的图片最大高度 </span><br><span class="line">    processorForDiskCache &#x3D; builder.processorForDiskCache;&#x2F;&#x2F;图片处理器，用于处理从磁盘缓存中读取到的图片 </span><br><span class="line">    taskExecutor &#x3D; builder.taskExecutor;&#x2F;&#x2F;ImageLoaderEngine中用于执行从源获取图片任务的 Executor。</span><br><span class="line">    taskExecutorForCachedImages &#x3D; builder.taskExecutorForCachedImages;&#x2F;&#x2F;ImageLoaderEngine中用于执行从缓存获取图片任务的 Executor。</span><br><span class="line">    threadPoolSize &#x3D; builder.threadPoolSize;&#x2F;&#x2F;上面两个默认线程池的核心池大小，即最大并发数。</span><br><span class="line">    threadPriority &#x3D; builder.threadPriority;&#x2F;&#x2F;上面两个默认线程池的线程优先级。</span><br><span class="line">    tasksProcessingType &#x3D; builder.tasksProcessingType;&#x2F;&#x2F;上面两个默认线程池的线程队列类型。目前只有 FIFO, LIFO 两种可供选择。</span><br><span class="line">    diskCache &#x3D; builder.diskCache;&#x2F;&#x2F;图片磁盘缓存，一般放在 SD 卡。</span><br><span class="line">    memoryCache &#x3D; builder.memoryCache;&#x2F;&#x2F;图片内存缓存。</span><br><span class="line">    defaultDisplayImageOptions &#x3D; builder.defaultDisplayImageOptions;&#x2F;&#x2F;图片显示的配置项。比如加载前、加载中、加载失败应该显示的占位图片，图片是否需要在磁盘缓存，是否需要在内存缓存等。</span><br><span class="line">    downloader &#x3D; builder.downloader;&#x2F;&#x2F;图片下载器。</span><br><span class="line">    decoder &#x3D; builder.decoder;&#x2F;&#x2F;图片解码器，内部可使用我们常用的BitmapFactory.decode(…)将图片资源解码成Bitmap对象。</span><br><span class="line"></span><br><span class="line">    customExecutor &#x3D; builder.customExecutor;&#x2F;&#x2F;用户是否自定义了上面的 taskExecutor。</span><br><span class="line">    customExecutorForCachedImages &#x3D; builder.customExecutorForCachedImages;&#x2F;&#x2F;用户是否自定义了上面的 taskExecutorForCachedImages。</span><br><span class="line"></span><br><span class="line">    networkDeniedDownloader &#x3D; new NetworkDeniedImageDownloader(downloader);&#x2F;&#x2F;不允许访问网络的图片下载器。</span><br><span class="line">    slowNetworkDownloader &#x3D; new SlowNetworkImageDownloader(downloader);&#x2F;&#x2F;慢网络情况下的图片下载器。</span><br><span class="line"></span><br><span class="line">    L.writeDebugLogs(builder.writeLogs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码有点多，但是很简单也很清晰，就是一些列初始化的代码。通过一些系列的调用，在<code>initEmptyFieldsWithDefaultValues</code>方法中对一些没有配置的进行的项进行配置，并通过<code>ImageLoaderConfiguration</code>给出默认的参数配置。对于其中的一些配置，在上面的注释中已经表明，<code>ImageLoaderConfiguration</code>中默认的配置，可以参考第48-73行。<br>至于<code>initEmptyFieldsWithDefaultValues</code>中的配置，在这里进行简单的介绍：</p>
<ul>
<li><strong>taskExecutor</strong> 从源获取图片任务的线程池</li>
<li><strong>taskExecutorForCachedImages</strong> 用于执行从缓存获取图片任务的线程池<br>前面两个线程池的参数如下：<table>
<thead>
<tr>
<th>核心线程数</th>
<th align="right">最大线程数</th>
<th align="center">空闲线程等待时间</th>
<th>容器</th>
</tr>
</thead>
<tbody><tr>
<td>3</td>
<td align="right">3</td>
<td align="center">0s</td>
<td>2</td>
</tr>
<tr>
<td>前面两个线程池如果用户自定义的相应的线程池来实现的话，就会将<code>customExecutor</code>置为<code>true</code>，或将<code>customExecutorForCachedImages</code>置为<code>true</code>。其实<code>customExecutor</code>存在的意义就在于判断用户有没有自定义从源获取图片任务的线程池，<code>customExecutorForCachedImages</code>存在的意义判断在于用户判断用户有没有重写从缓存获取图片的线程池。</td>
<td align="right"></td>
<td align="center"></td>
<td></td>
</tr>
</tbody></table>
</li>
<li><strong>diskCacheFileNameGenerator</strong> 默认实现为<code>HashCodeFileNameGenerator</code>，即用<code>mageUri.hashCode()</code>值当前图片名字。</li>
<li><strong>diskCache</strong>用于表示图片磁盘的缓存，默认实现为<code>createDiskCache</code>，默认的算法为<code>LruDiskCache</code>算法，缓存的目录为SD卡下的<code>/data/data/&quot; + context.getPackageName() + &quot;/cache/uil-images</code>目录下。</li>
<li><strong>memoryCache</strong>用于表示图片内存的缓存，默认实现为<code>createMemoryCache</code>,默认使用的算法为<code>LruMemoryCache</code>。</li>
<li><strong>denyCacheImageMultipleSizesInMemory</strong> 为<code>true</code>时，表示内存缓存不允许缓存一张图片的多个尺寸。这个时候用通过<code>FuzzyKeyMemoryCache</code>来构建<code>memoryCache</code></li>
<li><strong>downloader</strong>表示图片下载器，默认实现为<code>createImageDownloader</code>，最终通过<code>BaseImageDownloader</code>构建下载器，其下载器中重要的两个参数分别为：连接超时时间<code>connectTimeout</code>默认值为5分钟，读取超时时间<code>readTimeout</code>默认值为20分钟。</li>
<li><strong>decoder</strong> 表示图片解码器，默认实现为<code>createImageDecoder</code>，最终通过<code>BaseImageDecoder</code>实现。</li>
<li><strong>defaultDisplayImageOptions</strong> 表示默认参数，最终回调到<code>DisplayImageOptions</code>方法中，里面设计相关的参数初始化。这里就不展开了。</li>
</ul>
<h1 id="加载配置"><a href="#加载配置" class="headerlink" title="加载配置"></a>加载配置</h1><p>我们首先看<code>Application</code>中<code>imgaerLoader</code>设置配置的方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ImageLoader.getInstance().init(configuration);</span><br></pre></td></tr></table></figure>
<p>接下来我们继续分析上面的代码是如何将配置应用到ImageLoader中的。首先是<code>ImageLoader.getInstance()</code>实例化一个<code>ImageLoader</code>，通过代码来看实例化的过程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static ImageLoader getInstance() &#123;</span><br><span class="line">    if (instance &#x3D;&#x3D; null) &#123;</span><br><span class="line">        synchronized (ImageLoader.class) &#123;</span><br><span class="line">            if (instance &#x3D;&#x3D; null) &#123;</span><br><span class="line">                instance &#x3D; new ImageLoader();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出来，<code>getInstance</code>就是获取一个<code>ImageLoader</code>实例，运用了一个双重锁的单利模式，很简单，就不做解释了。<br>重点看<code>init</code>方法。具体在<code>ImageLoader</code>类中的实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public synchronized void init(ImageLoaderConfiguration configuration) &#123;</span><br><span class="line">        if (configuration &#x3D;&#x3D; null) &#123;</span><br><span class="line">            throw new IllegalArgumentException(ERROR_INIT_CONFIG_WITH_NULL);</span><br><span class="line">        &#125;</span><br><span class="line">        if (this.configuration &#x3D;&#x3D; null) &#123;</span><br><span class="line">            L.d(LOG_INIT_CONFIG);</span><br><span class="line">            engine &#x3D; new ImageLoaderEngine(configuration);</span><br><span class="line">            this.configuration &#x3D; configuration;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            L.w(WARNING_RE_INIT_CONFIG);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看出来，<code>init</code>的实现也是非常简单的。首先判断传入的<code>configuration</code>参数是否为空，为空就直接抛出一个异常，不为空就判断当前类属性<code>configuration</code>是否为空，类中<code>configuration</code>属性为空时调用<code>ImageLoaderEngine</code>构建<code>engine</code>对象，否则就打印警告日志。所以整个方法中最重要的一个语句就是<code>new ImageLoaderEngine(configuration);</code>。这里首先介绍一个<code>ImageLoaderEngine</code>类的作用。简单描述就是<code>ImageLoaderEngine</code>是任务分发器，负责分发<code>LoadAndDisplayImageTask</code>和<code>ProcessAndDisplayImageTask</code>给具体的线程池去执行。具体实现后面会讲到。</p>
<h1 id="加载图片"><a href="#加载图片" class="headerlink" title="加载图片"></a>加载图片</h1><p>通过上面两个步骤，imgaeLoder的参数配置已经设置完毕，接下来我们就可以用imageLoader加载图片了。下面是三种加载图片的方式：<br><strong>加载方式一，异步加载并显示图片到对应的imagerAware上</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ImageLoader.getInstance().displayImage(imageUrl,imageView);</span><br></pre></td></tr></table></figure>
<p><strong>加载方式二，异步加载图片并执行回调接口</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">ImageLoader.getInstance().loadImage(imageUrl,new  ImageLoadingListener() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onLoadingStarted(String imageUri, View view) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onLoadingFailed(String imageUri, View view, FailReason failReason) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onLoadingComplete(String imageUri, View view, Bitmap loadedImage) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onLoadingCancelled(String imageUri, View view) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><strong>加载方式三，同步加载图片</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ImageLoader.getInstance().loadImageSync(imageUrl);</span><br></pre></td></tr></table></figure>
<p>针对上面三种方法，我们先分析第一种加载图片的方法，其余的两种加载图片的分析也差不多，后面就不具体分析了，只是简单的体现其不同点。<br>我们来看<code>displayImage</code>方法在<code>ImageLoader</code>类中的实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public void displayImage(String uri, ImageView imageView) &#123;</span><br><span class="line">    displayImage(uri, new ImageViewAware(imageView), null, null, null);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void displayImage(String uri, ImageView imageView, ImageSize targetImageSize) &#123;</span><br><span class="line">    displayImage(uri, new ImageViewAware(imageView), null, targetImageSize, null, null);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">public void displayImage(String uri, ImageView imageView, DisplayImageOptions options) &#123;</span><br><span class="line">    displayImage(uri, new ImageViewAware(imageView), options, null, null);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void displayImage(String uri, ImageView imageView, ImageLoadingListener listener) &#123;</span><br><span class="line">    displayImage(uri, new ImageViewAware(imageView), null, listener, null);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void displayImage(String uri, ImageView imageView, DisplayImageOptions options,</span><br><span class="line">        ImageLoadingListener listener) &#123;</span><br><span class="line">    displayImage(uri, imageView, options, listener, null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看到上面的<code>displayImage</code>有很多中重载的方法，最终他们都会调用到下面的这个<code>displayImage</code>方法中来。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">public void displayImage(String uri, ImageAware imageAware, DisplayImageOptions options,</span><br><span class="line">        ImageSize targetSize, ImageLoadingListener listener, ImageLoadingProgressListener progressListener) &#123;</span><br><span class="line">    &#x2F;&#x2F;省略了部分判空代码</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    if (targetSize &#x3D;&#x3D; null) &#123;</span><br><span class="line">        targetSize &#x3D; ImageSizeUtils.defineTargetSizeForView(imageAware, configuration.getMaxImageSize());</span><br><span class="line">    &#125;</span><br><span class="line">    String memoryCacheKey &#x3D; MemoryCacheUtils.generateKey(uri, targetSize);</span><br><span class="line">    engine.prepareDisplayTaskFor(imageAware, memoryCacheKey);</span><br><span class="line"></span><br><span class="line">    listener.onLoadingStarted(uri, imageAware.getWrappedView());</span><br><span class="line"></span><br><span class="line">    Bitmap bmp &#x3D; configuration.memoryCache.get(memoryCacheKey);</span><br><span class="line">    if (bmp !&#x3D; null &amp;&amp; !bmp.isRecycled()) &#123;</span><br><span class="line">        L.d(LOG_LOAD_IMAGE_FROM_MEMORY_CACHE, memoryCacheKey);</span><br><span class="line"></span><br><span class="line">        if (options.shouldPostProcess()) &#123;</span><br><span class="line">            ImageLoadingInfo imageLoadingInfo &#x3D; new ImageLoadingInfo(uri, imageAware, targetSize, memoryCacheKey,</span><br><span class="line">                    options, listener, progressListener, engine.getLockForUri(uri));</span><br><span class="line">            ProcessAndDisplayImageTask displayTask &#x3D; new ProcessAndDisplayImageTask(engine, bmp, imageLoadingInfo,</span><br><span class="line">                    defineHandler(options));</span><br><span class="line">            if (options.isSyncLoading()) &#123;</span><br><span class="line">                displayTask.run();</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                engine.submit(displayTask);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            options.getDisplayer().display(bmp, imageAware, LoadedFrom.MEMORY_CACHE);</span><br><span class="line">            listener.onLoadingComplete(uri, imageAware.getWrappedView(), bmp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (options.shouldShowImageOnLoading()) &#123;</span><br><span class="line">            imageAware.setImageDrawable(options.getImageOnLoading(configuration.resources));</span><br><span class="line">        &#125; else if (options.isResetViewBeforeLoading()) &#123;</span><br><span class="line">            imageAware.setImageDrawable(null);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ImageLoadingInfo imageLoadingInfo &#x3D; new ImageLoadingInfo(uri, imageAware, targetSize, memoryCacheKey,</span><br><span class="line">                options, listener, progressListener, engine.getLockForUri(uri));</span><br><span class="line">        LoadAndDisplayImageTask displayTask &#x3D; new LoadAndDisplayImageTask(engine, imageLoadingInfo,</span><br><span class="line">                defineHandler(options));</span><br><span class="line">        if (options.isSyncLoading()) &#123;</span><br><span class="line">            displayTask.run();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            engine.submit(displayTask);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从第6行开始看，当没有传入<code>targetSize</code>目标尺寸时，会通过第6行的代码产生一个合适的尺寸。具体逻辑为，当image没有尺寸时就采用测量出来的最大尺寸，当image有尺寸时就用image本身的尺寸。获取最大尺寸的逻辑为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ImageSize getMaxImageSize() &#123;</span><br><span class="line">        &#x2F;&#x2F;获取屏幕像素</span><br><span class="line">        DisplayMetrics displayMetrics &#x3D; resources.getDisplayMetrics();</span><br><span class="line"></span><br><span class="line">        int width &#x3D; maxImageWidthForMemoryCache;&#x2F;&#x2F;最大的图片内存缓存宽度</span><br><span class="line">        if (width &lt;&#x3D; 0) &#123;</span><br><span class="line">            width &#x3D; displayMetrics.widthPixels;&#x2F;&#x2F;屏幕宽度</span><br><span class="line">        &#125;</span><br><span class="line">        int height &#x3D; maxImageHeightForMemoryCache;&#x2F;&#x2F;最大的图片内存缓存高度</span><br><span class="line">        if (height &lt;&#x3D; 0) &#123;</span><br><span class="line">            height &#x3D; displayMetrics.heightPixels;&#x2F;&#x2F;屏幕高度</span><br><span class="line">        &#125;</span><br><span class="line">        return new ImageSize(width, height);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>即最大的尺寸为：如设置了<code>maxImageWidthForMemoryCache</code>值且该值大于0，则最大尺寸为其设置的值，否则屏幕宽度。在高度上也一样，就不赘述了。综上，我们可以知道要显示图片的大小的逻辑，<strong>我们设置了图片显示的尺寸，则图片尺寸为我们设置的尺寸。否则图片的本身有尺寸的时候，显示的就是自己本身的尺寸，否则就显示最大的图片尺寸。当最大图片内存缓存尺寸大于0时，最大图片尺寸即为最大图片内存尺寸，否则为屏幕尺寸。</strong><br>分析了那么久，其实还只是分析了<code>displayImage</code>方法的一个方法，下面我们继续看<code>displayImage</code>中的实现。在计算好目标图片的尺寸之后，利用<code>generateKey</code>方法生成一个<code>memoryCacheKey</code>，这里的<code>memoryCacheKey</code>的组成形式为<code>URI + size</code>，用于表示要加载到内存中的图片。通过第10行代码，将要加载的图片加入到<code>cacheKeysForImageAwares</code>队列中,他是一个<code>Collections.synchronizedMap(new HashMap&lt;Integer, String&gt;())</code>类型的队列，他用来记录正在加载的任务，加载图片的时候会将<code>ImageView</code>的<code>id</code>和图片的<code>url</code>加上尺寸加入到<code>HashMap</code>中，加载完成之后会将其移除。然后通过第12行的代码回调<code>onLoadingStarted</code>方法，这个方法就是我们在使用时的<code>onLoadingStarted</code>方法回调,具体参考上面的<strong>加载方式二，异步加载图片并执行回调接口</strong>的使用实例。<br>对于最终调用的<code>displayImage</code>方法代码很重要，所以我们继续往下分析其中的代码。以下的代码已经省略前面已经分析的代码，完整代码参考前面的代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Bitmap bmp &#x3D; configuration.memoryCache.get(memoryCacheKey);</span><br><span class="line">if (bmp !&#x3D; null &amp;&amp; !bmp.isRecycled()) &#123;&#x2F;&#x2F;本地能获取到图片</span><br><span class="line">    L.d(LOG_LOAD_IMAGE_FROM_MEMORY_CACHE, memoryCacheKey);</span><br><span class="line"></span><br><span class="line">    if (options.shouldPostProcess()) &#123;</span><br><span class="line">        ---</span><br><span class="line">        &#x2F;&#x2F;缺失的代码片段1</span><br><span class="line">        ---</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        options.getDisplayer().display(bmp, imageAware, LoadedFrom.MEMORY_CACHE);</span><br><span class="line">        listener.onLoadingComplete(uri, imageAware.getWrappedView(), bmp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    ---</span><br><span class="line">    这里实现从网络上获取图片的逻辑</span><br><span class="line">     &#x2F;&#x2F;缺失的代码片段2</span><br><span class="line">    ---</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先从内存中拿出将要加载的图片（bitmap格式），然后在图片不为空且没被回收的基础上开始加载图片的逻辑。第5行中有一个判断，我们如果在<code>DisplayImageOptions</code>中设置了<code>postProcessor</code>就进入true逻辑，不过默认<code>postProcessor</code>是为null的，<code>BitmapProcessor</code>接口主要是对<code>Bitmap</code>进行处理，这个框架并没有给出相对应的实现，如果我们有自己的需求的时候可以自己实现<code>BitmapProcessor</code>接口（比如将图片设置成圆形的）。我们先分析默认情况，即<code>shouldPostProcess</code>为<code>false</code>的情况下执行的第16-17行代码。第16行代码就将<code>Bitmap</code>设置到<code>ImageView</code>上面,这里我们可以在<code>DisplayImageOptions</code>中配置显示需求<code>displayer</code>，默认使用的是<code>SimpleBitmapDisplayer</code>，直接将<code>Bitmap</code>设置到<code>ImageView</code>上面。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public final class SimpleBitmapDisplayer implements BitmapDisplayer &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void display(Bitmap bitmap, ImageAware imageAware, LoadedFrom loadedFrom) &#123;</span><br><span class="line">        imageAware.setImageBitmap(bitmap);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，ImageLoader也为我们提供了其他显示的方式，如<code>CircleBitmapDisplayer</code>（）,<code>FadeInBitmapDisplayer</code>,<code>RoundeBitmapDisplayer</code>三种显示方式。第17行代码很好理解，就是回调到<code>onLoadingComplete</code>方法，提供给用户的回调。<br>接下来我们来看当用于设置了<code>postProcessor</code>下情况的逻辑，即上面缺失的代码片段1：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ImageLoadingInfo imageLoadingInfo &#x3D; new ImageLoadingInfo(uri, imageAware, targetSize, memoryCacheKey,</span><br><span class="line">                    options, listener, progressListener, engine.getLockForUri(uri));</span><br><span class="line">            ProcessAndDisplayImageTask displayTask &#x3D; new ProcessAndDisplayImageTask(engine, bmp, imageLoadingInfo,</span><br><span class="line">                    defineHandler(options));</span><br><span class="line">            if (options.isSyncLoading()) &#123;</span><br><span class="line">                displayTask.run();</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                engine.submit(displayTask);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>这里代码执行的情况就是用于需要回调图片记载的进度时执行，即用户指定了<code>postProcessor</code>对象，而<code>postProcessor</code>主要用于表示缓存在内存之后的处理程序。<br>其中的<code>ImageLoadingInfo</code>主要用来加载和显示图片任务需要的信息，<code>ProcessAndDisplayImageTask</code>主要用于处理并显示图片的任务，他实现了<code>Runnable</code>接口。然后通过<code>isSyncLoading</code>判断是同步还是异步，当<code>isSyncLoading</code>为ture时表示当前是同步执行。这里还有一个点需要特别说明以下：我们看第1行代码中的<code>engine.getLockForUri(uri)</code>，这个方法主要是用来给图片的URl加锁的，那么给URL要传入这个一个参数给<code>ImageLoadingInfo</code>呢？其实主要是实现对图片的复用，考虑这样一种场景，在一个LitView中，某个Item正在获取图片的过程中，我们将这个item滚出界面后又将其滚进来，滚进来如果没有加锁，该item又会去加载一次图片，为了避免多次对同一个URL重复请求，有必要对正在加载的URL加锁，当图片加载完成之后，就将锁释放掉。<br>我们在来分析同步执行的情况，直接执行<code>run()</code>,通过<code>displayTask</code>任务来执行，我们来了解<code>ProcessAndDisplayImageTask</code>中<code>run()</code>方法里面的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        L.d(LOG_POSTPROCESS_IMAGE, imageLoadingInfo.memoryCacheKey);</span><br><span class="line"></span><br><span class="line">        BitmapProcessor processor &#x3D; imageLoadingInfo.options.getPostProcessor();</span><br><span class="line">        &#x2F;&#x2F;图片处理器，用于处理从磁盘缓存中读取到的图片。</span><br><span class="line">        Bitmap processedBitmap &#x3D; processor.process(bitmap);</span><br><span class="line">        &#x2F;&#x2F;处理图片</span><br><span class="line">        DisplayBitmapTask displayBitmapTask &#x3D; new DisplayBitmapTask(processedBitmap, imageLoadingInfo, engine,</span><br><span class="line">                LoadedFrom.MEMORY_CACHE);</span><br><span class="line">                &#x2F;&#x2F;构建图片实现的任务</span><br><span class="line">        LoadAndDisplayImageTask.runTask(displayBitmapTask, imageLoadingInfo.options.isSyncLoading(), handler, engine);</span><br><span class="line">                &#x2F;&#x2F;执行图片显示任务</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，在从本地读取到图片的显示逻辑还是很简单的，<code>run</code>方法核心只有四行代码，首先对图片进行相对应的处理，然后构建图片显示的任务，最后执行图片显示的任务就OK了。我们来看<code>DisplayBitmapTask</code>中具体做了什么：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">final class DisplayBitmapTask implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    private final Bitmap bitmap;</span><br><span class="line">    private final String imageUri;</span><br><span class="line">    private final ImageAware imageAware;</span><br><span class="line">    private final String memoryCacheKey;</span><br><span class="line">    private final BitmapDisplayer displayer;</span><br><span class="line">    private final ImageLoadingListener listener;</span><br><span class="line">    private final ImageLoaderEngine engine;</span><br><span class="line">    private final LoadedFrom loadedFrom;</span><br><span class="line"></span><br><span class="line">    public DisplayBitmapTask(Bitmap bitmap, ImageLoadingInfo imageLoadingInfo, ImageLoaderEngine engine,</span><br><span class="line">            LoadedFrom loadedFrom) &#123;</span><br><span class="line">        this.bitmap &#x3D; bitmap;</span><br><span class="line">        imageUri &#x3D; imageLoadingInfo.uri;</span><br><span class="line">        imageAware &#x3D; imageLoadingInfo.imageAware;</span><br><span class="line">        memoryCacheKey &#x3D; imageLoadingInfo.memoryCacheKey;</span><br><span class="line">        displayer &#x3D; imageLoadingInfo.options.getDisplayer();</span><br><span class="line">        listener &#x3D; imageLoadingInfo.listener;</span><br><span class="line">        this.engine &#x3D; engine;</span><br><span class="line">        this.loadedFrom &#x3D; loadedFrom;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        if (imageAware.isCollected()) &#123;&#x2F;&#x2F;如果要显示的图片已经被GC回收</span><br><span class="line">            &#x2F;&#x2F;回调onLoadingCancelled接口</span><br><span class="line">            listener.onLoadingCancelled(imageUri, imageAware.getWrappedView());</span><br><span class="line">        &#125; else if (isViewWasReused()) &#123;&#x2F;&#x2F;如果</span><br><span class="line">             &#x2F;&#x2F;回调onLoadingCancelled接口</span><br><span class="line">            listener.onLoadingCancelled(imageUri, imageAware.getWrappedView());</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">             &#x2F;&#x2F;正在显示图片的逻辑</span><br><span class="line">            displayer.display(bitmap, imageAware, loadedFrom);</span><br><span class="line">            engine.cancelDisplayTaskFor(imageAware);</span><br><span class="line">            listener.onLoadingComplete(imageUri, imageAware.getWrappedView(), bitmap);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;** Checks whether memory cache key (image URI) for current ImageAware is actual *&#x2F;</span><br><span class="line">    &#x2F;&#x2F;检查内存中当前图片的key是否是真实存在的</span><br><span class="line">    private boolean isViewWasReused() &#123;</span><br><span class="line">        String currentCacheKey &#x3D; engine.getLoadingUriForView(imageAware);</span><br><span class="line">        return !memoryCacheKey.equals(currentCacheKey);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面<code>run</code>方法中的逻辑也比较清晰，首先对是否能进行图片显示的环境做一定的判断，在当前环境可以显示图片的前提下，利用<code>BitmapDisplayer</code>中的<code>display</code>方法显示图片，然后通过<code>cancelDisplayTaskFor</code>方法将当前显示的图片从<code>cacheKeysForImageAwares</code>队列中移除。这里的<code>cacheKeysForImageAwares</code>指的是<code>ImageAware</code>与内存缓存<code>key</code>对应的<code>map</code>，<code>key</code> 为<code>ImageAware</code>的<code>id</code>，<code>value</code>为内存缓存的<code>key</code>。完成之后就回调<code>onLoadingComplete</code>方法。<br>但是注意到，在<code>ProcessAndDisplayImageTask</code>中，并没有直接将<code>displayBitmapTask</code>通过<code>start</code>或者是<code>run</code>方法将其执行，而是通过一个<code>LoadAndDisplayImageTask</code>中的<code>runTask</code>方法，我们来看其实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static void runTask(Runnable r, boolean sync, Handler handler, ImageLoaderEngine engine) &#123;</span><br><span class="line">    if (sync) &#123;</span><br><span class="line">        r.run();</span><br><span class="line">    &#125; else if (handler &#x3D;&#x3D; null) &#123;</span><br><span class="line">        engine.fireCallback(r);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        handler.post(r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从实现上来说，还是比较简单的。如果是同步加载的话，就直接调用<code>run</code>方法，否则（异步执行）就调用<code>handler</code>调用<code>post</code>方法将其投递到主线程中去执行，这个<code>handler</code>的实现在<code>ImageLoader</code>中。如果<code>handler</code>为空的话，就取消图片显示，直接处理善后工作。这个<code>handler</code>在<code>ImageLoader</code>中的实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private static Handler defineHandler(DisplayImageOptions options) &#123;</span><br><span class="line">    Handler handler &#x3D; options.getHandler();</span><br><span class="line">    if (options.isSyncLoading()) &#123;</span><br><span class="line">        handler &#x3D; null;</span><br><span class="line">    &#125; else if (handler &#x3D;&#x3D; null &amp;&amp; Looper.myLooper() &#x3D;&#x3D; Looper.getMainLooper()) &#123;</span><br><span class="line">        handler &#x3D; new Handler();</span><br><span class="line">    &#125;</span><br><span class="line">    return handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出来，handler的创建也只会在异步加载的时候才会创建，同步情况下不会创建handler。</p>
<h2 id="从网络上加载图片"><a href="#从网络上加载图片" class="headerlink" title="从网络上加载图片"></a>从网络上加载图片</h2><p>分析完本地加载图片后，我们来分析上面<code>displayImage</code>中缺失的代码片段2，即本地无法获取图片的图片加载逻辑，我们先来看其中的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public void displayImage(String uri, ImageAware imageAware, DisplayImageOptions options,</span><br><span class="line">            ImageSize targetSize, ImageLoadingListener listener, ImageLoadingProgressListener progressListener) &#123;</span><br><span class="line">    ...</span><br><span class="line">        Bitmap bmp &#x3D; configuration.memoryCache.get(memoryCacheKey);</span><br><span class="line">        if (bmp !&#x3D; null &amp;&amp; !bmp.isRecycled()) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F;这下面的代码就是在本地无法获取图片的情况下加载图片的逻辑</span><br><span class="line">            if (options.shouldShowImageOnLoading()) &#123;</span><br><span class="line">                imageAware.setImageDrawable(options.getImageOnLoading(configuration.resources));</span><br><span class="line">            &#125; else if (options.isResetViewBeforeLoading()) &#123;</span><br><span class="line">                imageAware.setImageDrawable(null);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ImageLoadingInfo imageLoadingInfo &#x3D; new ImageLoadingInfo(uri, imageAware, targetSize, memoryCacheKey,</span><br><span class="line">                    options, listener, progressListener, engine.getLockForUri(uri));</span><br><span class="line">            LoadAndDisplayImageTask displayTask &#x3D; new LoadAndDisplayImageTask(engine, imageLoadingInfo,</span><br><span class="line">                    defineHandler(options));</span><br><span class="line">            if (options.isSyncLoading()) &#123;</span><br><span class="line">                displayTask.run();</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                engine.submit(displayTask);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，在无法获取本地图片情况下加载图片的逻辑稍微比本地加载图片的逻辑稍微多一点，但实现上很多方法是相同的，我们一点一点来开始分析：</p>
<ol>
<li>首先利用<code>shouldShowImageOnLoading</code>方法判断在加载的过程中是否需要显示图片，当用户设置了<code>imageResOnLoading</code>占位图片资源id，或者设置了加载中占位图片drawable对象时其返回值为<code>ture</code>，即执行在图片加载过程中显示占位图片的逻辑。</li>
<li>在用户没有设置占位图片的情况下，会继续判断是否需要重设图片，若需要重设图片，就将图片设为null。</li>
<li>至于这里的<code>ImageLoadingInfo</code>(加载和显示图片任务需要的信息)和前面的实现一样，这里就不重复介绍了。</li>
<li>这里的<code>LoadAndDisplayImageTask</code>，为下载和显示图片任务，用于从网络、文件系统或者内存获取图片并解析，然后调用<code>DisplayBitmapTask</code>在<code>ImageAware</code>中显示图片。</li>
<li>在同步加载的情况下，直接运行<code>displayTask</code>。</li>
<li>异步加载的情况下，将<code>displayTask</code>提交到<code>taskDistributor</code>线程池中运行。<br>接下来，我们就具体分析<code>LoadAndDisplayImageTask</code>中的<code>run</code>方法。下面是<code>LoadAndDisplayImageTask</code>类中<code>run</code>的具体实现：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">    if (waitIfPaused()) return;</span><br><span class="line">    if (delayIfNeed()) return;</span><br><span class="line"></span><br><span class="line">    ---</span><br><span class="line">    暂时神略</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
可以看到，<code>LoadAndDisplayImageTask</code>中的<code>run()</code>方法里面的逻辑还是稍微有点复杂的。我们一点一点来分析；<br>首先看前面两个方法的实现，即3-4行的代码实现，他们在<code>LoadAndDisplayImageTask</code>类中的实现代码如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;主要用于判断当前线程是否被打断，被打断返回ture，否则返回isTaskNotActual()的返回值</span><br><span class="line">private boolean waitIfPaused() &#123;</span><br><span class="line">    AtomicBoolean pause &#x3D; engine.getPause();</span><br><span class="line">    if (pause.get()) &#123;</span><br><span class="line">        synchronized (engine.getPauseLock()) &#123;</span><br><span class="line">            if (pause.get()) &#123;</span><br><span class="line">                L.d(LOG_WAITING_FOR_RESUME, memoryCacheKey);</span><br><span class="line">                try &#123;</span><br><span class="line">                    engine.getPauseLock().wait();</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    L.e(LOG_TASK_INTERRUPTED, memoryCacheKey);</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">                L.d(LOG_RESUME_AFTER_PAUSE, memoryCacheKey);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return isTaskNotActual();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;主要用于判断是否需要预处理，不要要返回false，需要返回isTaskNotActual()的返回值</span><br><span class="line">private boolean delayIfNeed() &#123;</span><br><span class="line">    if (options.shouldDelayBeforeLoading()) &#123;</span><br><span class="line">        L.d(LOG_DELAY_BEFORE_LOADING, options.getDelayBeforeLoading(), memoryCacheKey);</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(options.getDelayBeforeLoading());</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            L.e(LOG_TASK_INTERRUPTED, memoryCacheKey);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return isTaskNotActual();</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;主要用于判断imageVire是否被回收和重用，满足其中一个条件返回ture，否则返回false</span><br><span class="line">private boolean isTaskNotActual() &#123;</span><br><span class="line">    return isViewCollected() || isViewReused();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;主要用于判断ImageView是否被GC回收了，回收了返回ture，否者返回false</span><br><span class="line">private boolean isViewCollected() &#123;</span><br><span class="line">    if (imageAware.isCollected()) &#123;</span><br><span class="line">        L.d(LOG_TASK_CANCELLED_IMAGEAWARE_COLLECTED, memoryCacheKey);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;主要用于判断imageView是否被重用，被重用返回true，否则返回false</span><br><span class="line">private boolean isViewReused() &#123;</span><br><span class="line">    String currentCacheKey &#x3D; engine.getLoadingUriForView(imageAware);</span><br><span class="line">    &#x2F;&#x2F; Check whether memory cache key (image URI) for current ImageAware is actual.</span><br><span class="line">    &#x2F;&#x2F; If ImageAware is reused for another task then current task should be cancelled.</span><br><span class="line">    boolean imageAwareWasReused &#x3D; !memoryCacheKey.equals(currentCacheKey);</span><br><span class="line">    if (imageAwareWasReused) &#123;</span><br><span class="line">        L.d(LOG_TASK_CANCELLED_IMAGEAWARE_REUSED, memoryCacheKey);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
看起来好像也有点复杂，但是并不难，我们直接一路看过去就好了。每个方法的作用我都已经在代码中添加了注释了，这里我们来整理一下思路：通过上面的源码，我们基本上可以确定他们的作用是什么了，但是为什么需要他们呢？我们试想这样一种场景，在使用ListView来显示图片时，在手指滑动的时候一般不会去加载图片，因为在这个过程中很多图片是没有必要加载的。这个时候我们就可以通过<code>PauseOnScrollListener(ImageLoader imageLoader, boolean pauseOnScroll, boolean pauseOnFling)</code>来控制在滑动过程中图片的加载。第一个参数用来控制手指按着滑动情况下的是否加载图片，第二个参数用来控制手指松开后时候加载图片。至于中间参数的参数和值的传递比较简单，这里就不全部给出来了，可以自行通过查看源码了解<code>pauseOnScroll</code>是如何改变<code>waitIfPaused</code>方法中<code>pause</code>的值的（默认为false）。<br>至于<code>isViewReused</code>的方法存在的意义就更好理解了，在ListView中存在一种复用的优化策略，即在ListView在滑动时，会复用Item，为了避免图片显示时的错位情况，在ImageLoader就通过<code>isViewReused</code>来解决这个问题。</li>
</ol>
<p>接下来我们继续看<code>LoadAndDisplayImageTask</code>中的<code>run()</code>方法中剩下的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">    ...</span><br><span class="line">    ReentrantLock loadFromUriLock &#x3D; imageLoadingInfo.loadFromUriLock;&#x2F;&#x2F;获取锁</span><br><span class="line">    L.d(LOG_START_DISPLAY_IMAGE_TASK, memoryCacheKey);</span><br><span class="line">    if (loadFromUriLock.isLocked()) &#123;   &#x2F;&#x2F;判断锁是否被持有</span><br><span class="line">        L.d(LOG_WAITING_FOR_IMAGE_LOADED, memoryCacheKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    loadFromUriLock.lock();&#x2F;加锁</span><br><span class="line">    Bitmap bmp;</span><br><span class="line">    try &#123;</span><br><span class="line">        checkTaskNotActual();&#x2F;&#x2F;判断当前请求是否是可实现的，（当imageView被GC回收或者此次请求的URL无法获取imageView时时为不可实现的请求）</span><br><span class="line"></span><br><span class="line">        bmp &#x3D; configuration.memoryCache.get(memoryCacheKey);&#x2F;&#x2F;尝试从内存中加载图片</span><br><span class="line">        if (bmp &#x3D;&#x3D; null || bmp.isRecycled()) &#123;</span><br><span class="line">            bmp &#x3D; tryLoadBitmap();&#x2F;&#x2F;尝试从文件中加载图片，如果没有再去网络中获取，然后将bitmap保存在文件系统中。</span><br><span class="line">            &#x2F;&#x2F;这个方法是重点，后面会进行讲到</span><br><span class="line">            if (bmp &#x3D;&#x3D; null) return; &#x2F;&#x2F; listener callback already was fired</span><br><span class="line"></span><br><span class="line">            checkTaskNotActual();</span><br><span class="line">            checkTaskInterrupted();&#x2F;&#x2F;用于判断当前任务有没有被打断，被打断直接抛出异常</span><br><span class="line"></span><br><span class="line">            if (options.shouldPreProcess()) &#123;&#x2F;&#x2F;默认为ture，表示缓存在内存之前没有要处理的程序</span><br><span class="line">                L.d(LOG_PREPROCESS_IMAGE, memoryCacheKey);</span><br><span class="line">                bmp &#x3D; options.getPreProcessor().process(bmp);&#x2F;&#x2F;对bitmap进行适当的剪裁</span><br><span class="line">                if (bmp &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    L.e(ERROR_PRE_PROCESSOR_NULL, memoryCacheKey);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (bmp !&#x3D; null &amp;&amp; options.isCacheInMemory()) &#123;&#x2F;&#x2F;如果有必要缓存到内存中的话</span><br><span class="line">                L.d(LOG_CACHE_IMAGE_IN_MEMORY, memoryCacheKey);</span><br><span class="line">                configuration.memoryCache.put(memoryCacheKey, bmp);&#x2F;&#x2F;将图片保存到内存缓存中去</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            loadedFrom &#x3D; LoadedFrom.MEMORY_CACHE;</span><br><span class="line">            L.d(LOG_GET_IMAGE_FROM_MEMORY_CACHE_AFTER_WAITING, memoryCacheKey);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (bmp !&#x3D; null &amp;&amp; options.shouldPostProcess()) &#123;</span><br><span class="line">            L.d(LOG_POSTPROCESS_IMAGE, memoryCacheKey);</span><br><span class="line">            bmp &#x3D; options.getPostProcessor().process(bmp);&#x2F;&#x2F;自定义的bitmap操作会在这里进行</span><br><span class="line">            if (bmp &#x3D;&#x3D; null) &#123;</span><br><span class="line">                L.e(ERROR_POST_PROCESSOR_NULL, memoryCacheKey);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        checkTaskNotActual();</span><br><span class="line">        checkTaskInterrupted();</span><br><span class="line">    &#125; catch (TaskCancelledException e) &#123;</span><br><span class="line">        fireCancelEvent(); &#x2F;&#x2F;解移除的监听 上面很多方法会抛出异常都需要这个方法来移除监听</span><br><span class="line">        return;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        loadFromUriLock.unlock();&#x2F;&#x2F;释放锁</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DisplayBitmapTask displayBitmapTask &#x3D; new DisplayBitmapTask(bmp, imageLoadingInfo, engine, loadedFrom); &#x2F;&#x2F;构建显示任务</span><br><span class="line">    runTask(displayBitmapTask, syncLoading, handler, engine);&#x2F;&#x2F;将图片显示到指定的imageView上</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码也有点多，但是在添加了先关的注解之后，详细阅读起来还是比较简单的。这里在梳理一下整个<code>LoadAndDisplayImageTask</code>中的<code>run</code>方法的相关逻辑。首先会判断当前是否是可以加载图片的状态，不可以加载图片的话就直接返回，什么都不做。在可以加载图片的前提下，会给以下的核心逻辑代码添加一个锁：【首先尝试从内存中获取图片，没有对应的图片就会从磁盘中寻找，如果磁盘中也找不到，那么就只能从网络中去需找，在找到图片后将其存在文件系统中，如果用户定义了图片的预处理，就会执行用户定义的图片预处理，如果需要缓存到内存就会缓存到内存中，继而执行用户定义的图片后处理（提前是用户定义了图片后处理），最后判断一下当前状态是否还可以显示图片，若当前状态不能显示图片就会直接抛出异常，在catch语句中移除相关的监听。如果当前状态还可以显示图片，在finally语句中释放锁 】以此保障多线程的可靠性，然后执行图片显示任务将图片显示到图片上，到此完成了整个图片的加载。用流程图表示如下：<br><img src="http://upload-images.jianshu.io/upload_images/2178834-16069ef078012739.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片加载流程"></p>
<p>下面我们来分析上面<code>run()</code>方法中最重要的一个方法<code>tryLoadBitmap（）</code>，他的实现也在<code>LoadAndDisplayImageTask</code>类中，实现代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">private Bitmap tryLoadBitmap() throws TaskCancelledException &#123;</span><br><span class="line">    Bitmap bitmap &#x3D; null;</span><br><span class="line">    try &#123;</span><br><span class="line">        File imageFile &#x3D; configuration.diskCache.get(uri);&#x2F;&#x2F;先判断文件中有没有该文件</span><br><span class="line">        if (imageFile !&#x3D; null &amp;&amp; imageFile.exists() &amp;&amp; imageFile.length() &gt; 0) &#123;&#x2F;&#x2F;如果文件中有该文件，就直接调用decodeImage去解码图片</span><br><span class="line">            L.d(LOG_LOAD_IMAGE_FROM_DISK_CACHE, memoryCacheKey);</span><br><span class="line">            loadedFrom &#x3D; LoadedFrom.DISC_CACHE;</span><br><span class="line"></span><br><span class="line">            checkTaskNotActual();&#x2F;&#x2F;判断当前是否具有加载图片的状态，这个方法在前面已经解析过了</span><br><span class="line">            bitmap &#x3D; decodeImage(Scheme.FILE.wrap(imageFile.getAbsolutePath()));&#x2F;&#x2F;解码图片</span><br><span class="line">        &#125;</span><br><span class="line">        if (bitmap &#x3D;&#x3D; null || bitmap.getWidth() &lt;&#x3D; 0 || bitmap.getHeight() &lt;&#x3D; 0) &#123;</span><br><span class="line">        &#x2F;&#x2F;表示文件中没有找到图片，就会指定到网络上获取bitmap，</span><br><span class="line">            L.d(LOG_LOAD_IMAGE_FROM_NETWORK, memoryCacheKey);</span><br><span class="line">            loadedFrom &#x3D; LoadedFrom.NETWORK;</span><br><span class="line"></span><br><span class="line">            String imageUriForDecoding &#x3D; uri;</span><br><span class="line">            if (options.isCacheOnDisk() &amp;&amp; tryCacheImageOnDisk()) &#123;</span><br><span class="line">            &#x2F;&#x2F;options.isCacheOnDisk()用来表是否需要将图片缓存到文件系统中，默认为fasle。</span><br><span class="line">                imageFile &#x3D; configuration.diskCache.get(uri);</span><br><span class="line">                if (imageFile !&#x3D; null) &#123;</span><br><span class="line">                    imageUriForDecoding &#x3D; Scheme.FILE.wrap(imageFile.getAbsolutePath());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; </span><br><span class="line"></span><br><span class="line">            checkTaskNotActual();</span><br><span class="line">            bitmap &#x3D; decodeImage(imageUriForDecoding);</span><br><span class="line"></span><br><span class="line">            if (bitmap &#x3D;&#x3D; null || bitmap.getWidth() &lt;&#x3D; 0 || bitmap.getHeight() &lt;&#x3D; 0) &#123;</span><br><span class="line">                fireFailEvent(FailType.DECODING_ERROR, null);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (IllegalStateException e) &#123;</span><br><span class="line">        fireFailEvent(FailType.NETWORK_DENIED, null);</span><br><span class="line">    &#125; catch (TaskCancelledException e) &#123;</span><br><span class="line">        throw e;</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        L.e(e);</span><br><span class="line">        fireFailEvent(FailType.IO_ERROR, e);</span><br><span class="line">    &#125; catch (OutOfMemoryError e) &#123;</span><br><span class="line">        L.e(e);</span><br><span class="line">        fireFailEvent(FailType.OUT_OF_MEMORY, e);</span><br><span class="line">    &#125; catch (Throwable e) &#123;</span><br><span class="line">        L.e(e);</span><br><span class="line">        fireFailEvent(FailType.UNKNOWN, e);</span><br><span class="line">    &#125;</span><br><span class="line">    return bitmap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码虽然看起来有点多，但是逻辑还是很清晰的，我在关键的地方都添加了注释，相信阅读起来很简单。这里再次梳理一下<code>tryLoadBitmap</code>的逻辑吧。首先从尝试从文件中去获取图片，如果能从文件中获取图片的话，就判断当前状态是否可以加载图片，然后通过<code>decodeImage</code>方法将图片解码成可以显示的格式。如果文件中没有要显示的图片，在设置了从网络获取图片的前提下就会利用<code>tryCacheImageOnDisk</code>方法从网络上获取图片，然后将图片解码成要显示的格式，可以参考下面的流程图：<br><img src="http://upload-images.jianshu.io/upload_images/2178834-96999153d13488db.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="tryLoadBitmap流程图"><br>在上面的流程中，我们对其中两个重要的方法来进一步的探究其实现，一个方法是<code>decodeImage</code>，另一个是<code>tryCacheImageOnDisk()</code>。着两个方法的实现源码如下，他们都在<code>LoadAndDisplayImageTask</code>类中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;解码图片</span><br><span class="line">private Bitmap decodeImage(String imageUri) throws IOException &#123;</span><br><span class="line">&#x2F;&#x2F;获取图片的</span><br><span class="line">    ViewScaleType viewScaleType &#x3D; imageAware.getScaleType();</span><br><span class="line">    ImageDecodingInfo decodingInfo &#x3D; new ImageDecodingInfo(memoryCacheKey, imageUri, uri, targetSize, viewScaleType,</span><br><span class="line">            getDownloader(), options);</span><br><span class="line">    return decoder.decode(decodingInfo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;** @return &lt;b&gt;true&lt;&#x2F;b&gt; - if image was downloaded successfully; &lt;b&gt;false&lt;&#x2F;b&gt; - otherwise *&#x2F;</span><br><span class="line">private boolean tryCacheImageOnDisk() throws TaskCancelledException &#123;</span><br><span class="line">    L.d(LOG_CACHE_IMAGE_ON_DISK, memoryCacheKey);</span><br><span class="line"></span><br><span class="line">    boolean loaded;</span><br><span class="line">    try &#123;</span><br><span class="line">        loaded &#x3D; downloadImage();</span><br><span class="line">        if (loaded) &#123;</span><br><span class="line">            int width &#x3D; configuration.maxImageWidthForDiskCache;</span><br><span class="line">            int height &#x3D; configuration.maxImageHeightForDiskCache;</span><br><span class="line">            if (width &gt; 0 || height &gt; 0) &#123;</span><br><span class="line">                L.d(LOG_RESIZE_CACHED_IMAGE_FILE, memoryCacheKey);</span><br><span class="line">                resizeAndSaveImage(width, height); &#x2F;&#x2F; TODO : process boolean result</span><br><span class="line">                &#x2F;&#x2F;解码成bitmap图片，并保存他。关于这个方法就不在深入了。</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        L.e(e);</span><br><span class="line">        loaded &#x3D; false;</span><br><span class="line">    &#125;</span><br><span class="line">    return loaded;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;负责下载图片，并将其保存到文件缓存中</span><br><span class="line">private boolean downloadImage() throws IOException &#123;</span><br><span class="line">    InputStream is &#x3D; getDownloader().getStream(uri, options.getExtraForDownloader());</span><br><span class="line">    if (is &#x3D;&#x3D; null) &#123;</span><br><span class="line">        L.e(ERROR_NO_IMAGE_STREAM, memoryCacheKey);</span><br><span class="line">        return false;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            return configuration.diskCache.save(uri, is, this);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            IoUtils.closeSilently(is);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里就不对上面的代码进行解释了，我们直接看<code>decode</code>方法在<code>BaseImageDecoder</code>中的具体实现，至于其他的方法，请参考注释。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Bitmap decode(ImageDecodingInfo decodingInfo) throws IOException &#123;</span><br><span class="line">    Bitmap decodedBitmap;</span><br><span class="line">    ImageFileInfo imageInfo;</span><br><span class="line"></span><br><span class="line">    InputStream imageStream &#x3D; getImageStream(decodingInfo);</span><br><span class="line">    if (imageStream &#x3D;&#x3D; null) &#123;</span><br><span class="line">        L.e(ERROR_NO_IMAGE_STREAM, decodingInfo.getImageKey());</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    try &#123;</span><br><span class="line">        imageInfo &#x3D; defineImageSizeAndRotation(imageStream, decodingInfo);</span><br><span class="line">        imageStream &#x3D; resetStream(imageStream, decodingInfo);</span><br><span class="line">        Options decodingOptions &#x3D; prepareDecodingOptions(imageInfo.imageSize, decodingInfo);</span><br><span class="line">        decodedBitmap &#x3D; BitmapFactory.decodeStream(imageStream, null, decodingOptions);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        IoUtils.closeSilently(imageStream);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (decodedBitmap &#x3D;&#x3D; null) &#123;</span><br><span class="line">        L.e(ERROR_CANT_DECODE_IMAGE, decodingInfo.getImageKey());</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        decodedBitmap &#x3D; considerExactScaleAndOrientatiton(decodedBitmap, decodingInfo, imageInfo.exif.rotation,</span><br><span class="line">                imageInfo.exif.flipHorizontal);</span><br><span class="line">    &#125;</span><br><span class="line">    return decodedBitmap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>综上，我们暂时分析完了<code>run()</code>方法中逻辑和主要方法。接下来我们继续分析异步的情况，这里再次贴出之前<code>displayImage</code>的主要流程代码。因为之前的代码隔得有点远了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public void displayImage(String uri, ImageAware imageAware, DisplayImageOptions options,</span><br><span class="line">ImageSize targetSize, ImageLoadingListener listener, ImageLoadingProgressListener progressListener) &#123;</span><br><span class="line">      ---</span><br><span class="line">Bitmap bmp &#x3D; configuration.memoryCache.get(memoryCacheKey);</span><br><span class="line">    if (bmp !&#x3D; null &amp;&amp; !bmp.isRecycled()) &#123;</span><br><span class="line">        if (options.shouldPostProcess()) &#123;</span><br><span class="line">           ...</span><br><span class="line">           if (options.isSyncLoading()) &#123;</span><br><span class="line">                displayTask.run();</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                engine.submit(displayTask);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            options.getDisplayer().display(bmp, imageAware, LoadedFrom.MEMORY_CACHE);</span><br><span class="line">            listener.onLoadingComplete(uri, imageAware.getWrappedView(), bmp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">       ...</span><br><span class="line">       缺失的代码片段2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们之前已经分析了<code>displayTask.run();</code>的主要流程，接下来我们分析异步的执行<code>engine.submit(displayTask);</code>的主要流程和方法，他的实现主要在<code>ImageLoaderEngine</code>中，<code>submit</code>的实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void submit(ProcessAndDisplayImageTask task) &#123;</span><br><span class="line">    initExecutorsIfNeed();</span><br><span class="line">    taskExecutorForCachedImages.execute(task);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法很简单，首先只有两个方法调用，第一行代码从名字分析就应该是用来初始化Executor的（有必要的话），然后执行将此次任务提交到线程池中运行。在线程池中的执行也会执行调用之前的run方法，这里就不再分析了。我们分析一下第一行代码，验证一下我们的猜想是不是正确的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private void initExecutorsIfNeed() &#123;</span><br><span class="line">    if (!configuration.customExecutor &amp;&amp; ((ExecutorService) taskExecutor).isShutdown()) &#123;</span><br><span class="line">        taskExecutor &#x3D; createTaskExecutor();</span><br><span class="line">    &#125;</span><br><span class="line">    if (!configuration.customExecutorForCachedImages &amp;&amp; ((ExecutorService) taskExecutorForCachedImages)</span><br><span class="line">            .isShutdown()) &#123;</span><br><span class="line">        taskExecutorForCachedImages &#x3D; createTaskExecutor();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面代码分析：首先判断当前的<code>taskExecutor</code>是不是关闭了，如果处于关闭状态就创建一个新<code>的Executor</code>，这里的<code>taskExecutor</code>指的是用与执行从源获取图片任务的线程池。然后判断<code>taskExecutorForCachedImages</code>是不是就绪，如果他被关闭的话就创建一个新的线程池<code>taskExecutorForCachedImages</code>，用于执行从缓存获取图片任务的线程池。综上，源码验证了我们之前的猜测，<code>initExecutorsIfNeed</code>方法的确是用来初始化相关线程池的。</p>
<h2 id="displayImage方法总结"><a href="#displayImage方法总结" class="headerlink" title="displayImage方法总结"></a>displayImage方法总结</h2><p>从上面的流程中，可以明显看出来，<code>displayImage</code>方法就是<code>imageLoader</code>加载图片的核心，我们在这里在来总结一下整个<code>displayImage</code>的逻辑，先将整个<code>displayImage</code>代码完整的贴上来：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">public void displayImage(String uri, ImageAware imageAware, DisplayImageOptions options,</span><br><span class="line">        ImageSize targetSize, ImageLoadingListener listener, ImageLoadingProgressListener progressListener) &#123;</span><br><span class="line">    checkConfiguration();</span><br><span class="line">    if (imageAware &#x3D;&#x3D; null) &#123;</span><br><span class="line">        throw new IllegalArgumentException(ERROR_WRONG_ARGUMENTS);</span><br><span class="line">    &#125;</span><br><span class="line">    if (listener &#x3D;&#x3D; null) &#123;</span><br><span class="line">        listener &#x3D; defaultListener;</span><br><span class="line">    &#125;</span><br><span class="line">    if (options &#x3D;&#x3D; null) &#123;</span><br><span class="line">        options &#x3D; configuration.defaultDisplayImageOptions;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (TextUtils.isEmpty(uri)) &#123;</span><br><span class="line">        engine.cancelDisplayTaskFor(imageAware);</span><br><span class="line">        listener.onLoadingStarted(uri, imageAware.getWrappedView());</span><br><span class="line">        if (options.shouldShowImageForEmptyUri()) &#123;</span><br><span class="line">            imageAware.setImageDrawable(options.getImageForEmptyUri(configuration.resources));</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            imageAware.setImageDrawable(null);</span><br><span class="line">        &#125;</span><br><span class="line">        listener.onLoadingComplete(uri, imageAware.getWrappedView(), null);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (targetSize &#x3D;&#x3D; null) &#123;</span><br><span class="line">        targetSize &#x3D; ImageSizeUtils.defineTargetSizeForView(imageAware, configuration.getMaxImageSize());</span><br><span class="line">    &#125;</span><br><span class="line">    String memoryCacheKey &#x3D; MemoryCacheUtils.generateKey(uri, targetSize);</span><br><span class="line">    engine.prepareDisplayTaskFor(imageAware, memoryCacheKey);</span><br><span class="line"></span><br><span class="line">    listener.onLoadingStarted(uri, imageAware.getWrappedView());</span><br><span class="line"></span><br><span class="line">    Bitmap bmp &#x3D; configuration.memoryCache.get(memoryCacheKey);</span><br><span class="line">    if (bmp !&#x3D; null &amp;&amp; !bmp.isRecycled()) &#123;</span><br><span class="line">        L.d(LOG_LOAD_IMAGE_FROM_MEMORY_CACHE, memoryCacheKey);</span><br><span class="line"></span><br><span class="line">        if (options.shouldPostProcess()) &#123;</span><br><span class="line">            ImageLoadingInfo imageLoadingInfo &#x3D; new ImageLoadingInfo(uri, imageAware, targetSize, memoryCacheKey,</span><br><span class="line">                    options, listener, progressListener, engine.getLockForUri(uri));</span><br><span class="line">            ProcessAndDisplayImageTask displayTask &#x3D; new ProcessAndDisplayImageTask(engine, bmp, imageLoadingInfo,</span><br><span class="line">                    defineHandler(options));</span><br><span class="line">            if (options.isSyncLoading()) &#123;</span><br><span class="line">                displayTask.run();</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                engine.submit(displayTask);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            options.getDisplayer().display(bmp, imageAware, LoadedFrom.MEMORY_CACHE);</span><br><span class="line">            listener.onLoadingComplete(uri, imageAware.getWrappedView(), bmp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (options.shouldShowImageOnLoading()) &#123;</span><br><span class="line">            imageAware.setImageDrawable(options.getImageOnLoading(configuration.resources));</span><br><span class="line">        &#125; else if (options.isResetViewBeforeLoading()) &#123;</span><br><span class="line">            imageAware.setImageDrawable(null);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ImageLoadingInfo imageLoadingInfo &#x3D; new ImageLoadingInfo(uri, imageAware, targetSize, memoryCacheKey,</span><br><span class="line">                options, listener, progressListener, engine.getLockForUri(uri));</span><br><span class="line">        LoadAndDisplayImageTask displayTask &#x3D; new LoadAndDisplayImageTask(engine, imageLoadingInfo,</span><br><span class="line">                defineHandler(options));</span><br><span class="line">        if (options.isSyncLoading()) &#123;</span><br><span class="line">            displayTask.run();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            engine.submit(displayTask);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将上面代码用流程图可以表示为以下的表现形式。<br><img src="http://ovec6nnof.bkt.clouddn.com/imagerLoader%E4%B8%AD%E7%9A%84dispalyer%E9%80%BB%E8%BE%91.svg" alt="displayImage"></p>
<p align="center">（原创图，敬请批评指正）</p>

<p>可以看到，在上面流程图算比较复杂，但是逻辑很清晰，基本上所有的功能集中在<code>displayImage</code>中进行调度使用，所以给我们分析<code>ImageLoader</code>降低了不少的难度。<br>至于上面流程图中没有具体体现的任务可以参考前面的分析。</p>
<p>针对上面三种显示图片的方法，最终都会通过调用<code>displayImage</code>来实现，只是对其中的参数进行了一定的设置，这里就不在详细介绍了，有兴趣的可以自己查阅源码。</p>
<h1 id="LRUCache和DisLruCacher分析"><a href="#LRUCache和DisLruCacher分析" class="headerlink" title="LRUCache和DisLruCacher分析"></a>LRUCache和DisLruCacher分析</h1><h2 id="LRUCache"><a href="#LRUCache" class="headerlink" title="LRUCache"></a>LRUCache</h2><p>LruCache是android 3.1所提供的一个缓存类，他是一个泛型类，他内部采用一个<code>LinkedHashMap</code>以强引用的方式存储外界的缓存对象，其提供了<code>get</code>和<code>put</code>方法来完成缓存的获取和添加属性，当缓存满时，LruCache会移除较早使用的缓存对象，然后在添加新的缓存对象。<br>构造方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public LruCache(int maxSize) &#123;</span><br><span class="line">       if (maxSize &lt;&#x3D; 0) &#123;</span><br><span class="line">           throw new IllegalArgumentException(&quot;maxSize &lt;&#x3D; 0&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">       this.maxSize &#x3D; maxSize;</span><br><span class="line">       this.map &#x3D; new LinkedHashMap&lt;K, V&gt;(0, 0.75f, true);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，<code>LruCache</code>的构造方法非常简单，只需要传入一个maxSize设置最大的缓存对象即可，然后实例化<code>map</code>对象。<br>这里也附上get和put的源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">public final V get(K key) &#123;</span><br><span class="line">    if (key &#x3D;&#x3D; null) &#123;</span><br><span class="line">        throw new NullPointerException(&quot;key &#x3D;&#x3D; null&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    V mapValue;</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">        mapValue &#x3D; map.get(key);</span><br><span class="line">        if (mapValue !&#x3D; null) &#123;</span><br><span class="line">            hitCount++;</span><br><span class="line">            return mapValue;</span><br><span class="line">        &#125;</span><br><span class="line">        missCount++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  V createdValue &#x3D; create(key);</span><br><span class="line">    if (createdValue &#x3D;&#x3D; null) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">        createCount++;</span><br><span class="line">        mapValue &#x3D; map.put(key, createdValue);</span><br><span class="line"></span><br><span class="line">        if (mapValue !&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F; There was a conflict so undo that last put</span><br><span class="line">            map.put(key, mapValue);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            size +&#x3D; safeSizeOf(key, createdValue);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (mapValue !&#x3D; null) &#123;</span><br><span class="line">        entryRemoved(false, key, createdValue, mapValue);</span><br><span class="line">        return mapValue;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        trimToSize(maxSize);</span><br><span class="line">        return createdValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">public final V put(K key, V value) &#123;</span><br><span class="line">    if (key &#x3D;&#x3D; null || value &#x3D;&#x3D; null) &#123;</span><br><span class="line">        throw new NullPointerException(&quot;key &#x3D;&#x3D; null || value &#x3D;&#x3D; null&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    V previous;</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">        putCount++;</span><br><span class="line">        size +&#x3D; safeSizeOf(key, value);</span><br><span class="line">        previous &#x3D; map.put(key, value);</span><br><span class="line">        if (previous !&#x3D; null) &#123;</span><br><span class="line">            size -&#x3D; safeSizeOf(key, previous);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (previous !&#x3D; null) &#123;</span><br><span class="line">        entryRemoved(false, key, previous, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    trimToSize(maxSize);</span><br><span class="line">    return previous;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更多的分析可以参考<a href="http://blog.csdn.net/xiaanming/article/details/27525741" target="_blank" rel="noopener">这里</a>。</p>
<h2 id="DisLruCache"><a href="#DisLruCache" class="headerlink" title="DisLruCache"></a>DisLruCache</h2><p>DisLruCache用于实现存储设置缓存，即磁盘缓存，他通过将缓存对象写入文件系统从而实现缓存的效果。<br>我们在这里对其创建，缓存添加和移除缓存进行简单的分析。<br>创建过程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private DiskLruCache(File directory, int appVersion, int valueCount, long maxSize) &#123;</span><br><span class="line"> ...简单的赋值，就不贴出来了</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中的四个参数分别是：</p>
<ul>
<li><code>directory</code>表示磁盘存在文件系统中的存储路径；</li>
<li><code>appVersion</code> 表示应用的版本号，一般设置1就可；</li>
<li><code>valueCount</code> 表示单个节点锁对应的数据的个数，一般设为1就可以了；</li>
<li><code>maxSize</code> 表示缓存的总大小，比如50MB，当缓存大小超过这个设置值后，DisLruCache会清除一些缓存从而保证总大小不大于这个设定值。<br>当然，<code>DiskLruCache</code>提供了<code>open</code>方法来创建自身：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public static DiskLruCache open(File directory, int appVersion, int valueCount, long maxSize)</span><br><span class="line">    throws IOException &#123;</span><br><span class="line">  if (maxSize &lt;&#x3D; 0) &#123;</span><br><span class="line">    throw new IllegalArgumentException(&quot;maxSize &lt;&#x3D; 0&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  if (valueCount &lt;&#x3D; 0) &#123;</span><br><span class="line">    throw new IllegalArgumentException(&quot;valueCount &lt;&#x3D; 0&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; If a bkp file exists, use it instead.</span><br><span class="line">  File backupFile &#x3D; new File(directory, JOURNAL_FILE_BACKUP);</span><br><span class="line">  if (backupFile.exists()) &#123;</span><br><span class="line">    File journalFile &#x3D; new File(directory, JOURNAL_FILE);</span><br><span class="line">    &#x2F;&#x2F; If journal file also exists just delete backup file.</span><br><span class="line">    if (journalFile.exists()) &#123;</span><br><span class="line">      backupFile.delete();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      renameTo(backupFile, journalFile, false);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
<li><em>DisLruCacher的缓存添加：*</em><br>DisLruCache的缓存操作通过Editor完成的，Editor表示一个缓存对象的编辑对象。在ImageLoader的运用，首先需要获取图片的URL所对用的Key，然后根据Key就可以通过<code>edit()</code>方法来获取Editor对象，如果这个缓存正在被编辑，那么edit会返回null，即DisLrucache不允许同时编辑一个缓存对象。之所以要把url转换成key，是因为url中可能有特殊字符，这将影响url在Adnroid中的直接使用，一般采用url的md5值作为key。</li>
</ul>
<p><strong>DisLruCacher的缓存查找：</strong><br>缓存查找过程也需要将url转换成key，然后通过<code>DisLrache</code>的get方法得到一个<code>snapshot</code>对象即可得到缓存的文件输入流，进而得到Bitmap对象。为了避免加载图片过程中导致的OOM问题，一般建议不直接加载原始图片，建议先对图片进行压缩之后在去加载。下面是<code>get</code>方法的实现逻辑：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public synchronized Value get(String key) throws IOException &#123;</span><br><span class="line">   checkNotClosed();</span><br><span class="line">   Entry entry &#x3D; lruEntries.get(key);</span><br><span class="line">   if (entry &#x3D;&#x3D; null) &#123;</span><br><span class="line">     return null;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   if (!entry.readable) &#123;</span><br><span class="line">     return null;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   for (File file : entry.cleanFiles) &#123;</span><br><span class="line">       &#x2F;&#x2F; A file must have been deleted manually!</span><br><span class="line">       if (!file.exists()) &#123;</span><br><span class="line">           return null;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   redundantOpCount++;</span><br><span class="line">   journalWriter.append(READ);</span><br><span class="line">   journalWriter.append(&#39; &#39;);</span><br><span class="line">   journalWriter.append(key);</span><br><span class="line">   journalWriter.append(&#39;\n&#39;);</span><br><span class="line">   if (journalRebuildRequired()) &#123;</span><br><span class="line">     executorService.submit(cleanupCallable);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   return new Value(key, entry.sequenceNumber, entry.cleanFiles, entry.lengths);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p><strong>DisLruCacher的缓存删除：</strong><br><code>DisLruCacher</code>提供了<code>remove</code>,<code>delete</code>方法来进行磁盘的删除操作。删除通过需要将url转换成key，然后从<code>lruEntries</code>的<code>LinkedHashMap</code>对象中获取该对象，在对象存在的前提下，删除文件中对应的文件，然后移除<code>lruEntries</code>对应的key值。代码实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public synchronized boolean remove(String key) throws IOException &#123;</span><br><span class="line">   checkNotClosed();</span><br><span class="line">   Entry entry &#x3D; lruEntries.get(key);</span><br><span class="line">   if (entry &#x3D;&#x3D; null || entry.currentEditor !&#x3D; null) &#123;</span><br><span class="line">     return false;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   for (int i &#x3D; 0; i &lt; valueCount; i++) &#123;</span><br><span class="line">     File file &#x3D; entry.getCleanFile(i);</span><br><span class="line">     if (file.exists() &amp;&amp; !file.delete()) &#123;</span><br><span class="line">       throw new IOException(&quot;failed to delete &quot; + file);</span><br><span class="line">     &#125;</span><br><span class="line">     size -&#x3D; entry.lengths[i];</span><br><span class="line">     entry.lengths[i] &#x3D; 0;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   redundantOpCount++;</span><br><span class="line">   journalWriter.append(REMOVE);</span><br><span class="line">   journalWriter.append(&#39; &#39;);</span><br><span class="line">   journalWriter.append(key);</span><br><span class="line">   journalWriter.append(&#39;\n&#39;);</span><br><span class="line"></span><br><span class="line">   lruEntries.remove(key);</span><br><span class="line"></span><br><span class="line">   if (journalRebuildRequired()) &#123;</span><br><span class="line">     executorService.submit(cleanupCallable);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   return true;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h1 id="杂谈"><a href="#杂谈" class="headerlink" title="杂谈"></a>杂谈</h1><p>下面是我对<code>imageLoader</code>源码分析之后的一些感悟和一些总结，有一些还是面试时被问到的问题，这里一并记录下来。</p>
<h2 id="ImageLoader运用的设计模式"><a href="#ImageLoader运用的设计模式" class="headerlink" title="ImageLoader运用的设计模式"></a>ImageLoader运用的设计模式</h2><p>从源码分析上来看，最明显的就是建造者模式和单例模式，这两种模式在实际项目中也是运行最广的设计模式。还使用了工厂模式，装饰者模式，代理模式，策略模式等等。<a href="https://github.com/mingjunli/JavaDesignPatterns" target="_blank" rel="noopener">设计模式参考</a></p>
<h2 id="当ListView显示图片，滚动时ImageLoader是如何避免OOM的？"><a href="#当ListView显示图片，滚动时ImageLoader是如何避免OOM的？" class="headerlink" title="当ListView显示图片，滚动时ImageLoader是如何避免OOM的？"></a>当ListView显示图片，滚动时ImageLoader是如何避免OOM的？</h2><p>首先是对缓存进行管理，具体管理内存的方法是LruCache，实现算法是LRU：通过优先淘汰最近最少使用的缓存对象，保证总缓存大小不高于限定值。</p>
<h2 id="LRUCacher算法的具体实现"><a href="#LRUCacher算法的具体实现" class="headerlink" title="LRUCacher算法的具体实现"></a>LRUCacher算法的具体实现</h2><p>他内部采用一个LinkedhashMap以强引用的方式存储外界的缓存对象，其提供了get和put方法来完成缓存的获取和添加操作，当缓存满时，LRUcacher会移除较早使用的缓存对象，然后再添加新的缓存对象。</p>
<h2 id="ImagerLoader的为什么会被淘汰"><a href="#ImagerLoader的为什么会被淘汰" class="headerlink" title="ImagerLoader的为什么会被淘汰"></a>ImagerLoader的为什么会被淘汰</h2><ul>
<li>首先相对于Gilde来说，ImagerLoader的配置相对繁琐，需要对其中的参数有比较详细的了解才能比较好的驾驭ImageLoader，而Gilde简单易用，没有繁琐复杂的配置；</li>
<li>Gilde中的内存管理比ImageLoader做的更好，虽然ImageLoader也说有三层缓存，但是实际上是两层，一个磁盘，一个内存缓存。而Gilde中的内存管理做到了两级内存缓存，更加可靠；</li>
<li>在网络请求方面，ImageLoader采用的是HttpConnection，而Gilde默认采用更加高效的okhttp，虽然两者都支持自定义下载器，但是明显Gilde的支持更好。</li>
</ul>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul>
<li><a href="https://github.com/nostra13/Android-Universal-Image-Loader" target="_blank" rel="noopener">官方github</a></li>
<li><a href="http://a.codekk.com/detail/Android/huxian99/Android%20Universal%20Image%20Loader%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90" target="_blank" rel="noopener">Android Universal Image Loader 源码分析</a></li>
<li><a href="http://blog.csdn.net/xiaanming/article/details/26810303" target="_blank" rel="noopener">universal-imager-Loader完全解析</a></li>
<li>《android开发艺术探索》</li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD/" rel="tag"># 图片加载</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2017/08/30/%E6%96%87%E6%A1%A3%E6%9F%A5%E7%9C%8B%E5%99%A8/" rel="prev" title="文档查看器">
      <i class="fa fa-chevron-left"></i> 文档查看器
    </a></div>
      <div class="post-nav-item">
    <a href="/2017/09/02/okhttp%E8%A7%A3%E6%9E%90/" rel="next" title="okhttp解析">
      okhttp解析 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#ImagerLoader特征"><span class="nav-number">1.</span> <span class="nav-text">ImagerLoader特征</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#开始使用"><span class="nav-number">2.</span> <span class="nav-text">开始使用</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ImageLoaderConfiguration配置实现"><span class="nav-number">3.</span> <span class="nav-text">ImageLoaderConfiguration配置实现</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#加载配置"><span class="nav-number">4.</span> <span class="nav-text">加载配置</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#加载图片"><span class="nav-number">5.</span> <span class="nav-text">加载图片</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#从网络上加载图片"><span class="nav-number">5.1.</span> <span class="nav-text">从网络上加载图片</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#displayImage方法总结"><span class="nav-number">5.2.</span> <span class="nav-text">displayImage方法总结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#LRUCache和DisLruCacher分析"><span class="nav-number">6.</span> <span class="nav-text">LRUCache和DisLruCacher分析</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#LRUCache"><span class="nav-number">6.1.</span> <span class="nav-text">LRUCache</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DisLruCache"><span class="nav-number">6.2.</span> <span class="nav-text">DisLruCache</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#杂谈"><span class="nav-number">7.</span> <span class="nav-text">杂谈</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#ImageLoader运用的设计模式"><span class="nav-number">7.1.</span> <span class="nav-text">ImageLoader运用的设计模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#当ListView显示图片，滚动时ImageLoader是如何避免OOM的？"><span class="nav-number">7.2.</span> <span class="nav-text">当ListView显示图片，滚动时ImageLoader是如何避免OOM的？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LRUCacher算法的具体实现"><span class="nav-number">7.3.</span> <span class="nav-text">LRUCacher算法的具体实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ImagerLoader的为什么会被淘汰"><span class="nav-number">7.4.</span> <span class="nav-text">ImagerLoader的为什么会被淘汰</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#参考链接"><span class="nav-number">8.</span> <span class="nav-text">参考链接</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">reoger</p>
  <div class="site-description" itemprop="description">reoger</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">56</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">33</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">reoger</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
