<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"reoger.tk","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="reoger">
<meta property="og:type" content="website">
<meta property="og:title" content="reoger的记录">
<meta property="og:url" content="http://reoger.tk/page/2/index.html">
<meta property="og:site_name" content="reoger的记录">
<meta property="og:description" content="reoger">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="reoger">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://reoger.tk/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>reoger的记录</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">reoger的记录</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">--以后的你会感激现在那么努力的自己</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>日程表</a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>公益 404</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://reoger.tk/2018/11/01/algorithm/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="reoger">
      <meta itemprop="description" content="reoger">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="reoger的记录">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/11/01/algorithm/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/" class="post-title-link" itemprop="url">二叉搜索树的最近公共祖先</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-11-01 23:41:48" itemprop="dateCreated datePublished" datetime="2018-11-01T23:41:48+08:00">2018-11-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-12 23:09:00" itemprop="dateModified" datetime="2020-04-12T23:09:00+08:00">2020-04-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/" itemprop="url" rel="index"><span itemprop="name">algorithm</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="二叉搜索树的最近公共祖先"><a href="#二叉搜索树的最近公共祖先" class="headerlink" title="二叉搜索树的最近公共祖先"></a><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/" target="_blank" rel="noopener">二叉搜索树的最近公共祖先</a></h3><p>难度 <strong>简单</strong></p>
<p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p>
<p>中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。”</p>
<p>例如，给定如下二叉搜索树:  root = [6,2,8,0,4,7,9,null,null,3,5]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">     _______6______</span><br><span class="line">    &#x2F;              \</span><br><span class="line"> ___2__          ___8__</span><br><span class="line">&#x2F;      \        &#x2F;      \</span><br><span class="line">0      _4       7       9</span><br><span class="line">      &#x2F;  \</span><br><span class="line">      3   5</span><br></pre></td></tr></table></figure>

<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">**输入:** root &#x3D; [6,2,8,0,4,7,9,null,null,3,5], p &#x3D; 2, q &#x3D; 8</span><br><span class="line">**输出:** 6 </span><br><span class="line">**解释:** 节点 2 和节点 8 的最近公共祖先是 6。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">**输入:** root &#x3D; [6,2,8,0,4,7,9,null,null,3,5], p &#x3D; 2, q &#x3D; 4</span><br><span class="line">**输出:** 2</span><br><span class="line">**解释:** 节点 &#96;2&#96; 和节点 &#96;4&#96; 的最近公共祖先是 &#96;2&#96;, 因为根据定义最近公共祖先节点可以为节点本身。</span><br></pre></td></tr></table></figure>

<p><strong>说明:</strong></p>
<ul>
<li>所有节点的值都是唯一的。</li>
<li>p、q 为不同节点且均存在于给定的二叉搜索树中。</li>
</ul>
<h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><h3 id="解法1，自顶向下遍历"><a href="#解法1，自顶向下遍历" class="headerlink" title="解法1，自顶向下遍历"></a>解法1，自顶向下遍历</h3><p>我们可以从根结点出发，判断当前结点的左右子树是否包含这两个结点。如果左子树包含两个结点，则它们的最低公共祖先结点也一定在左子树中。如果右子树包含两个结点，则它们的最低公共祖先结点也一定在右子树中。如果一个结点在左子树，而另一个结点在右子树中，则当前结点就是它们的最低公共祖先结点。根据该思路写出代码如下，注意这里已经假定p和q是二叉树中的结点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123;</span><br><span class="line">       if (root &#x3D;&#x3D; null)</span><br><span class="line">           return null;</span><br><span class="line">      if (containTargetTreeNode(root.left, p)  &amp;&amp; containTargetTreeNode(root.left, q))&#123;</span><br><span class="line">          return lowestCommonAncestor(root.left, p, q);</span><br><span class="line">      &#125;else if (containTargetTreeNode(root.right, p)  &amp;&amp; containTargetTreeNode(root.right, q))&#123;</span><br><span class="line">          return lowestCommonAncestor(root.right, p, q);</span><br><span class="line">      &#125;</span><br><span class="line">       return root;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   private boolean containTargetTreeNode(TreeNode root, TreeNode targetNode) &#123;</span><br><span class="line">       if (root &#x3D;&#x3D; null)</span><br><span class="line">           return false;</span><br><span class="line">       if (root &#x3D;&#x3D; targetNode)</span><br><span class="line">           return true;</span><br><span class="line">       return containTargetTreeNode(root.left, targetNode) || containTargetTreeNode(root.right, targetNode);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="思路二：自顶向上"><a href="#思路二：自顶向上" class="headerlink" title="思路二：自顶向上"></a>思路二：自顶向上</h3><p>由于自顶向下的方法需要重复遍历结点，使用自底向上的方法可以避免这种情况。</p>
<p>自底向上遍历结点，一旦遇到结点等于p或者q，则将其向上传递给它的父结点。父结点会判断它的左右子树是否都包含其中一个结点，如果是，则父结点一定是这两个节点p和q的LCA，传递父结点到root。如果不是，我们向上传递其中的包含结点p或者q的子结点，或者NULL(如果子结点不包含任何一个)。该方法时间复杂度为O(N)。</p>
<p>Language: <strong>Java</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (p == root || q == root)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        TreeNode l = lowestCommonAncestor(root.left, p, q);</span><br><span class="line">        TreeNode r = lowestCommonAncestor(root.right, p, q);</span><br><span class="line">        <span class="keyword">if</span> (l != <span class="keyword">null</span> &amp;&amp; r != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">return</span> l == <span class="keyword">null</span> ? r : l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="思路三：利用搜索树的性质"><a href="#思路三：利用搜索树的性质" class="headerlink" title="思路三：利用搜索树的性质"></a>思路三：利用搜索树的性质</h3><p>因为树是二叉树，我们从根节点开始遍历，一定有顶点root的值大于p和q的值时，p、q的最近祖先一定在root的左子树下，当root的值小于p、q的值时，那么p、q的最近祖先一定在root的左子树下，不是上述两种情况的话，说明当前的root已经是最近的祖先了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor3</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (root.val &gt; p.val &amp;&amp; root.val &gt; q.val)</span><br><span class="line">            <span class="keyword">return</span> lowestCommonAncestor3(root.left, p, q);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (root.val &lt; p.val &amp;&amp; root.val &lt; q.val)</span><br><span class="line">            <span class="keyword">return</span> lowestCommonAncestor3(root.right, p, q);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://reoger.tk/2018/11/01/algorithm/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="reoger">
      <meta itemprop="description" content="reoger">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="reoger的记录">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/11/01/algorithm/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C/" class="post-title-link" itemprop="url">二叉树中的最大路径和</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-11-01 01:06:52" itemprop="dateCreated datePublished" datetime="2018-11-01T01:06:52+08:00">2018-11-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-12 23:09:29" itemprop="dateModified" datetime="2020-04-12T23:09:29+08:00">2020-04-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/" itemprop="url" rel="index"><span itemprop="name">algorithm</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="二叉树中的最大路径和"><a href="#二叉树中的最大路径和" class="headerlink" title="二叉树中的最大路径和"></a><a href="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/" target="_blank" rel="noopener">二叉树中的最大路径和</a></h3><p>难度 <strong>困难</strong></p>
<p>给定一个<strong>非空</strong>二叉树，返回其最大路径和。</p>
<p>本题中，路径被定义为一条从树中任意节点出发，达到任意节点的序列。该路径<strong>至少包含一个</strong>节点，且不一定经过根节点。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">**输入:** [1,2,3]</span><br><span class="line"></span><br><span class="line">       **1**</span><br><span class="line">      **&#x2F; \**</span><br><span class="line">     **2**   **3**</span><br><span class="line"></span><br><span class="line">**输出:** 6</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">**输入:** [-10,9,20,null,null,15,7]</span><br><span class="line"></span><br><span class="line">   -10</span><br><span class="line">   &#x2F; \</span><br><span class="line">  9  **20**</span><br><span class="line">    **&#x2F;  \**</span><br><span class="line">   **15   7**</span><br><span class="line"></span><br><span class="line">**输出:** 42</span><br></pre></td></tr></table></figure>

<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>需找一个最大的路径和，势必会以某一个节点为顶点，我们以某个顶点去寻找以其为顶点的最大的路径和，然后遍历二叉树上所有的节点，选出最大的路径和即可。</p>
<h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><p>Language: <strong>Java</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">         res = Integer.MIN_VALUE;</span><br><span class="line">        oneOther(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">oneOther</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = oneOther(root.left);</span><br><span class="line">        <span class="keyword">int</span> right = oneOther(root.right);</span><br><span class="line">        res = Math.max(Math.max(left, <span class="number">0</span>) + Math.max(right, <span class="number">0</span>) + root.val , res);</span><br><span class="line">           <span class="keyword">return</span> Math.max(Math.max(left,right), <span class="number">0</span>)+ root.val;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://reoger.tk/2018/10/31/algorithm/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%ACk%E4%B8%AA%E7%BB%93%E7%82%B9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="reoger">
      <meta itemprop="description" content="reoger">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="reoger的记录">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/10/31/algorithm/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%ACk%E4%B8%AA%E7%BB%93%E7%82%B9/" class="post-title-link" itemprop="url">二叉搜索树的第k个结点</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-10-31 00:08:52" itemprop="dateCreated datePublished" datetime="2018-10-31T00:08:52+08:00">2018-10-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-12 23:09:20" itemprop="dateModified" datetime="2020-04-12T23:09:20+08:00">2020-04-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/" itemprop="url" rel="index"><span itemprop="name">algorithm</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="二叉搜索树中第K小的元素"><a href="#二叉搜索树中第K小的元素" class="headerlink" title="二叉搜索树中第K小的元素"></a><a href="https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/" target="_blank" rel="noopener">二叉搜索树中第K小的元素</a></h3><p>难度 <strong>中等</strong></p>
<p>给定一个二叉搜索树，编写一个函数 <code>kthSmallest</code> 来查找其中第 *<em>k *</em>个最小的元素。</p>
<p><strong>说明：</strong><br>你可以假设 k 总是有效的，1 ≤ k ≤ 二叉搜索树元素个数。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">**输入:** root &#x3D; [3,1,4,null,2], k &#x3D; 1</span><br><span class="line">   3</span><br><span class="line">  &#x2F; \</span><br><span class="line"> 1   4</span><br><span class="line">  \</span><br><span class="line">   2</span><br><span class="line">**输出:** 1</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">**输入:** root &#x3D; [5,3,6,2,4,null,null,1], k &#x3D; 3</span><br><span class="line">       5</span><br><span class="line">      &#x2F; \</span><br><span class="line">     3   6</span><br><span class="line">    &#x2F; \</span><br><span class="line">   2   4</span><br><span class="line">  &#x2F;</span><br><span class="line"> 1</span><br><span class="line">**输出:** 3</span><br></pre></td></tr></table></figure>

<p><strong>进阶：</strong><br>如果二叉搜索树经常被修改（插入/删除操作）并且你需要频繁地查找第 k 小的值，你将如何优化 <code>kthSmallest</code> 函数？</p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>二叉搜索树 已经就是一个排好序的树了，我们只要按照中序遍历到第k个数，输出第k个数的值即可。</p>
<h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><p>Language: <strong>Java</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span> (root == <span class="keyword">null</span> || k &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        count = k;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> inOrder(root);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">inOrder</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> val = inOrder(root.left);</span><br><span class="line">        <span class="keyword">if</span>(count == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> val;</span><br><span class="line">        <span class="keyword">if</span>(--count == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> root.val;</span><br><span class="line">        <span class="keyword">return</span> inOrder(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者使用方法二：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">        private int index&#x3D;0;</span><br><span class="line">        public int kthSmallest(TreeNode root, int k) &#123;</span><br><span class="line">            if(root&#x3D;&#x3D;null)</span><br><span class="line">                return Integer.MAX_VALUE;</span><br><span class="line">            int ret&#x3D;kthSmallest(root.left,k);</span><br><span class="line">            if(ret!&#x3D;Integer.MAX_VALUE)</span><br><span class="line">                return ret;</span><br><span class="line">            index++;</span><br><span class="line">            if(index&#x3D;&#x3D;k)</span><br><span class="line">            &#123;</span><br><span class="line">                return root.val;</span><br><span class="line">            &#125;</span><br><span class="line">            return  kthSmallest(root.right,k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://reoger.tk/2018/10/14/java/Class%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84--%E5%B8%B8%E9%87%8F%E6%B1%A0%EF%BC%88%E4%B8%80%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="reoger">
      <meta itemprop="description" content="reoger">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="reoger的记录">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/10/14/java/Class%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84--%E5%B8%B8%E9%87%8F%E6%B1%A0%EF%BC%88%E4%B8%80%EF%BC%89/" class="post-title-link" itemprop="url">Class文件结构--常量池（一）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-10-14 14:56:55" itemprop="dateCreated datePublished" datetime="2018-10-14T14:56:55+08:00">2018-10-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-06-06 17:33:47" itemprop="dateModified" datetime="2020-06-06T17:33:47+08:00">2020-06-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Class文件结构–常量池（一）"><a href="#Class文件结构–常量池（一）" class="headerlink" title="Class文件结构–常量池（一）"></a>Class文件结构–常量池（一）</h1><hr>
<p>转载自<a href="https://www.jianshu.com/p/d8492e748c57" target="_blank" rel="noopener">https://www.jianshu.com/p/d8492e748c57</a></p>
<ul>
<li>字节码查看工具：WinHex</li>
</ul>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul>
<li>Java虚拟机实现语言无关性的基石就是Class文件<br><img src="https://upload-images.jianshu.io/upload_images/3458176-30ce955fde8883d1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/830/format/webp" alt="Java虚拟机提供的语言无关性"></li>
<li>这篇文章讲Class格式文件的的魔数、版本号和常量池。主要内容是常量池。</li>
</ul>
<h1 id="Class类文件的结构"><a href="#Class类文件的结构" class="headerlink" title="Class类文件的结构"></a>Class类文件的结构</h1><h2 id="全局规范"><a href="#全局规范" class="headerlink" title="全局规范"></a>全局规范</h2><ul>
<li><p><strong>1.任何一个Class文件都对应着唯一一个类或接口的定义信息，但反过来说，类或接口并不一定都得定义在文件里（譬如类或接口也可以通过类加载器直接生成）。本章中，只是通俗地将任意一个有效的类或接口所应当满足的格式称为“Class文件格式”，实际上它并不一定以磁盘文件的形式存在。“Class文件”应当是一串二进制的字节流，无论以何种形式存在。</strong></p>
</li>
<li><p>2.Class文件是一组以8位字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在Class文件之中，当遇到需要占用8位字节以上空间的数据项时，则会按照<strong>高位在前（Big-Endian）</strong>的方式分割成若干个8位字节进行存储。无符号数据类型最大占8个字节。</p>
</li>
<li><p>3.Class文件中存储数据的类型：无符号数和表。</p>
</li>
<li><p><strong>无符号数（基本数据类型）</strong>：以u1、u2、u4、u8来分别代表1个字节、2个字节、4个字节和8个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串值。</p>
</li>
<li><p><strong>表（复合数据类型）</strong>：是由多个无符号数或者其他表作为数据项构成的复合数据类型，所有表都习惯性地“_info”结尾。表用于描述有层次关系的复合结构的数据。表是一个统称，就好比把ArrayList、LinkedList、Set都是称为集合(Collection)，但是每个集合的内部结构都是不同的，Class中有很多不同的表。如下图中cp_info类型,是表类型，但是它是一个固定结构的类型吗？不是，它好比Collection集合下的List集合，只是一类集合的统称，实际上cp_info表是14种具体表类型的统称，constant_pool_count-1指出了有多少个cp_info表，那到底是哪些具体的表，就需要具体看了。</p>
</li>
<li><p>4.整个Class文件本质上就是一张表，下表就是Class文件格式。Class中所有内容都在这些类型中定义了。</p>
<ul>
<li><p><strong>注：表中的数据项，无论是顺序还是数量，甚至于数据存储的字节序（Byte Ordering,Class文件中字节序为Big-Endian）这样的细节，都是被严格限定的，哪个字节代表什么含义，长度是多少，先后顺序如何，都不允许改变。</strong>  </p>
<p><img src="https:https://upload-images.jianshu.io/upload_images/3458176-8fce946bab563076.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/972/format/webp" alt=""></p>
<p>Class文件格式</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3458176-183170e077348dd9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/847/format/webp" alt=""></p>
<p>class文件结构</p>
</li>
</ul>
</li>
<li><p>5.无论是无符号数还是表，当需要描述同一类型但数量不定的多个数据时，经常会使用一个前置的容量计数器加若干个连续的数据项的形式，这时称这一系列连续的某一类型的数据为某一类型的集合。</p>
</li>
<li><p><strong>如上表的描述常量池数据使用了一个constant_pool_count、多个constant_pool,其中constant_pool是表类型并且数量为constant_pool_count值减去1，把一个constant_pool_count和多个constant_pool数据项称为常量池集合</strong></p>
</li>
<li><p>从Class文件格式中可以看出有：常量池集合、接口索引集合、字段表集合、方法表集合、属性表集合。</p>
</li>
<li><p>6.具体的Class文件案例，以下讲解会通过这个TestClass类的<code>TestClass.class</code>文件来分析。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">package com.zlcook.clazz;</span><br><span class="line"></span><br><span class="line">public class TestClass&#123;</span><br><span class="line">  private int m;</span><br><span class="line">  public int inc()&#123;</span><br><span class="line">   return m+1;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="1-魔数与Class文件的版本"><a href="#1-魔数与Class文件的版本" class="headerlink" title="1. 魔数与Class文件的版本"></a>1. 魔数与Class文件的版本</h2><ul>
<li>由上表得Class文件的前三个数据类型存储了魔数（magic)、次版本号(minor_version)、主版本号(major_version)的值，数据类型分别为u4、u2、u2。共占8个字节。</li>
<li>魔数：0xCAFEBABE （16进制），值固定，唯一作用是确定这个文件是否为一个能被虚拟机接受的Class文件。</li>
<li>Class文件版本号：次版本号组成u2+主版本号u2。共占4个字节。</li>
<li><strong>高版本的JDK能向下兼容以前的版本的Class文件，但不能运行高版本的Class文件。</strong></li>
<li>JDK1.1的版本号为45.0-45.65535（10进制），之后每个大版本发布主版本号加1，如：JDK1.2：46.0~46.65535。</li>
<li>例如：Class文件中紧接着魔数的4个字节的16进制为： ox00000034，那么它代表的十进制版本号为：次版本号为ox0000=0，主版本号为：ox0034 = 52。所以ox00000034的版本号为52.0，对应的JDK版本为JDK1.8</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/3458176-4113215a9048a30f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/284/format/webp" alt=""></p>
<p><code>TestClass.class</code>文件的前8个字节</p>
<h2 id="2-常量池"><a href="#2-常量池" class="headerlink" title="2. 常量池"></a>2. 常量池</h2><ul>
<li>先了解常量池中需要存放哪些内容，再讨论用什么类来存放这些内容。</li>
</ul>
<h3 id="2-1-常量池中存放的内容"><a href="#2-1-常量池中存放的内容" class="headerlink" title="2.1 常量池中存放的内容"></a>2.1 常量池中存放的内容</h3><ul>
<li><p>Class文件中包含常量池，那么我就需要知道常量池会包含哪些内容，接下来才是关心class格式文件用什么类型来存放这些内容。</p>
</li>
<li><p><strong>字面量（Literal）</strong></p>
</li>
<li><p>字面量比较接近于Java语言层面的常量概念，如文本字符串、声明为final的常量值等。</p>
</li>
<li><p><strong>符号引用（Symbolic References）</strong></p>
</li>
<li><p>符号引用则属于编译原理方面的概念，包括了下面三类常量：<br>类和接口的全限定名（Fully Qualified Name）<br>字段的名称和描述符（Descriptor）<br>方法的名称和描述符</p>
</li>
<li><p><strong>其它：</strong>常量池中<strong>主要</strong>内容是上面2项，说明还有其它内容，这部分内容，在下面我们看到用来描述常量池内容的14种常量项的介绍时就发现标志为15、16、18的常量项类型是用来支持动态语言调用的（jdk1.7时才加入的）。</p>
</li>
<li><p>常量池：可以理解为Class文件之中的资源仓库，它是Class文件结构中与其他项目关联最多的数据类型（后面的很多数据类型都会指向此处），也是占用Class文件空间最大的数据项目之一。</p>
</li>
</ul>
<h3 id="2-2-常量池中为什么要包含这些内容"><a href="#2-2-常量池中为什么要包含这些内容" class="headerlink" title="2.2 常量池中为什么要包含这些内容"></a>2.2 常量池中为什么要包含这些内容</h3><ul>
<li>Java代码在进行Javac编译的时候，并不像C和C++那样有“连接”这一步骤，而是在虚拟机加载Class文件的时候进行动态连接。也就是说，在Class文件中不会保存各个方法、字段的最终内存布局信息，因此这些字段、方法的符号引用不经过运行期转换的话无法得到真正的内存入口地址，也就无法直接被虚拟机使用。当虚拟机运行时，需要从常量池获得对应的符号引用，再在类创建时或运行时解析、翻译到具体的内存地址之中。关于类的创建和动态连接的内容，在虚拟机类加载过程时再进行详细讲解。</li>
</ul>
<h3 id="2-3-Class文件中如何描述常量池中内容"><a href="#2-3-Class文件中如何描述常量池中内容" class="headerlink" title="2.3 Class文件中如何描述常量池中内容"></a>2.3 Class文件中如何描述常量池中内容</h3><ul>
<li><p>知道Class文件的常量池包含的内容后，我们下面就来看看class格式文件使用了哪些类型数据来存放常量池的内容。</p>
</li>
<li><p>由Class文件格式可得紧接着主版本号的是常量池入口。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
</tr>
</thead>
<tbody><tr>
<td>u2（无符号数）</td>
<td>constant_pool_count</td>
<td>1</td>
</tr>
<tr>
<td>cp_info（表）</td>
<td>constant_pool</td>
<td>constant_pool_count-1</td>
</tr>
</tbody></table>
<ul>
<li><p>占用的字节数：2+(constant_pool_count-1)个具体表所占字节。</p>
</li>
<li><p>由上表可见，Class文件使用了一个前置的容量计数器（constant_pool_count）加若干个连续的数据项（constant_pool）的形式来描述常量池内容。我们把这一系列连续常量池数据称为常量池集合。</p>
</li>
<li><p>先给看一下TestClass.class文件全局的内容，下面就来分析其中常量池中的内容，其它内容后面的文章在分析。从图片也可以看出常量池内容占据了class文件的很大一部分，当然TestClass类中代码比较少就更显得常量池内容的多了。</p>
</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/3458176-da04f13d9345d534.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/633/format/webp" alt="TestClass.class文件的16进制内容"></p>
<h4 id="2-3-1-constant-pool-count"><a href="#2-3-1-constant-pool-count" class="headerlink" title="2.3.1 constant_pool_count"></a>2.3.1 constant_pool_count</h4><ul>
<li><p>常量池容量计数值（u2类型）：<strong>从1开始</strong>，表示常量池中有多少项常量。即constant_pool_count=1表示常量池中有0个常量项。</p>
</li>
<li><p>设计者将第0项常量空出来是有特殊考虑的，这样做的目的在于满足后面某些指向常量池的索引值的数据在特定情况下需要表达“不引用任何一个常量池项目”的含义，这种情况就可以把索引值置为0来表示。Class文件结构中只有常量池的容量计数是从1开始，对于其他集合类型，包括接口索引集合、字段表集合、方法表集合等的容量计数都与一般习惯相同，是从0开始的。</p>
</li>
<li><p>TestClass.class文件中constant_pool_count的十进制值为19，表示常量池中有18项常量，索引范围1-18。</p>
</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/3458176-1708ec53425bf43f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/385/format/webp" alt=""></p>
<p>TestClass.class文件中constant_pool_count的十进制值为19</p>
<h4 id="2-3-2-constant-pool"><a href="#2-3-2-constant-pool" class="headerlink" title="2.3.2 constant_pool"></a>2.3.2 constant_pool</h4><ul>
<li>constant_pool_count表明了后面有多少个常量项。</li>
</ul>
<h5 id="14种常量项结构"><a href="#14种常量项结构" class="headerlink" title="14种常量项结构"></a>14种常量项结构</h5><ul>
<li>常量池中每一项常量都是一个表，JDK1.7之后共有14种不同的表结构数据。一个常量池中的每个常量项都逃不脱这14种结构。根据下图每个类型的描述我们也可以知道每个类型是用来描述常量池中哪些内容（主要是字面量、符号引用）的。比如：CONSTANT_Integer_info是用来描述常量池中字面量信息的，而且只是整型字面量信息。而标志为15、16、18的常量项类型是用来支持动态语言调用的（jdk1.7时才加入的）。</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/3458176-cc110223178a4215.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/977/format/webp" alt="常量池中的14种项目类型"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/3458176-8b9bb010f69e4a93.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/701/format/webp" alt="常量池中的14种常量项的结构总表"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/3458176-878fa839b1e28cf3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/694/format/webp" alt="常量池中的14种常量项的结构总表（续）"></p>
<ul>
<li><p>这14种表（或者常量项结构）的共同点是：表开始的第一位是一个u1类型的标志位（tag），代表当前这个常量项使用的是哪种表结构，即哪种常量类型。</p>
</li>
<li><p>这14种常量项结构还有一个特点是，其中13表占用得字节固定，只有CONSTANT_Utf8_info占用字节不固定，其大小由length决定。为什么呢？因为从常量池存放的内容可知，其存放的是字面量和符号引用，最终这些内容都会是一个字符串，这些字符串的大小是在编写程序时才确定，比如你定义一个类，类名可以取长取短，所以在没编译前，无法确定大小不固定，编译后，通过utf-8编码，就可以知道其长度。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>表</th>
<th>占用字节</th>
</tr>
</thead>
<tbody><tr>
<td>CONSTANT_Class_info</td>
<td>3</td>
</tr>
<tr>
<td>CONSTANT_Integer_info</td>
<td>5</td>
</tr>
<tr>
<td>CONSTANT_Fieldref_info</td>
<td>5</td>
</tr>
<tr>
<td>CONSTANT_Methodref_info</td>
<td>5</td>
</tr>
<tr>
<td>CONSTANT_Utf8_info</td>
<td>不固定，取决于length大小</td>
</tr>
</tbody></table>
<h2 id="2-4-查找testClass-class文件的第一个常量项内容"><a href="#2-4-查找testClass-class文件的第一个常量项内容" class="headerlink" title="2.4 查找testClass.class文件的第一个常量项内容"></a>2.4 查找testClass.class文件的第一个常量项内容</h2><ul>
<li>由上面constant_pool_count得到值为19，因为从1开始计数，所以说明后面有18个常量项，由于每个常量项的表结构都不同但是第一位相同，所以读到第一位就可以确定表结构了。下面我们就来查看第一个常量项包含得内容，至于其它17个常量项内容类似，最后还会介绍java提供得一个工具命令javap来帮我们分析class文件字节码内容。</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/3458176-22b038defbeda453.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/655/format/webp" alt="第一个表的tag为10"></p>
<ul>
<li>由上图可知常量池中第一项常量标志的16进制值是0x0A=10,查表发现这个常量属于CONSTANT_Methodref_info类型，此类型表示类中方法的符号引用。查看该类型的结构如下：</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/3458176-18d7609da23c0b93.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/851/format/webp" alt="CONSTANT\_Methodref\_info类型结构"></p>
<ul>
<li>CONSTANT_Methodref_info型常量的第二个数据项为index，类型是u2，index存储的是一个索引值，从class文件中查得该值为oX0004=4，即它指向常量池中第4个常量；第三个数据项也是索引其值为0X000F=15，指向常量池种第15个常量。</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/3458176-1a800d5b071be1b3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/623/format/webp" alt=""></p>
<p>Paste_Image.png</p>
<ul>
<li>到此为止，第一个常量项是CONSTANT_Methodref_info型常量项，该类型常量项用来表示类中方法的符号引用，其内容为tag=10,index1=4,index2=15，因为其表示的是类中方法的符号引用，所以index中存放的不是一个具体得内容，而是一个索引位置，所以说其具体内容存放在另一个常量项中。下面我们就来看看其索引指向的常量项（即第4个常量项）的内容到底是什么？</li>
<li>找第4个常量项之前需要知道第4个常量项的开始位置，所以需要知道前3个常量项所占字节数。那好就看第2个常量项，由于第一个常量项共占了5个字节，则紧接着的字节就为第二个常量项的tag，如下图可得其值为0X09=9，说明第2个常量项得项目类型为CONSTANT_Fieldref_info。查表得其该类型得字节长度固定占5个字节。</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/3458176-b27b29fd146c1371.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/638/format/webp" alt=""></p>
<p>第二个常量项</p>
<ul>
<li>依次类推查的第3,4个常量项为CONSTANT_Class_info型。如下图：</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/3458176-9dedb81d1b044555.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/646/format/webp" alt="前4个常量项"></p>
<ul>
<li>下面就看第四个常量项CONSTANT_Class_info的内容0X070012。 CONSTANT_Class_info存放的是指向类或接口的符号引用。</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/3458176-31580b94471eec94.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/641/format/webp" alt="CONSTANT\_Class\_info型常量项"></p>
<p>根据CONSTANT_Class_info项常量项的结构可知其index数据项又是一个索引项，指向全限定名常量项索引，index数据项的值为0X12=18，表示指向第18个常量项，根据constant_pool_count的值为19可得，常量池中一共有18个常量项，巧了正好在最后一个，但是要知道18个常量项必须知道前17个常量项所占字节，这里就不一一找了，最后找到第18个常量项CONSTANT_Utf8_info在class文件中包含的内容如下：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3458176-942c562db653d825.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/649/format/webp" alt="第18个常量项"></p>
<ul>
<li><img src="https://upload-images.jianshu.io/upload_images/3458176-6d21f61844e69dc4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/851/format/webp" alt="CONSTANT\_Utf8\_info型表的结构"></li>
</ul>
<ul>
<li><p>根据tag等于1得第18项是CONSTANT_Utf8_info型，该类型存储UTF-8编码的字符串，在TestClass.class文件种该常量项种个数据项的内容如下：</p>
<ul>
<li>length(u2):表示UTF-8编码的字符串占用的字节数，值为0x0010=16.</li>
<li>bytes(u1):表示长度为length的UTF-8编码的字符串.</li>
<li>因为length=16，所以 length后面紧跟的长度为16个字节的连续数据是一个使用<strong>UTF-8缩略编码</strong>表示的字符串。后面紧跟的第一个字节为0x6A=106，那该编码代表的字符为j，我们发现106其实就是字符j对应的<a href="https://link.jianshu.com?t=http://baike.baidu.com/link?url=yWgaMCeHhkhUQfJByEHL7PwMq1jWtYH8sGqB063JSCSy4Si2bWfVPzVMClgYqGyhW8tpLBd6qKWYLISuGI1024oRv9HEUOV_XaIi4QeCE2GTKQHAVU8DcVtr6Gu2UFDZhImE37QR1-FVFHKkg66k3a" target="_blank" rel="noopener">ASCII码</a>。后面16个字节代表的字符就是: java/lang/Object</li>
</ul>
</li>
</ul>
<p>到此为止，我们得到了第一个常量项CONSTANT_Methodref_info的第二个数据项index指向的内容为CONSTANT_Class_info常量项，CONSTANT_Class_info常量的第二个数据项index指向CONSTANT_Utf8_info常量项，CONSTANT_Utf8_info常量项的内容为 java/lang/Object 。<br>当然CONSTANT_Methodref_info常量项还有第三个数据项index，其存放的也是一个其他常量的索引。</p>
<ul>
<li>根据上面的找法我们就可以找出常量池中包含的内容：字面量和符号引用。</li>
</ul>
<h2 id="2-5-采用javap命令分析class文件"><a href="#2-5-采用javap命令分析class文件" class="headerlink" title="2.5 采用javap命令分析class文件"></a>2.5 采用javap命令分析class文件</h2><ul>
<li><p>根据上面的找法我们就可以找出常量池中包含的内容：字面量和符号引用。java考虑到这种找法太麻烦了，所以提供了一个命令javap来帮助我们分析class文件的内容。</p>
</li>
<li><p>javap分析class文件用法：javap -verbose class文件名</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">$ javap -verbose TestClass.class</span><br><span class="line">Classfile &#x2F;E:&#x2F;studytry&#x2F;com&#x2F;zlcook&#x2F;clazz&#x2F;TestClass.class</span><br><span class="line">  Last modified 2017-4-7; size 292 bytes</span><br><span class="line">  MD5 checksum 486567c6d4d7432fc359230fed9c92c7</span><br><span class="line">  Compiled from &quot;TestClass.java&quot;</span><br><span class="line">public class com.zlcook.clazz.TestClass</span><br><span class="line">  SourceFile: &quot;TestClass.java&quot;</span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: 52</span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #1 &#x3D; Methodref          #4.#15         &#x2F;&#x2F;  java&#x2F;lang&#x2F;Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #2 &#x3D; Fieldref           #3.#16         &#x2F;&#x2F;  com&#x2F;zlcook&#x2F;clazz&#x2F;TestClass.m:I</span><br><span class="line">   #3 &#x3D; Class              #17            &#x2F;&#x2F;  com&#x2F;zlcook&#x2F;clazz&#x2F;TestClass</span><br><span class="line">   #4 &#x3D; Class              #18            &#x2F;&#x2F;  java&#x2F;lang&#x2F;Object</span><br><span class="line">   #5 &#x3D; Utf8               m</span><br><span class="line">   #6 &#x3D; Utf8               I</span><br><span class="line">   #7 &#x3D; Utf8               &lt;init&gt;</span><br><span class="line">   #8 &#x3D; Utf8               ()V</span><br><span class="line">   #9 &#x3D; Utf8               Code</span><br><span class="line">  #10 &#x3D; Utf8               LineNumberTable</span><br><span class="line">  #11 &#x3D; Utf8               inc</span><br><span class="line">  #12 &#x3D; Utf8               ()I</span><br><span class="line">  #13 &#x3D; Utf8               SourceFile</span><br><span class="line">  #14 &#x3D; Utf8               TestClass.java</span><br><span class="line">  #15 &#x3D; NameAndType        #7:#8          &#x2F;&#x2F;  &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #16 &#x3D; NameAndType        #5:#6          &#x2F;&#x2F;  m:I</span><br><span class="line">  #17 &#x3D; Utf8               com&#x2F;zlcook&#x2F;clazz&#x2F;TestClass</span><br><span class="line">  #18 &#x3D; Utf8               java&#x2F;lang&#x2F;Object</span><br><span class="line">&#123;</span><br><span class="line">  public com.zlcook.clazz.TestClass();</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack&#x3D;1, locals&#x3D;1, args_size&#x3D;1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: invokespecial #1                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         4: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 2: 0</span><br><span class="line"></span><br><span class="line">  public int inc();</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack&#x3D;2, locals&#x3D;1, args_size&#x3D;1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: getfield      #2                  &#x2F;&#x2F; Field m:I</span><br><span class="line">         4: iconst_1</span><br><span class="line">         5: iadd</span><br><span class="line">         6: ireturn</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 6: 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>上面通过javap命令得到的结果，该结果显示的很友好，由过上面的理论我们可以很清楚的看到常量池一共18项：其中第一项如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#1 &#x3D; Methodref          #4.#15       &#x2F;&#x2F;  java&#x2F;lang&#x2F;Object.&quot;&lt;init&gt;&quot;:()V</span><br></pre></td></tr></table></figure>
</li>
<li><p>和我们通过手动方式查看第一个常量项CONSTANT_Methodref_info对比一下就知道javap显示的内容是多么友好了。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>第一个常量项</th>
<th>第几个</th>
<th>tag</th>
<th>index</th>
<th>index</th>
<th>最终代表的内容</th>
</tr>
</thead>
<tbody><tr>
<td>class中16进制值</td>
<td>0X0A</td>
<td>0X004</td>
<td>0X000F</td>
<td></td>
<td></td>
</tr>
<tr>
<td>转换成10进制值</td>
<td>10</td>
<td>4</td>
<td>15</td>
<td>查完4和15才知道</td>
<td></td>
</tr>
<tr>
<td>javap分析显示的友好值</td>
<td>#1</td>
<td>Methodref</td>
<td>#4</td>
<td>#15</td>
<td>java/lang/Object.”&lt;init&gt;”:()V</td>
</tr>
</tbody></table>
<h2 id="2-6-class文件中包含的内容"><a href="#2-6-class文件中包含的内容" class="headerlink" title="2.6 class文件中包含的内容"></a>2.6 class文件中包含的内容</h2><ul>
<li><p>下面我们来看一下class文件中常量池的内容和java源码中的内容。</p>
</li>
<li><p>TestClass.java代码内容</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">package com.zlcook.clazz;</span><br><span class="line"></span><br><span class="line">public class TestClass&#123;</span><br><span class="line">  private int m;</span><br><span class="line">  public int inc()&#123;</span><br><span class="line">   return m+1;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>TestClass.class中常量池内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Constant pool:</span><br><span class="line">   #1 &#x3D; Methodref          #4.#15         &#x2F;&#x2F;  java&#x2F;lang&#x2F;Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #2 &#x3D; Fieldref           #3.#16         &#x2F;&#x2F;  com&#x2F;zlcook&#x2F;clazz&#x2F;TestClass.m:I</span><br><span class="line">   #3 &#x3D; Class              #17            &#x2F;&#x2F;  com&#x2F;zlcook&#x2F;clazz&#x2F;TestClass</span><br><span class="line">   #4 &#x3D; Class              #18            &#x2F;&#x2F;  java&#x2F;lang&#x2F;Object</span><br><span class="line">   #5 &#x3D; Utf8               m</span><br><span class="line">   #6 &#x3D; Utf8               I</span><br><span class="line">   #7 &#x3D; Utf8               &lt;init&gt;</span><br><span class="line">   #8 &#x3D; Utf8               ()V</span><br><span class="line">   #9 &#x3D; Utf8               Code</span><br><span class="line">  #10 &#x3D; Utf8               LineNumberTable</span><br><span class="line">  #11 &#x3D; Utf8               inc</span><br><span class="line">  #12 &#x3D; Utf8               ()I</span><br><span class="line">  #13 &#x3D; Utf8               SourceFile</span><br><span class="line">  #14 &#x3D; Utf8               TestClass.java</span><br><span class="line">  #15 &#x3D; NameAndType        #7:#8          &#x2F;&#x2F;  &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #16 &#x3D; NameAndType        #5:#6          &#x2F;&#x2F;  m:I</span><br><span class="line">  #17 &#x3D; Utf8               com&#x2F;zlcook&#x2F;clazz&#x2F;TestClass</span><br><span class="line">  #18 &#x3D; Utf8               java&#x2F;lang&#x2F;Object</span><br></pre></td></tr></table></figure>
</li>
<li><p>再复习一下常量池中主要存放字面量：如文本字符串、声明为final的常量值等。和符号引用：类和接口的全限定名、字段的名称和描述符、方法的名称和描述符。</p>
</li>
<li><p>所以出现com/zlcook/clazz/TestClass、java/lang/Object、m、inc都是应该的，那么I、V、<init>、LineNumberTable都是什么？那肯定是字段描述符或者是方法描述符了。这部分是编译时自动生成的，它们会被class文件中其它部分（字段表field_info、方法表method_info、属性表attribute_info）引用到，它们会用来描述一些不方便使用“固定字节”进行表达的内容。譬如描述方法的返回值是什么？有几个参数？每个参数的类型是什么？因为Java中的“类”是无穷无尽的，无法通过简单的无符号字节来描述一个方法用到了什么类，因此在描述方法的这些信息时，需要引用常量表中的符号引用进行表达。</p>
</li>
</ul>
<h2 id="3-哪些字面量会进入常量池中"><a href="#3-哪些字面量会进入常量池中" class="headerlink" title="3. 哪些字面量会进入常量池中"></a>3. 哪些字面量会进入常量池中</h2><ul>
<li>我们知道class文件存放字面量：如文本字符串、声明为final的常量值等。这里的“等”就挺烦人。</li>
<li>下面我们来看看哪些字面量会进入常量池。（jdk1.8.0环境）</li>
</ul>
<p><strong>8种基本类型：</strong></p>
<p>测试案例：</p>
<ul>
<li>final类型 FinalTest.java代码</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class FinalTest&#123;</span><br><span class="line"></span><br><span class="line">   private final int int_num &#x3D;12;</span><br><span class="line">   private final char char_num &#x3D; &#39;a&#39;;</span><br><span class="line">   private final short short_num &#x3D;30;</span><br><span class="line">   private final float float_num &#x3D; 45.3f;</span><br><span class="line">   private final double double_num &#x3D;39.8;</span><br><span class="line">   private final byte byte_num &#x3D;121;</span><br><span class="line">   private final long long_num &#x3D; 2323L;</span><br><span class="line">   private final boolean boolean_flage &#x3D; true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>非final类型 test.java代码<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class test&#123;</span><br><span class="line"></span><br><span class="line">   private int int_num &#x3D;12;</span><br><span class="line">   private char char_num &#x3D; &#39;a&#39;;</span><br><span class="line">   private short short_num &#x3D;30;</span><br><span class="line">   private float float_num &#x3D; 45.3f;</span><br><span class="line">   private double double_num &#x3D;39.8;</span><br><span class="line">   private byte byte_num &#x3D;121;</span><br><span class="line">   private long long_num &#x3D; 2323L;</span><br><span class="line">   private long long_delay_num ;</span><br><span class="line">   private boolean boolean_flage &#x3D; true;</span><br><span class="line"></span><br><span class="line">   public void init()&#123;</span><br><span class="line">     this.long_delay_num &#x3D; 5555L;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>上面代码测试结果：</p>
<ul>
<li>final类型的8种基本类型的值会进入常量池。</li>
<li>非final类型的8种基本类型的值double、float、long的值会进入常量池，包括long_delay_num的值。</li>
</ul>
<p><strong>String类型</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">*   StringTest.java代码：</span><br><span class="line"></span><br><span class="line">    public class StringTest&#123;</span><br><span class="line">    </span><br><span class="line">          private String str1 &#x3D; &quot;zl&quot;+&quot;cook&quot;;</span><br><span class="line">          private String str2 &#x3D; str1+&quot;hello&quot;;</span><br><span class="line">          private String str3 &#x3D; new String(&quot;zlcook here?&quot;);</span><br><span class="line">          private String str4 &#x3D; &quot;everybody &quot;+ new String(&quot;here?&quot;);</span><br><span class="line">    </span><br><span class="line">          private final String fin1 &#x3D; &quot;boy&quot;;</span><br><span class="line">          private final String fin2 &#x3D; fin1+ &quot;is boy&quot;;</span><br><span class="line">          private final String fin3 &#x3D; str1+ &quot;is boy&quot;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>StringTest.class的常量池种包含内容：</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/3458176-adab40db73749fe0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/709/format/webp" alt="常量池中包含的字符串类型字面量"></p>
<p>所有测试数据github： <a href="https://link.jianshu.com?t=https://github.com/zlcook/JVM/tree/master/constant" target="_blank" rel="noopener">测试数据</a></p>
<h1 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h1><ul>
<li>这一节主要讲了Class文件魔数、版本号和常量池，比较详细介绍了常量池包含的内容以及用到的14种常量项结构。记住本节讲的常量池是class文件中的常量池，要记住还有运行时常量池，每个class文件中的常量池内容在类加载侯会进入方法区的运行时常量池中存放。当然运行时常量池的内容不仅包含这些还包含运行期加入的常量，常见的就是String类的intern()方法。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://reoger.tk/2018/10/13/system/%E4%BF%AE%E6%94%B9ubuntu%E4%B8%8B%E7%9A%84dns/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="reoger">
      <meta itemprop="description" content="reoger">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="reoger的记录">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/10/13/system/%E4%BF%AE%E6%94%B9ubuntu%E4%B8%8B%E7%9A%84dns/" class="post-title-link" itemprop="url">修改ubuntu下的dns</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-10-13 19:08:55" itemprop="dateCreated datePublished" datetime="2018-10-13T19:08:55+08:00">2018-10-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-12 23:10:40" itemprop="dateModified" datetime="2020-04-12T23:10:40+08:00">2020-04-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%9D%82%E7%83%A9/" itemprop="url" rel="index"><span itemprop="name">杂烩</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="修改ubuntu下的dns"><a href="#修改ubuntu下的dns" class="headerlink" title="修改ubuntu下的dns"></a>修改ubuntu下的dns</h1><p>适用环境：oracle vm 虚拟机下的ununtu-14.04.5版本。</p>
<h2 id="验证有效的方法：https-blog-csdn-net-u014453443-article-details-80878061"><a href="#验证有效的方法：https-blog-csdn-net-u014453443-article-details-80878061" class="headerlink" title="验证有效的方法：https://blog.csdn.net/u014453443/article/details/80878061"></a>验证有效的方法：<a href="https://blog.csdn.net/u014453443/article/details/80878061" target="_blank" rel="noopener">https://blog.csdn.net/u014453443/article/details/80878061</a></h2><p>基本步骤：</p>
<ol>
<li><p>查看当前dns配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat &#x2F;etc&#x2F;resolv.conf</span><br></pre></td></tr></table></figure></li>
<li><p>添加dns配置,在interfaces文件下添加需要的dns配置，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vi &#x2F;etc&#x2F;network&#x2F;interfaces</span><br></pre></td></tr></table></figure>
<p>参考的dns配置地址：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dns-nameservers 8.8.8.8 </span><br><span class="line">dns-nameservers 8.8.4.4</span><br></pre></td></tr></table></figure>
<p>参考配置如下：<br><img src="https://upload-images.jianshu.io/upload_images/2178834-3b11eca15608f683.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
</li>
<li><p>重启，后验证dns</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat &#x2F;etc&#x2F;resolv.conf</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p><img src="https://upload-images.jianshu.io/upload_images/2178834-41be0ea18ebb5d5d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>dns修改成功！ </p>
<h2 id="可能有效的方法-https-blog-csdn-net-qq-27818541-article-details-75730125"><a href="#可能有效的方法-https-blog-csdn-net-qq-27818541-article-details-75730125" class="headerlink" title="可能有效的方法 https://blog.csdn.net/qq_27818541/article/details/75730125"></a>可能有效的方法 <a href="https://blog.csdn.net/qq_27818541/article/details/75730125" target="_blank" rel="noopener">https://blog.csdn.net/qq_27818541/article/details/75730125</a></h2><h2 id="验证无效，但是其他版本可能有效的方法-https-blog-csdn-net-zd147896325-article-details-81078414"><a href="#验证无效，但是其他版本可能有效的方法-https-blog-csdn-net-zd147896325-article-details-81078414" class="headerlink" title="验证无效，但是其他版本可能有效的方法 https://blog.csdn.net/zd147896325/article/details/81078414"></a>验证无效，但是其他版本可能有效的方法 <a href="https://blog.csdn.net/zd147896325/article/details/81078414" target="_blank" rel="noopener">https://blog.csdn.net/zd147896325/article/details/81078414</a></h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://reoger.tk/2018/08/31/algorithm/Android%20%E6%8F%92%E4%BB%B6%E5%8C%96%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90%E2%80%94%E2%80%94%E6%8F%92%E4%BB%B6%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="reoger">
      <meta itemprop="description" content="reoger">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="reoger的记录">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/08/31/algorithm/Android%20%E6%8F%92%E4%BB%B6%E5%8C%96%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90%E2%80%94%E2%80%94%E6%8F%92%E4%BB%B6%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/" class="post-title-link" itemprop="url">Android 插件化原理解析——插件加载机制</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-08-31 11:13:55" itemprop="dateCreated datePublished" datetime="2018-08-31T11:13:55+08:00">2018-08-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-12 22:54:20" itemprop="dateModified" datetime="2020-04-12T22:54:20+08:00">2020-04-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%BD%AC%E8%BD%BD/" itemprop="url" rel="index"><span itemprop="name">转载</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Android-插件化原理解析——插件加载机制"><a href="#Android-插件化原理解析——插件加载机制" class="headerlink" title="Android 插件化原理解析——插件加载机制"></a>Android 插件化原理解析——插件加载机制</h1><p>本文转载自<a href="http://weishu.me/2016/04/05/understand-plugin-framework-classloader/" target="_blank" rel="noopener">http://weishu.me/2016/04/05/understand-plugin-framework-classloader/</a>。</p>
<p>上文 <a href="http://weishu.me/2016/03/21/understand-plugin-framework-activity-management/" target="_blank" rel="noopener">Activity生命周期管理</a> 中我们地完成了『启动没有在AndroidManifest.xml中显式声明的Activity』的任务；通过Hook <code>AMS</code>和拦截ActivityThread中<code>H</code>类对于组件调度我们成功地绕过了AndroidMAnifest.xml的限制。</p>
<p>但是我们启动的『没有在AndroidManifet.xml中显式声明』的Activity和宿主程序存在于同一个Apk中；通常情况下，插件均以独立的文件存在甚至通过网络获取，这时候插件中的Activity能否成功启动呢？</p>
<p>要启动Activity组件肯定先要创建对应的Activity类的对象，从上文 <a href="http://weishu.me/2016/03/21/understand-plugin-framework-activity-management/" target="_blank" rel="noopener">Activity生命周期管理</a> 知道，创建Activity类对象的过程如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">java.lang.ClassLoader cl &#x3D; r.packageInfo.getClassLoader();  </span><br><span class="line">activity &#x3D; mInstrumentation.newActivity(  </span><br><span class="line"> cl, component.getClassName(), r.intent);  </span><br><span class="line">StrictMode.incrementExpectedActivityCount(activity.getClass());  </span><br><span class="line">r.intent.setExtrasClassLoader(cl);</span><br></pre></td></tr></table></figure>
<p>也就是说，系统通过<code>ClassLoader</code>加载了需要的Activity类并通过反射调用构造函数创建出了Activity对象。如果Activity组件存在于独立于宿主程序的文件之中，系统的ClassLoader怎么知道去哪里加载呢？因此，如果不做额外的处理，插件中的Activity对象甚至都没有办法创建出来，谈何启动？</p>
<p>因此，要使存在于独立文件或者网络中的插件被成功启动，首先就需要解决这个<strong>插件类加载</strong>的问题。<br>下文将围绕此问题展开，完成『启动没有在AndroidManifest.xml中显示声明，并且存在于外部插件中的Activity』的任务。</p>
<p>阅读本文之前，可以先clone一份 <a href="https://github.com/tiann/understand-plugin-framework" target="_blank" rel="noopener">understand-plugin-framework</a>，参考此项目的<code>classloader-hook</code> 模块。另外，插件框架原理解析系列文章见<a href="http://weishu.me/2016/01/28/understand-plugin-framework-overview/" target="_blank" rel="noopener">索引</a>。</p>
<h2 id="ClassLoader机制"><a href="#ClassLoader机制" class="headerlink" title="ClassLoader机制"></a>ClassLoader机制</h2><p>或许有的童鞋还不太了解Java的ClassLoader机制，我这里简要介绍一下。</p>
<blockquote>
<p>Java虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校检、转换解析和初始化的，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。<br>与那些在编译时进行链连接工作的语言不同，在Java语言里面，类型的加载、连接和初始化都是在程序运行期间完成的，这种策略虽然会令类加载时稍微增加一些性能开销，但是会为Java应用程序提供高度的灵活性，Java里天生可以同代拓展的语言特性就是依赖运行期动态加载和动态链接这个特点实现的。例如，如果编写一个面相接口的应用程序，可以等到运行时在制定实际的实现类；用户可以通过Java与定义的和自定义的类加载器，让一个本地的应用程序可以在运行时从网络或其他地方加载一个二进制流作为代码的一部分，这种组装应用程序的方式目前已经广泛应用于Java程序之中。从最基础的Applet，JSP到复杂的OSGi技术，都使用了Java语言运行期类加载的特性。</p>
</blockquote>
<p>Java的类加载是一个相对复杂的过程；它包括加载、验证、准备、解析和初始化五个阶段；对于开发者来说，可控性最强的是<strong>加载阶段</strong>；加载阶段主要完成三件事：</p>
<ol>
<li>根据一个类的全限定名来获取定义此类的二进制字节流</li>
<li>将这个字节流所代表的静态存储结构转化为JVM方法区中的运行时数据结构</li>
<li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。</li>
</ol>
<p>『通过一个类的全限定名获取描述此类的二进制字节流』这个过程被抽象出来，就是Java的类加载器模块，也即JDK中ClassLoader API。</p>
<p>Android Framework提供了DexClassLoader这个类，简化了『通过一个类的全限定名获取描述次类的二进制字节流』这个过程；我们只需要告诉DexClassLoader一个dex文件或者apk文件的路径就能完成类的加载。因此本文的内容用一句话就可以概括：</p>
<p><strong>将插件的dex或者apk文件告诉『合适的』DexClassLoader，借助它完成插件类的加载</strong></p>
<p>关于CLassLoader机制更多的内容，请参阅『深入理解Java虚拟机』这本书。</p>
<h2 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h2><p>Android系统使用了ClassLoader机制来进行Activity等组件的加载；apk被安装之后，APK文件的代码以及资源会被系统存放在固定的目录（比如/data/app/package_name/base-1.apk )系统在进行类加载的时候，会自动去这一个或者几个特定的路径来寻找这个类；但是系统并不知道存在于插件中的Activity组件的信息(插件可以是任意位置，甚至是网络，系统无法提前预知)，因此正常情况下系统无法加载我们插件中的类；因此也没有办法创建Activity的对象，更不用谈启动组件了。</p>
<p>解决这个问题有两个思路，要么全盘接管这个类加载的过程；要么告知系统我们使用的插件存在于哪里，让系统帮忙加载；这两种方式或多或少都需要<strong>干预</strong>这个类加载的过程。老规矩，知己知彼，百战不殆。我们首先分析一下，系统是如果完成这个类加载过程的。</p>
<p>我们再次搬出Activity的创建过程的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">java.lang.ClassLoader cl &#x3D; r.packageInfo.getClassLoader();  </span><br><span class="line">activity &#x3D; mInstrumentation.newActivity(cl, component.getClassName(), r.intent);  </span><br><span class="line">StrictMode.incrementExpectedActivityCount(activity.getClass());  </span><br><span class="line">r.intent.setExtrasClassLoader(cl);</span><br></pre></td></tr></table></figure>
<p>这里可以很明显地看到，系统通过待启动的Activity的类名<code>className</code>，然后使用ClassLoader对象<code>cl</code>把这个类加载进虚拟机，最后使用反射创建了这个Activity类的实例对象。要想干预这个ClassLoader（告知它我们的路径或者替换他），我们首先得看看这玩意到底是个什么来头。（从哪里创建的）</p>
<p><code>cl</code>这个ClasssLoader对象通过<code>r.packageInfo</code>对象的getClassLoader()方法得到，r.packageInfo是一个LoadedApk类的对象；那么，LoadedApk到底是个什么东西？？</p>
<p>我们查阅LoadedApk类的文档，只有一句话，不过说的很明白：</p>
<blockquote>
<p>Local state maintained about a currently loaded .apk.</p>
</blockquote>
<p><strong>LoadedApk对象是APK文件在内存中的表示。</strong> Apk文件的相关信息，诸如Apk文件的代码和资源，甚至代码里面的Activity，Service等组件的信息我们都可以通过此对象获取。</p>
<p>OK, 我们知道这个LoadedApk是何方神圣了；接下来我们要搞清楚的是：这个 <code>r.packageInfo</code> 到底是从哪里获取的？</p>
<p>我们顺着 performLaunchActivity上溯，辗转handleLaunchActivity回到了 <code>H</code> 类的LAUNCH_ACTIVITY消息，找到了<code>r.packageInfo</code>的来源：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">final ActivityClientRecord r &#x3D; (ActivityClientRecord) msg.obj;  </span><br><span class="line">r.packageInfo &#x3D; getPackageInfoNoCheck(  </span><br><span class="line"> r.activityInfo.applicationInfo, r.compatInfo);  </span><br><span class="line">handleLaunchActivity(r, null);</span><br></pre></td></tr></table></figure>
<p>getPackageInfoNoCheck方法很简单，直接调用了getPackageInfo方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public final LoadedApk getPackageInfoNoCheck(ApplicationInfo ai,  </span><br><span class="line"> CompatibilityInfo compatInfo) &#123;  </span><br><span class="line"> return getPackageInfo(ai, compatInfo, null, false, true, false);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个getPackageInfo方法里面我们发现了端倪：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">private LoadedApk getPackageInfo(ApplicationInfo aInfo, CompatibilityInfo compatInfo,  </span><br><span class="line"> ClassLoader baseLoader, boolean securityViolation, boolean includeCode,  </span><br><span class="line"> boolean registerPackage) &#123;  </span><br><span class="line"> &#x2F;&#x2F; 获取userid信息  </span><br><span class="line"> final boolean differentUser &#x3D; (UserHandle.myUserId() !&#x3D; UserHandle.getUserId(aInfo.uid));  </span><br><span class="line"> synchronized (mResourcesManager) &#123;  </span><br><span class="line"> &#x2F;&#x2F; 尝试获取缓存信息  </span><br><span class="line"> WeakReference&lt;LoadedApk&gt; ref;  </span><br><span class="line"> if (differentUser) &#123;  </span><br><span class="line"> &#x2F;&#x2F; Caching not supported across users  </span><br><span class="line"> ref &#x3D; null;  </span><br><span class="line"> &#125; else if (includeCode) &#123;  </span><br><span class="line"> ref &#x3D; mPackages.get(aInfo.packageName);  </span><br><span class="line"> &#125; else &#123;  </span><br><span class="line"> ref &#x3D; mResourcePackages.get(aInfo.packageName);  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line"> LoadedApk packageInfo &#x3D; ref !&#x3D; null ? ref.get() : null;  </span><br><span class="line"> if (packageInfo &#x3D;&#x3D; null || (packageInfo.mResources !&#x3D; null  </span><br><span class="line"> &amp;&amp; !packageInfo.mResources.getAssets().isUpToDate())) &#123;  </span><br><span class="line"> &#x2F;&#x2F; 缓存没有命中，直接new  </span><br><span class="line"> packageInfo &#x3D;  </span><br><span class="line"> new LoadedApk(this, aInfo, compatInfo, baseLoader,  </span><br><span class="line"> securityViolation, includeCode &amp;&amp;  </span><br><span class="line"> (aInfo.flags&amp;ApplicationInfo.FLAG\_HAS\_CODE) !&#x3D; 0, registerPackage);  </span><br><span class="line">  </span><br><span class="line"> &#x2F;&#x2F; 省略。。更新缓存  </span><br><span class="line"> return packageInfo;  </span><br><span class="line"> &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法很重要，我们必须弄清楚每一步；</p>
<p>首先，它判断了调用方和或许App信息的一方是不是同一个userId；如果是同一个user，那么可以共享缓存数据（要么缓存的代码数据，要么缓存的资源数据）</p>
<p>接下来尝试获取缓存数据；如果没有命中缓存数据，才通过LoadedApk的构造函数创建了LoadedApk对象；创建成功之后，如果是同一个uid还放入了缓存。</p>
<p>提到缓存数据，看过<a href="http://weishu.me/2016/02/16/understand-plugin-framework-binder-hook/" target="_blank" rel="noopener">Hook机制之Binder Hook</a>的童鞋可能就知道了，我们之前成功借助ServiceManager的本地代理使用缓存的机制Hook了各种Binder；因此这里完全可以如法炮制——我们拿到这一份缓存数据，修改里面的ClassLoader；自己控制类加载的过程，这样加载插件中的Activity类的问题就解决了。这就引出了我们加载插件类的第一种方案：</p>
<h2 id="激进方案：Hook掉ClassLoader，自己操刀"><a href="#激进方案：Hook掉ClassLoader，自己操刀" class="headerlink" title="激进方案：Hook掉ClassLoader，自己操刀"></a>激进方案：Hook掉ClassLoader，自己操刀</h2><p>从上述分析中我们得知，在获取LoadedApk的过程中使用了一份缓存数据；这个缓存数据是一个<code>Map</code>，从包名到LoadedApk的一个映射。正常情况下，我们的插件肯定不会存在于这个对象里面；但是<strong>如果我们手动把我们插件的信息添加到里面呢？</strong>系统在查找缓存的过程中，会直接命中缓存！进而使用我们添加进去的LoadedApk的ClassLoader来加载这个特定的Activity类！这样我们就能接管我们自己插件类的加载过程了！</p>
<p>这个缓存对象<code>mPackages</code>存在于ActivityThread类中；老方法，我们首先获取这个对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 先获取到当前的ActivityThread对象  </span><br><span class="line">Class&lt;?&gt; activityThreadClass &#x3D; Class.forName(&quot;android.app.ActivityThread&quot;);  </span><br><span class="line">Method currentActivityThreadMethod &#x3D; activityThreadClass.getDeclaredMethod(&quot;currentActivityThread&quot;);  </span><br><span class="line">currentActivityThreadMethod.setAccessible(true);  </span><br><span class="line">Object currentActivityThread &#x3D; currentActivityThreadMethod.invoke(null);  </span><br><span class="line">  </span><br><span class="line">&#x2F;&#x2F; 获取到 mPackages 这个静态成员变量, 这里缓存了dex包的信息  </span><br><span class="line">Field mPackagesField &#x3D; activityThreadClass.getDeclaredField(&quot;mPackages&quot;);  </span><br><span class="line">mPackagesField.setAccessible(true);  </span><br><span class="line">Map mPackages &#x3D; (Map) mPackagesField.get(currentActivityThread);</span><br></pre></td></tr></table></figure>
<p>拿到这个Map之后接下来怎么办呢？<strong>我们需要填充这个map，把插件的信息塞进这个map里面</strong>，以便系统在查找的时候能命中缓存。但是这个填充这个Map我们出了需要包名之外，还需要一个LoadedApk对象；如何创建一个LoadedApk对象呢？</p>
<p>我们当然可以直接反射调用它的构造函数直接创建出需要的对象，但是万一哪里有疏漏，构造参数填错了怎么办？又或者Android的不同版本使用了不同的参数，导致我们创建出来的对象与系统创建出的对象不一致，无法work怎么办？</p>
<p>因此我们需要使用与系统完全相同的方式创建LoadedApk对象；从上文分析得知，系统创建LoadedApk对象是通过<code>getPackageInfo</code>来完成的，因此我们可以调用这个函数来创建LoadedApk对象；但是这个函数是<code>private</code>的，我们无法使用。</p>
<p>有的童鞋可能会有疑问了，<code>private</code>不是也能反射到吗？我们确实能够调用这个函数，但是<code>private</code>表明这个函数是内部实现，或许那一天Google高兴，把这个函数改个名字我们就直接GG了；但是public函数不同，public被导出的函数你无法保证是否有别人调用它，因此大部分情况下不会修改；我们最好调用public函数来保证尽可能少的遇到兼容性问题。（当然，如果实在木有路可以考虑调用私有方法，自己处理兼容性问题，这个我们以后也会遇到）</p>
<p>间接调用<code>getPackageInfo</code>这个私有函数的public函数有同名的getPackageInfo系列和getPackageInfoNoCheck；简单查看源代码发现，getPackageInfo除了获取包的信息，还检查了包的一些组件；为了绕过这些验证，我们选择使用<code>getPackageInfoNoCheck</code>获取LoadedApk信息。</p>
<h3 id="构建插件LoadedApk对象"><a href="#构建插件LoadedApk对象" class="headerlink" title="构建插件LoadedApk对象"></a>构建插件LoadedApk对象</h3><p>我们这一步的目的很明确，通过getPackageInfoNoCheck函数创建出我们需要的LoadedApk对象，以供接下来使用。</p>
<p>这个函数的签名如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public final LoadedApk getPackageInfoNoCheck(ApplicationInfo ai,  </span><br><span class="line"> CompatibilityInfo compatInfo) &#123;</span><br></pre></td></tr></table></figure>
<p>因此，为了调用这个函数，我们需要构造两个参数。其一是ApplicationInfo，其二是CompatibilityInfo；第二个参数顾名思义，代表这个App的兼容性信息，比如targetSDK版本等等，这里我们只需要提取出app的信息，因此直接使用默认的兼容性即可；在CompatibilityInfo类里面有一个公有字段DEFAULT_COMPATIBILITY_INFO代表默认兼容性信息；因此，我们的首要目标是获取这个ApplicationInfo信息。</p>
<h3 id="构建插件ApplicationInfo信息"><a href="#构建插件ApplicationInfo信息" class="headerlink" title="构建插件ApplicationInfo信息"></a>构建插件ApplicationInfo信息</h3><p>我们首先看看ApplicationInfo代表什么，这个类的文档说的很清楚：</p>
<blockquote>
<p>Information you can retrieve about a particular application. This corresponds to information collected from the AndroidManifest.xml’s <application> tag.</p>
</blockquote>
<p>也就是说，这个类就是AndroidManifest.xml里面的 这个标签下面的信息；这个AndroidManifest.xml无疑是一个标准的xml文件，因此我们完全可以自己使用parse来解析这个信息。</p>
<p>那么，系统是如何获取这个信息的呢？其实Framework就有一个这样的parser，也即PackageParser；理论上，我们也可以借用系统的parser来解析AndroidMAnifest.xml从而得到ApplicationInfo的信息。但遗憾的是，<strong>这个类的兼容性很差</strong>；Google几乎在每一个Android版本都对这个类动刀子，如果坚持使用系统的解析方式，必须写一系列兼容行代码！！DroidPlugin就选择了这种方式，相关类如下：</p>
<p><a href="http://7xp3xc.com1.z0.glb.clouddn.com/201601/1459829051777.png" target="_blank" rel="noopener" title="DroidPlugin的PackageParser"><img src="http://7xp3xc.com1.z0.glb.clouddn.com/201601/1459829051777.png" alt="DroidPlugin的PackageParser"></a></p>
<p><a href="http://7xp3xc.com1.z0.glb.clouddn.com/201601/1459829051777.png" target="_blank" rel="noopener" title="DroidPlugin的PackageParser">DroidPlugin的PackageParser</a></p>
<p>看到这里我就问你怕不怕！！！这也是我们之前提到的<strong>私有或者隐藏的API可以使用，但必须处理好兼容性问题</strong>；如果Android 7.0发布，这里估计得添加一个新的类PackageParseApi24。</p>
<p>我这里使用API 23作为演示，<strong>版本不同的可能无法运行</strong>请自行查阅 DroidPlugin 不同版本如何处理。</p>
<p>OK回到正题，我们决定使用PackageParser类来提取ApplicationInfo信息。下图是API 23上，PackageParser的部分类结构图：</p>
<p><a href="http://7xp3xc.com1.z0.glb.clouddn.com/201601/1459829674687.png" target="_blank" rel="noopener"><img src="http://7xp3xc.com1.z0.glb.clouddn.com/201601/1459829674687.png" alt=""></a></p>
<p>看起来有我们需要的方法 generateApplication；确实如此，依靠这个方法我们可以成功地拿到ApplicationInfo。<br>由于PackageParser是@hide的，因此我们需要通过反射进行调用。我们根据这个generateApplicationInfo方法的签名：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public static ApplicationInfo generateApplicationInfo(Package p, int flags,  </span><br><span class="line"> PackageUserState state)</span><br></pre></td></tr></table></figure>
<p>可以写出调用generateApplicationInfo的反射代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; packageParserClass &#x3D; Class.forName(&quot;android.content.pm.PackageParser&quot;);  </span><br><span class="line">&#x2F;&#x2F; 首先拿到我们得终极目标: generateApplicationInfo方法  </span><br><span class="line">&#x2F;&#x2F; API 23 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  </span><br><span class="line">&#x2F;&#x2F; public static ApplicationInfo generateApplicationInfo(Package p, int flags,  </span><br><span class="line">&#x2F;&#x2F;    PackageUserState state) &#123;  </span><br><span class="line">&#x2F;&#x2F; 其他Android版本不保证也是如此.  </span><br><span class="line">Class&lt;?&gt; packageParser$PackageClass &#x3D; Class.forName(&quot;android.content.pm.PackageParser$Package&quot;);  </span><br><span class="line">Class&lt;?&gt; packageUserStateClass &#x3D; Class.forName(&quot;android.content.pm.PackageUserState&quot;);  </span><br><span class="line">Method generateApplicationInfoMethod &#x3D; packageParserClass.getDeclaredMethod(&quot;generateApplicationInfo&quot;,  </span><br><span class="line"> packageParser$PackageClass,  </span><br><span class="line"> int.class,  </span><br><span class="line"> packageUserStateClass);</span><br></pre></td></tr></table></figure>
<p>要成功调用这个方法，还需要三个参数；因此接下来我们需要一步一步构建调用此函数的参数信息。</p>
<h4 id="构建PackageParser-Package"><a href="#构建PackageParser-Package" class="headerlink" title="构建PackageParser.Package"></a>构建PackageParser.Package</h4><p>generateApplicationInfo方法需要的第一个参数是PackageParser.Package；从名字上看这个类代表某个apk包的信息，我们看看文档怎么解释：</p>
<blockquote>
<p>Representation of a full package parsed from APK files on disk. A package consists of a single base APK, and zero or more split APKs.</p>
</blockquote>
<p>果然，这个类代表从PackageParser中解析得到的某个apk包的信息，是磁盘上apk文件在内存中的数据结构表示；因此，要获取这个类，肯定需要解析整个apk文件。PackageParser中解析apk的核心方法是parsePackage，这个方法返回的就是一个Package类型的实例，因此我们调用这个方法即可；使用反射代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 首先, 我们得创建出一个Package对象出来供这个方法调用  </span><br><span class="line">&#x2F;&#x2F; 而这个需要得对象可以通过 android.content.pm.PackageParser#parsePackage 这个方法返回得 Package对象得字段获取得到  </span><br><span class="line">&#x2F;&#x2F; 创建出一个PackageParser对象供使用  </span><br><span class="line">Object packageParser &#x3D; packageParserClass.newInstance();  </span><br><span class="line">&#x2F;&#x2F; 调用 PackageParser.parsePackage 解析apk的信息  </span><br><span class="line">Method parsePackageMethod &#x3D; packageParserClass.getDeclaredMethod(&quot;parsePackage&quot;, File.class, int.class);  </span><br><span class="line">  </span><br><span class="line">&#x2F;&#x2F; 实际上是一个 android.content.pm.PackageParser.Package 对象  </span><br><span class="line">Object packageObj &#x3D; parsePackageMethod.invoke(packageParser, apkFile, 0);</span><br></pre></td></tr></table></figure>
<p>这样，我们就得到了generateApplicationInfo的第一个参数；第二个参数是解析包使用的flag，我们直接选择解析全部信息，也就是0；</p>
<h4 id="构建PackageUserState"><a href="#构建PackageUserState" class="headerlink" title="构建PackageUserState"></a>构建PackageUserState</h4><p>第三个参数是PackageUserState，代表不同用户中包的信息。由于Android是一个多任务多用户系统，因此不同的用户同一个包可能有不同的状态；这里我们只需要获取包的信息，因此直接使用默认的即可；</p>
<p>至此，generateApplicaionInfo的参数我们已经全部构造完成，直接调用此方法即可得到我们需要的applicationInfo对象；在返回之前我们需要做一点小小的修改：使用系统系统的这个方法解析得到的ApplicationInfo对象中并没有apk文件本身的信息，所以我们把解析的apk文件的路径设置一下（ClassLoader依赖dex文件以及apk的路径）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 第三个参数 mDefaultPackageUserState 我们直接使用默认构造函数构造一个出来即可  </span><br><span class="line">Object defaultPackageUserState &#x3D; packageUserStateClass.newInstance();  </span><br><span class="line">  </span><br><span class="line">&#x2F;&#x2F; 万事具备!!!!!!!!!!!!!!  </span><br><span class="line">ApplicationInfo applicationInfo &#x3D; (ApplicationInfo) generateApplicationInfoMethod.invoke(packageParser,  </span><br><span class="line"> packageObj, 0, defaultPackageUserState);  </span><br><span class="line">String apkPath &#x3D; apkFile.getPath();  </span><br><span class="line">applicationInfo.sourceDir &#x3D; apkPath;  </span><br><span class="line">applicationInfo.publicSourceDir &#x3D; apkPath;</span><br></pre></td></tr></table></figure>

<h3 id="替换ClassLoader"><a href="#替换ClassLoader" class="headerlink" title="替换ClassLoader"></a>替换ClassLoader</h3><h4 id="获取LoadedApk信息"><a href="#获取LoadedApk信息" class="headerlink" title="获取LoadedApk信息"></a>获取LoadedApk信息</h4><p>方才为了获取ApplicationInfo我们费了好大一番精力；回顾一下我们的初衷：</p>
<p>我们最终的目的是调用getPackageInfoNoCheck得到LoadedApk的信息，并替换其中的mClassLoader然后把把添加到ActivityThread的mPackages缓存中；从而达到我们使用自己的ClassLoader加载插件中的类的目的。</p>
<p>现在我们已经拿到了getPackageInfoNoCheck这个方法中至关重要的第一个参数applicationInfo；上文提到第二个参数CompatibilityInfo代表设备兼容性信息，直接使用默认的值即可；因此，两个参数都已经构造出来，我们可以调用getPackageInfoNoCheck获取LoadedApk：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; android.content.res.CompatibilityInfo  </span><br><span class="line">Class&lt;?&gt; compatibilityInfoClass &#x3D; Class.forName(&quot;android.content.res.CompatibilityInfo&quot;);  </span><br><span class="line">Method getPackageInfoNoCheckMethod &#x3D; activityThreadClass.getDeclaredMethod(&quot;getPackageInfoNoCheck&quot;, ApplicationInfo.class, compatibilityInfoClass);  </span><br><span class="line">  </span><br><span class="line">Field defaultCompatibilityInfoField &#x3D; compatibilityInfoClass.getDeclaredField(&quot;DEFAULT\_COMPATIBILITY\_INFO&quot;);  </span><br><span class="line">defaultCompatibilityInfoField.setAccessible(true);  </span><br><span class="line">  </span><br><span class="line">Object defaultCompatibilityInfo &#x3D; defaultCompatibilityInfoField.get(null);  </span><br><span class="line">ApplicationInfo applicationInfo &#x3D; generateApplicationInfo(apkFile);  </span><br><span class="line">  </span><br><span class="line">Object loadedApk &#x3D; getPackageInfoNoCheckMethod.invoke(currentActivityThread, applicationInfo, defaultCompatibilityInfo);</span><br></pre></td></tr></table></figure>
<p>我们成功地构造出了LoadedAPK, 接下来我们需要替换其中的ClassLoader，然后把它添加进ActivityThread的mPackages中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String odexPath &#x3D; Utils.getPluginOptDexDir(applicationInfo.packageName).getPath();  </span><br><span class="line">String libDir &#x3D; Utils.getPluginLibDir(applicationInfo.packageName).getPath();  </span><br><span class="line">ClassLoader classLoader &#x3D; new CustomClassLoader(apkFile.getPath(), odexPath, libDir, ClassLoader.getSystemClassLoader());  </span><br><span class="line">Field mClassLoaderField &#x3D; loadedApk.getClass().getDeclaredField(&quot;mClassLoader&quot;);  </span><br><span class="line">mClassLoaderField.setAccessible(true);  </span><br><span class="line">mClassLoaderField.set(loadedApk, classLoader);  </span><br><span class="line">&#x2F;&#x2F; 由于是弱引用, 因此我们必须在某个地方存一份, 不然容易被GC; 那么就前功尽弃了.  </span><br><span class="line">sLoadedApk.put(applicationInfo.packageName, loadedApk);  </span><br><span class="line">  </span><br><span class="line">WeakReference weakReference &#x3D; new WeakReference(loadedApk);  </span><br><span class="line">mPackages.put(applicationInfo.packageName, weakReference);</span><br></pre></td></tr></table></figure>
<p>我们的这个CustomClassLoader非常简单，直接继承了DexClassLoader，什么都没有做；当然这里可以直接使用DexClassLoader，这里重新创建一个类是为了更有区分度；以后也可以通过修改这个类实现对于类加载的控制：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class CustomClassLoader extends DexClassLoader &#123;  </span><br><span class="line">  </span><br><span class="line"> public CustomClassLoader(String dexPath, String optimizedDirectory, String libraryPath, ClassLoader parent) &#123;  </span><br><span class="line"> super(dexPath, optimizedDirectory, libraryPath, parent);  </span><br><span class="line"> &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到这里，我们已经成功地把把插件的信息放入ActivityThread中，这样我们插件中的类能够成功地被加载；因此插件中的Activity实例能被成功第创建；由于整个流程较为复杂，我们简单梳理一下：</p>
<ol>
<li>在ActivityThread接收到IApplication的 scheduleLaunchActivity远程调用之后，将消息转发给<code>H</code></li>
<li><code>H</code>类在handleMessage的时候，调用了getPackageInfoNoCheck方法来获取待启动的组件信息。在这个方法中会优先查找<code>mPackages</code>中的缓存信息，而我们已经手动把插件信息添加进去；因此能够成功命中缓存，获取到独立存在的插件信息。</li>
<li><code>H</code>类然后调用handleLaunchActivity最终转发到performLaunchActivity方法；这个方法使用从getPackageInfoNoCheck中拿到LoadedApk中的mClassLoader来加载Activity类，进而使用反射创建Activity实例；接着创建Application，Context等完成Activity组件的启动。</li>
</ol>
<p>看起来好像已经天衣无缝万事大吉了；但是运行一下会出现一个异常，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">04-05 02:49:53.742  11759-11759&#x2F;com.weishu.upf.hook_classloader E&#x2F;AndroidRuntime﹕ FATAL EXCEPTION: main  </span><br><span class="line"> Process: com.weishu.upf.hook_classloader, PID: 11759  </span><br><span class="line"> java.lang.RuntimeException: Unable to start activity ComponentInfo&#123;com.weishu.upf.ams\_pms\_hook.app&#x2F;com.weishu.upf.ams\_pms\_hook.app.MainActivity&#125;: java.lang.RuntimeException: Unable to instantiate application android.app.Application: java.lang.IllegalStateException: Unable to get package info for com.weishu.upf.ams\_pms\_hook.app; is package not installed?</span><br></pre></td></tr></table></figure>

<p>错误提示说是无法实例化 <code>Application</code>，而Application的创建也是在performLaunchActivity中进行的，这里有些蹊跷，我们仔细查看一下。</p>
<h4 id="绕过系统检查"><a href="#绕过系统检查" class="headerlink" title="绕过系统检查"></a>绕过系统检查</h4><p>通过ActivityThread的performLaunchActivity方法可以得知，Application通过LoadedApk的makeApplication方法创建，我们查看这个方法，在源码中发现了上文异常抛出的位置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">try &#123;  </span><br><span class="line"> java.lang.ClassLoader cl &#x3D; getClassLoader();  </span><br><span class="line"> if (!mPackageName.equals(&quot;android&quot;)) &#123;  </span><br><span class="line"> initializeJavaContextClassLoader();  </span><br><span class="line"> &#125;  </span><br><span class="line"> ContextImpl appContext &#x3D; ContextImpl.createAppContext(mActivityThread, this);  </span><br><span class="line"> app &#x3D; mActivityThread.mInstrumentation.newApplication(  </span><br><span class="line"> cl, appClass, appContext);  </span><br><span class="line"> appContext.setOuterContext(app);  </span><br><span class="line">&#125; catch (Exception e) &#123;  </span><br><span class="line"> if (!mActivityThread.mInstrumentation.onException(app, e)) &#123;  </span><br><span class="line"> throw new RuntimeException(  </span><br><span class="line"> &quot;Unable to instantiate application &quot; \+ appClass  </span><br><span class="line"> \+ &quot;: &quot; \+ e.toString(), e);  </span><br><span class="line"> &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>木有办法，我们只有一行一行地查看到底是哪里抛出这个异常的了；所幸代码不多。（所以说，缩小异常范围是一件多么重要的事情！！！）</p>
<p>第一句 getClassLoader() 没什么可疑的，虽然方法很长，但是它木有抛出任何异常（当然，它调用的代码可能抛出异常，万一找不到只能进一步深搜了；所以我觉得这里应该使用受检异常）。</p>
<p>然后我们看第二句，如果包名不是<code>android</code>开头，那么调用了一个叫做initializeJavaContextClassLoader的方法；我们查阅这个方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">private void initializeJavaContextClassLoader() &#123;  </span><br><span class="line"> IPackageManager pm &#x3D; ActivityThread.getPackageManager();  </span><br><span class="line"> android.content.pm.PackageInfo pi;  </span><br><span class="line"> try &#123;  </span><br><span class="line"> pi &#x3D; pm.getPackageInfo(mPackageName, 0, UserHandle.myUserId());  </span><br><span class="line"> &#125; catch (RemoteException e) &#123;  </span><br><span class="line"> throw new IllegalStateException(&quot;Unable to get package info for &quot;  </span><br><span class="line"> \+ mPackageName + &quot;; is system dying?&quot;, e);  </span><br><span class="line"> &#125;  </span><br><span class="line"> if (pi &#x3D;&#x3D; null) &#123;  </span><br><span class="line"> throw new IllegalStateException(&quot;Unable to get package info for &quot;  </span><br><span class="line"> \+ mPackageName + &quot;; is package not installed?&quot;);  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line"> boolean sharedUserIdSet &#x3D; (pi.sharedUserId !&#x3D; null);  </span><br><span class="line"> boolean processNameNotDefault &#x3D;  </span><br><span class="line"> (pi.applicationInfo !&#x3D; null &amp;&amp;  </span><br><span class="line"> !mPackageName.equals(pi.applicationInfo.processName));  </span><br><span class="line"> boolean sharable &#x3D; (sharedUserIdSet || processNameNotDefault);  </span><br><span class="line"> ClassLoader contextClassLoader &#x3D;  </span><br><span class="line"> (sharable)  </span><br><span class="line"> ? new WarningContextClassLoader()  </span><br><span class="line"> : mClassLoader;  </span><br><span class="line"> Thread.currentThread().setContextClassLoader(contextClassLoader);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里，我们找出了这个异常的来源：原来这里调用了<code>getPackageInfo</code>方法获取包的信息；而我们的插件<strong>并没有安装在系统上</strong>，因此系统肯定认为插件没有安装，这个方法肯定返回null。所以，我们还要欺骗一下PMS，让系统觉得<strong>插件已经安装在系统上了</strong>；至于如何欺骗 PMS，<a href="http://weishu.me/2016/03/07/understand-plugin-framework-ams-pms-hook/" target="_blank" rel="noopener">Hook机制之AMS&amp;PMS</a> 有详细解释，这里直接给出代码，不赘述了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">private static void hookPackageManager() throws Exception &#123;  </span><br><span class="line">  </span><br><span class="line"> &#x2F;&#x2F; 这一步是因为 initializeJavaContextClassLoader 这个方法内部无意中检查了这个包是否在系统安装  </span><br><span class="line"> &#x2F;&#x2F; 如果没有安装, 直接抛出异常, 这里需要临时Hook掉 PMS, 绕过这个检查.  </span><br><span class="line">  </span><br><span class="line"> Class&lt;?&gt; activityThreadClass &#x3D; Class.forName(&quot;android.app.ActivityThread&quot;);  </span><br><span class="line"> Method currentActivityThreadMethod &#x3D; activityThreadClass.getDeclaredMethod(&quot;currentActivityThread&quot;);  </span><br><span class="line"> currentActivityThreadMethod.setAccessible(true);  </span><br><span class="line"> Object currentActivityThread &#x3D; currentActivityThreadMethod.invoke(null);  </span><br><span class="line">  </span><br><span class="line"> &#x2F;&#x2F; 获取ActivityThread里面原始的 sPackageManager  </span><br><span class="line"> Field sPackageManagerField &#x3D; activityThreadClass.getDeclaredField(&quot;sPackageManager&quot;);  </span><br><span class="line"> sPackageManagerField.setAccessible(true);  </span><br><span class="line"> Object sPackageManager &#x3D; sPackageManagerField.get(currentActivityThread);  </span><br><span class="line">  </span><br><span class="line"> &#x2F;&#x2F; 准备好代理对象, 用来替换原始的对象  </span><br><span class="line"> Class&lt;?&gt; iPackageManagerInterface &#x3D; Class.forName(&quot;android.content.pm.IPackageManager&quot;);  </span><br><span class="line"> Object proxy &#x3D; Proxy.newProxyInstance(iPackageManagerInterface.getClassLoader(),  </span><br><span class="line"> new Class&lt;?&gt;\[\] &#123; iPackageManagerInterface &#125;,  </span><br><span class="line"> new IPackageManagerHookHandler(sPackageManager));  </span><br><span class="line">  </span><br><span class="line"> &#x2F;&#x2F; 1\. 替换掉ActivityThread里面的 sPackageManager 字段  </span><br><span class="line"> sPackageManagerField.set(currentActivityThread, proxy);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>OK到这里，我们已经能够成功地加载<strong>简单的</strong>独立的存在于外部文件系统中的apk了。至此 关于 DroidPlugin 对于Activity生命周期的管理已经完全讲解完毕了；这是一种极其复杂的Activity管理方案，我们仅仅写一个用来理解的demo就Hook了相当多的东西，在Framework层来回牵扯；这其中的来龙去脉要完全把握清楚还请读者亲自翻阅源码。另外，我在此 对DroidPlugin 作者献上我的膝盖～这其中的玄妙让人叹为观止！</p>
<p>上文给出的方案中，我们全盘接管了插件中类的加载过程，这是一种相对暴力的解决方案；能不能更温柔一点呢？通俗来说，我们可以选择改革，而不是革命——告诉系统ClassLoader一些必要信息，让它帮忙完成插件类的加载。</p>
<h2 id="保守方案：委托系统，让系统帮忙加载"><a href="#保守方案：委托系统，让系统帮忙加载" class="headerlink" title="保守方案：委托系统，让系统帮忙加载"></a>保守方案：委托系统，让系统帮忙加载</h2><p>我们再次搬出ActivityThread中加载Activity类的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">java.lang.ClassLoader cl &#x3D; r.packageInfo.getClassLoader();  </span><br><span class="line">activity &#x3D; mInstrumentation.newActivity(  </span><br><span class="line"> cl, component.getClassName(), r.intent);  </span><br><span class="line">StrictMode.incrementExpectedActivityCount(activity.getClass());  </span><br><span class="line">r.intent.setExtrasClassLoader(cl);</span><br></pre></td></tr></table></figure>
<p>我们知道 这个r.packageInfo中的<code>r</code>是通过getPackageInfoNoCheck获取到的；在『激进方案』中我们把插件apk手动添加进缓存，采用自己加载办法解决；如果我们不干预这个过程，导致无法命中mPackages中的缓存，会发生什么？</p>
<p>查阅 getPackageInfo方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">private LoadedApk getPackageInfo(ApplicationInfo aInfo, CompatibilityInfo compatInfo,  </span><br><span class="line"> ClassLoader baseLoader, boolean securityViolation, boolean includeCode,  </span><br><span class="line"> boolean registerPackage) &#123;  </span><br><span class="line"> final boolean differentUser &#x3D; (UserHandle.myUserId() !&#x3D; UserHandle.getUserId(aInfo.uid));  </span><br><span class="line"> synchronized (mResourcesManager) &#123;  </span><br><span class="line"> WeakReference&lt;LoadedApk&gt; ref;  </span><br><span class="line"> if (differentUser) &#123;  </span><br><span class="line"> &#x2F;&#x2F; Caching not supported across users  </span><br><span class="line"> ref &#x3D; null;  </span><br><span class="line"> &#125; else if (includeCode) &#123;  </span><br><span class="line"> ref &#x3D; mPackages.get(aInfo.packageName);  </span><br><span class="line"> &#125; else &#123;  </span><br><span class="line"> ref &#x3D; mResourcePackages.get(aInfo.packageName);  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line"> LoadedApk packageInfo &#x3D; ref !&#x3D; null ? ref.get() : null;  </span><br><span class="line"> if (packageInfo &#x3D;&#x3D; null || (packageInfo.mResources !&#x3D; null  </span><br><span class="line"> &amp;&amp; !packageInfo.mResources.getAssets().isUpToDate())) &#123;  </span><br><span class="line"> packageInfo &#x3D;  </span><br><span class="line"> new LoadedApk(this, aInfo, compatInfo, baseLoader,  </span><br><span class="line"> securityViolation, includeCode &amp;&amp;  </span><br><span class="line"> (aInfo.flags&amp;ApplicationInfo.FLAG\_HAS\_CODE) !&#x3D; 0, registerPackage);  </span><br><span class="line">  </span><br><span class="line"> &#x2F;&#x2F; 略  </span><br><span class="line"> &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，没有命中缓存的情况下，系统直接new了一个LoadedApk；注意这个构造函数的第二个参数<code>aInfo</code>，这是一个ApplicationInfo类型的对象。在『激进方案』中我们为了获取独立插件的ApplicationInfo花了不少心思；那么如果不做任何处理这里传入的这个<code>aInfo</code>参数是什么？</p>
<p>追本溯源不难发现，这个aInfo是从我们的替身StubActivity中获取的！而StubActivity存在于宿主程序中，所以，这个<code>aInfo</code>对象代表的实际上就是宿主程序的Application信息！</p>
<p>我们知道，接下来会使用new出来的这个LoadedApk的getClassLoader()方法获取到ClassLoader来对插件的类进行加载；而获取到的这个ClassLoader是宿主程序使用的ClassLoader，因此现在还无法加载插件的类；那么，<strong>我们能不能让宿主的ClasLoader获得加载插件类的能力呢？</strong>；如果我们告诉宿主使用的ClassLoader插件使用的类在哪里，就能帮助他完成加载！</p>
<h3 id="宿主的ClassLoader在哪里，是唯一的吗？"><a href="#宿主的ClassLoader在哪里，是唯一的吗？" class="headerlink" title="宿主的ClassLoader在哪里，是唯一的吗？"></a>宿主的ClassLoader在哪里，是唯一的吗？</h3><p>上面说到，我们可以通过告诉宿主程序的ClassLoader插件使用的类，让宿主的ClasLoader完成对于插件类的加载；那么问题来了，我们如何获取到宿主的ClassLoader？宿主程序使用的ClasLoader默认情况下是全局唯一的吗？</p>
<p>答案是肯定的。</p>
<p>因为在FrameWork中宿主程序也是使用LoadedApk表示的，如同Activity启动是加载Activity类一样，宿主中的类也都是通过LoadedApk的getClassLoader()方法得到的ClassLoader加载的；由类加载机制的『双亲委派』特性，只要有一个应用程序类由某一个ClassLoader加载，那么它引用到的别的类除非父加载器能加载，否则都是由这同一个加载器加载的（不遵循双亲委派模型的除外）。</p>
<p>表示宿主的LoadedApk在Application类中有一个成员变量<code>mLoadedApk</code>，而这个变量是从ContextImpl中获取的；ContextImpl重写了getClassLoader方法，因此<strong>我们在Context环境中直接getClassLoader()获取到的就是宿主程序唯一的ClassLoader</strong>。</p>
<h3 id="LoadedApk的ClassLoader到底是什么？"><a href="#LoadedApk的ClassLoader到底是什么？" class="headerlink" title="LoadedApk的ClassLoader到底是什么？"></a>LoadedApk的ClassLoader到底是什么？</h3><p>现在我们确保了『使用宿主ClassLoader帮助加载插件类』可行性；那么我们应该如何完成这个过程呢？</p>
<p>知己知彼，百战不殆。</p>
<p>不论是宿主程序还是插件程序都是通过LoadedApk的getClassLoader()方法返回的ClassLoader进行类加载的，返回的这个ClassLoader到底是个什么东西？？这个方法源码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public ClassLoader getClassLoader() &#123;  </span><br><span class="line"> synchronized (this) &#123;  </span><br><span class="line"> if (mClassLoader !&#x3D; null) &#123;  </span><br><span class="line"> return mClassLoader;  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line"> if (mIncludeCode &amp;&amp; !mPackageName.equals(&quot;android&quot;)) &#123;  </span><br><span class="line"> &#x2F;&#x2F; 略...  </span><br><span class="line"> mClassLoader &#x3D; ApplicationLoaders.getDefault().getClassLoader(zip, lib,  </span><br><span class="line"> mBaseClassLoader);  </span><br><span class="line">  </span><br><span class="line"> StrictMode.setThreadPolicy(oldPolicy);  </span><br><span class="line"> &#125; else &#123;  </span><br><span class="line"> if (mBaseClassLoader &#x3D;&#x3D; null) &#123;  </span><br><span class="line"> mClassLoader &#x3D; ClassLoader.getSystemClassLoader();  </span><br><span class="line"> &#125; else &#123;  </span><br><span class="line"> mClassLoader &#x3D; mBaseClassLoader;  </span><br><span class="line"> &#125;  </span><br><span class="line"> &#125;  </span><br><span class="line"> return mClassLoader;  </span><br><span class="line"> &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，非<code>android</code>开头的包和<code>android</code>开头的包分别使用了两种不同的ClassLoader，我们只关心第一种；因此继续跟踪ApplicationLoaders类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public ClassLoader getClassLoader(String zip, String libPath, ClassLoader parent)  </span><br><span class="line">&#123;  </span><br><span class="line">  </span><br><span class="line"> ClassLoader baseParent &#x3D; ClassLoader.getSystemClassLoader().getParent();  </span><br><span class="line">  </span><br><span class="line"> synchronized (mLoaders) &#123;  </span><br><span class="line"> if (parent &#x3D;&#x3D; null) &#123;  </span><br><span class="line"> parent &#x3D; baseParent;  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line"> if (parent &#x3D;&#x3D; baseParent) &#123;  </span><br><span class="line"> ClassLoader loader &#x3D; mLoaders.get(zip);  </span><br><span class="line"> if (loader !&#x3D; null) &#123;  </span><br><span class="line"> return loader;  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line"> Trace.traceBegin(Trace.TRACE\_TAG\_ACTIVITY_MANAGER, zip);  </span><br><span class="line"> PathClassLoader pathClassloader &#x3D;  </span><br><span class="line"> new PathClassLoader(zip, libPath, parent);  </span><br><span class="line"> Trace.traceEnd(Trace.TRACE\_TAG\_ACTIVITY_MANAGER);  </span><br><span class="line">  </span><br><span class="line"> mLoaders.put(zip, pathClassloader);  </span><br><span class="line"> return pathClassloader;  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line"> Trace.traceBegin(Trace.TRACE\_TAG\_ACTIVITY_MANAGER, zip);  </span><br><span class="line"> PathClassLoader pathClassloader &#x3D; new PathClassLoader(zip, parent);  </span><br><span class="line"> Trace.traceEnd(Trace.TRACE\_TAG\_ACTIVITY_MANAGER);  </span><br><span class="line"> return pathClassloader;  </span><br><span class="line"> &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，应用程序使用的ClassLoader都是PathClassLoader类的实例。那么，这个PathClassLoader是什么呢？从Android SDK给出的源码只能看出这么多：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class PathClassLoader extends BaseDexClassLoader &#123;  </span><br><span class="line"> public PathClassLoader(String dexPath, ClassLoader parent) &#123;  </span><br><span class="line"> super((String)null, (File)null, (String)null, (ClassLoader)null);  </span><br><span class="line"> throw new RuntimeException(&quot;Stub!&quot;);  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line"> public PathClassLoader(String dexPath, String libraryPath, ClassLoader parent) &#123;  </span><br><span class="line"> super((String)null, (File)null, (String)null, (ClassLoader)null);  </span><br><span class="line"> throw new RuntimeException(&quot;Stub!&quot;);  </span><br><span class="line"> &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>SDK没有导出这个类的源码，我们去<a href="http://androidxref.com/6.0.1_r10/xref/libcore/dalvik/src/main/java/dalvik/system/PathClassLoader.java" target="_blank" rel="noopener">androidxref</a>上面看；发现其实这个类真的就这么多内容；我们继续查看它的父类<a href="http://androidxref.com/6.0.1_r10/xref/libcore/dalvik/src/main/java/dalvik/system/BaseDexClassLoader.java" target="_blank" rel="noopener">BaseDexClassLoader</a>；ClassLoader嘛，我们查看findClass或者defineClass方法，BaseDexClassLoader的findClass方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123;  </span><br><span class="line"> List&lt;Throwable&gt; suppressedExceptions &#x3D; new ArrayList&lt;Throwable&gt;();  </span><br><span class="line"> Class c &#x3D; pathList.findClass(name, suppressedExceptions);  </span><br><span class="line"> if (c &#x3D;&#x3D; null) &#123;  </span><br><span class="line"> ClassNotFoundException cnfe &#x3D; new ClassNotFoundException(&quot;Didn&#39;t find class \\&quot;&quot; \+ name + &quot;\\&quot; on path: &quot; \+ pathList);  </span><br><span class="line"> for (Throwable t : suppressedExceptions) &#123;  </span><br><span class="line"> cnfe.addSuppressed(t);  </span><br><span class="line"> &#125;  </span><br><span class="line"> throw cnfe;  </span><br><span class="line"> &#125;  </span><br><span class="line"> return c;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，查找Class的任务通过<code>pathList</code>完成；这个<code>pathList</code>是一个<code>DexPathList</code>类的对象，它的<code>findClass</code>方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public Class findClass(String name, List&lt;Throwable&gt; suppressed) &#123;  </span><br><span class="line"> for (Element element : dexElements) &#123;  </span><br><span class="line"> DexFile dex &#x3D; element.dexFile;  </span><br><span class="line">  </span><br><span class="line"> if (dex !&#x3D; null) &#123;  </span><br><span class="line"> Class clazz &#x3D; dex.loadClassBinaryName(name, definingContext, suppressed);  </span><br><span class="line"> if (clazz !&#x3D; null) &#123;  </span><br><span class="line"> return clazz;  </span><br><span class="line"> &#125;  </span><br><span class="line"> &#125;  </span><br><span class="line"> &#125;  </span><br><span class="line"> if (dexElementsSuppressedExceptions !&#x3D; null) &#123;  </span><br><span class="line"> suppressed.addAll(Arrays.asList(dexElementsSuppressedExceptions));  </span><br><span class="line"> &#125;  </span><br><span class="line"> return null;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个DexPathList内部有一个叫做dexElements的数组，然后findClass的时候会遍历这个数组来查找Class；<strong>如果我们把插件的信息塞进这个数组里面，那么不就能够完成类的加载过程吗？！！</strong></p>
<h3 id="给默认ClassLoader打补丁"><a href="#给默认ClassLoader打补丁" class="headerlink" title="给默认ClassLoader打补丁"></a>给默认ClassLoader打补丁</h3><p>通过上述分析，我们知道，可以把插件的相关信息放入BaseDexClassLoader的表示dex文件的数组里面，这样宿主程序的ClassLoader在进行类加载，遍历这个数组的时候，会自动遍历到我们添加进去的插件信息，从而完成插件类的加载！</p>
<p>接下来，我们实现这个过程；我们会用到一些较为复杂的反射技术哦～不过代码非常短：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public static void patchClassLoader(ClassLoader cl, File apkFile, File optDexFile)  </span><br><span class="line"> throws IllegalAccessException, NoSuchMethodException, IOException, InvocationTargetException, InstantiationException, NoSuchFieldException &#123;  </span><br><span class="line"> &#x2F;&#x2F; 获取 BaseDexClassLoader : pathList  </span><br><span class="line"> Field pathListField &#x3D; DexClassLoader.class.getSuperclass().getDeclaredField(&quot;pathList&quot;);  </span><br><span class="line"> pathListField.setAccessible(true);  </span><br><span class="line"> Object pathListObj &#x3D; pathListField.get(cl);  </span><br><span class="line">  </span><br><span class="line"> &#x2F;&#x2F; 获取 PathList: Element\[\] dexElements  </span><br><span class="line"> Field dexElementArray &#x3D; pathListObj.getClass().getDeclaredField(&quot;dexElements&quot;);  </span><br><span class="line"> dexElementArray.setAccessible(true);  </span><br><span class="line"> Object\[\] dexElements &#x3D; (Object\[\]) dexElementArray.get(pathListObj);  </span><br><span class="line">  </span><br><span class="line"> &#x2F;&#x2F; Element 类型  </span><br><span class="line"> Class&lt;?&gt; elementClass &#x3D; dexElements.getClass().getComponentType();  </span><br><span class="line">  </span><br><span class="line"> &#x2F;&#x2F; 创建一个数组, 用来替换原始的数组  </span><br><span class="line"> Object\[\] newElements &#x3D; (Object\[\]) Array.newInstance(elementClass, dexElements.length + 1);  </span><br><span class="line">  </span><br><span class="line"> &#x2F;&#x2F; 构造插件Element(File file, boolean isDirectory, File zip, DexFile dexFile) 这个构造函数  </span><br><span class="line"> Constructor&lt;?&gt; constructor &#x3D; elementClass.getConstructor(File.class, boolean.class, File.class, DexFile.class);  </span><br><span class="line"> Object o &#x3D; constructor.newInstance(apkFile, false, apkFile, DexFile.loadDex(apkFile.getCanonicalPath(), optDexFile.getAbsolutePath(), 0));  </span><br><span class="line">  </span><br><span class="line"> Object\[\] toAddElementArray &#x3D; new Object\[\] &#123; o &#125;;  </span><br><span class="line"> &#x2F;&#x2F; 把原始的elements复制进去  </span><br><span class="line"> System.arraycopy(dexElements, 0, newElements, 0, dexElements.length);  </span><br><span class="line"> &#x2F;&#x2F; 插件的那个element复制进去  </span><br><span class="line"> System.arraycopy(toAddElementArray, 0, newElements, dexElements.length, toAddElementArray.length);  </span><br><span class="line">  </span><br><span class="line"> &#x2F;&#x2F; 替换  </span><br><span class="line"> dexElementArray.set(pathListObj, newElements);  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>短短的二十几行代码，我们就完成了『委托宿主ClassLoader加载插件类』的任务；因此第二种方案也宣告完成！我们简要总结一下这种方式的原理：</p>
<ol>
<li>默认情况下performLacunchActivity会使用替身StubActivity的ApplicationInfo也就是宿主程序的CLassLoader加载所有的类；我们的思路是告诉宿主ClassLoader我们在哪，让其帮助完成类加载的过程。</li>
<li>宿主程序的ClassLoader最终继承自BaseDexClassLoader，BaseDexClassLoader通过DexPathList进行类的查找过程；而这个查找通过遍历一个dexElements的数组完成；<strong>我们通过把插件dex添加进这个数组</strong>就让宿主ClasLoader获取了加载插件类的能力。</li>
</ol>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文中我们采用两种方案成功完成了『启动没有在AndroidManifest.xml中显示声明，并且存在于外部插件中的Activity』的任务。</p>
<p>『激进方案』中我们自定义了插件的ClassLoader，并且绕开了Framework的检测；利用ActivityThread对于LoadedApk的缓存机制，我们把携带这个自定义的ClassLoader的插件信息添加进<code>mPackages</code>中，进而完成了类的加载过程。</p>
<p>『保守方案』中我们深入探究了系统使用ClassLoader findClass的过程，发现应用程序使用的非系统类都是通过同一个PathClassLoader加载的；而这个类的最终父类BaseDexClassLoader通过DexPathList完成类的查找过程；我们hack了这个查找过程，从而完成了插件类的加载。</p>
<p>这两种方案孰优孰劣呢？</p>
<p>很显然，『激进方案』比较麻烦，从代码量和分析过程就可以看出来，这种机制异常复杂；而且在解析apk的时候我们使用的PackageParser的兼容性非常差，我们不得不手动处理每一个版本的apk解析api；另外，它Hook的地方也有点多：不仅需要Hook AMS和<code>H</code>，还需要Hook ActivityThread的<code>mPackages</code>和PackageManager！</p>
<p>『保守方案』则简单得多（虽然原理也不简单），不仅代码很少，而且Hook的地方也不多；有一点正本清源的意思，从最最上层Hook住了整个类的加载过程。</p>
<p>但是，我们不能简单地说『保守方案』比『激进方案』好。从根本上说，这两种方案的差异在哪呢？</p>
<p>『激进方案』是<strong>多ClassLoader构架</strong>，每一个插件都有一个自己的ClassLoader，因此类的隔离性非常好——如果不同的插件使用了同一个库的不同版本，它们相安无事！『保守方案』是<strong>单ClassLoader方案</strong>，插件和宿主程序的类全部都通过宿主的ClasLoader加载，虽然代码简单，但是鲁棒性很差；一旦插件之间甚至插件与宿主之间使用的类库有冲突，那么直接GG。</p>
<p>多ClassLoader还有一个优点：可以真正完成代码的热加载！如果插件需要升级，直接重新创建一个自定的ClassLoader加载新的插件，然后替换掉原来的版本即可（Java中，不同ClassLoader加载的同一个类被认为是不同的类）；单ClassLoader的话实现非常麻烦，有可能需要重启进程。</p>
<p>在J2EE领域中广泛使用ClasLoader的地方均采用多ClassLoader架构，比如Tomcat服务器，Java模块化事实标准的OSGi技术；所以，我们有足够的理由认为<strong>选择多ClassLoader架构在大多数情况下是明智之举</strong>。</p>
<p>目前开源的插件方案中，DroidPlugin采用的『激进方案』，Small采用的『保守方案』那么，有没有两种优点兼顾的方案呢？？</p>
<p>答案自然是有的。</p>
<p>DroidPlugin和Small的共同点是<strong>两者都是非侵入式的插件框架</strong>；什么是『非侵入式』呢？打个比方，你启动一个插件Activity，直接使用<code>startActivity</code>即可，就跟开发普通的apk一样，开发插件和普通的程序对于开发者来说没有什么区别。</p>
<p>如果我们一定程度上放弃这种『侵入性』，那么我们就能实现一个两者优点兼而有之的插件框架！这里我先卖个关子～</p>
<p>OK，本文的内容就到这里了；关于『插件机制对于Activity的处理方式』也就此完结。要说明的是，在本文的『保守方案』其实只处理了代码的加载过程，它并不能加载有资源的apk！所以目前我这个实现基本没什么暖用；当然我这里只是就『代码加载』进行举例；至于资源，那牵扯到另外一个问题——<strong>插件系统的资源管理机制</strong>这个在后续文章的合适机会我会单独讲解。</p>
<p>接下来的文章，会讲述Android四大组件的另外三个<code>Service</code>，<code>BroadCastReceiver</code>, <code>ContentProvider</code>的处理方式。喜欢就点个赞吧～持续更新，请关注github项目 <a href="https://github.com/tiann/understand-plugin-framework" target="_blank" rel="noopener">understand-plugin-framework</a>和我的 <a href="http://weishu.me" target="_blank" rel="noopener">博客</a>! 这文章我前前后后准备了快两个星期，如果你看到了这里，还请支持一下 :)</p>
<p><a href="/tags/android/">#android</a> <a href="/tags/binder/">#binder</a> <a href="/tags/classloader/">#classloader</a> <a href="/tags/droidplugin/">#droidplugin</a> <a href="/tags/plugin-framework/">#plugin framework</a></p>
<p><a href="/2016/04/12/understand-plugin-framework-receiver/">Android插件化原理解析——广播的管理</a></p>
<p><a href="/2016/03/21/understand-plugin-framework-activity-management/">Android 插件化原理解析——Activity生命周期管理</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://reoger.tk/2018/08/31/android/Android%20%E6%8F%92%E4%BB%B6%E5%8C%96%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90%E2%80%94%E2%80%94%E6%8F%92%E4%BB%B6%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="reoger">
      <meta itemprop="description" content="reoger">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="reoger的记录">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/08/31/android/Android%20%E6%8F%92%E4%BB%B6%E5%8C%96%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90%E2%80%94%E2%80%94%E6%8F%92%E4%BB%B6%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/" class="post-title-link" itemprop="url">Android 插件化原理解析——插件加载机制</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-08-31 11:13:55" itemprop="dateCreated datePublished" datetime="2018-08-31T11:13:55+08:00">2018-08-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-12 22:54:20" itemprop="dateModified" datetime="2020-04-12T22:54:20+08:00">2020-04-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%BD%AC%E8%BD%BD/" itemprop="url" rel="index"><span itemprop="name">转载</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Android-插件化原理解析——插件加载机制"><a href="#Android-插件化原理解析——插件加载机制" class="headerlink" title="Android 插件化原理解析——插件加载机制"></a>Android 插件化原理解析——插件加载机制</h1><p>本文转载自<a href="http://weishu.me/2016/04/05/understand-plugin-framework-classloader/" target="_blank" rel="noopener">http://weishu.me/2016/04/05/understand-plugin-framework-classloader/</a>。</p>
<p>上文 <a href="http://weishu.me/2016/03/21/understand-plugin-framework-activity-management/" target="_blank" rel="noopener">Activity生命周期管理</a> 中我们地完成了『启动没有在AndroidManifest.xml中显式声明的Activity』的任务；通过Hook <code>AMS</code>和拦截ActivityThread中<code>H</code>类对于组件调度我们成功地绕过了AndroidMAnifest.xml的限制。</p>
<p>但是我们启动的『没有在AndroidManifet.xml中显式声明』的Activity和宿主程序存在于同一个Apk中；通常情况下，插件均以独立的文件存在甚至通过网络获取，这时候插件中的Activity能否成功启动呢？</p>
<p>要启动Activity组件肯定先要创建对应的Activity类的对象，从上文 <a href="http://weishu.me/2016/03/21/understand-plugin-framework-activity-management/" target="_blank" rel="noopener">Activity生命周期管理</a> 知道，创建Activity类对象的过程如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">java.lang.ClassLoader cl &#x3D; r.packageInfo.getClassLoader();  </span><br><span class="line">activity &#x3D; mInstrumentation.newActivity(  </span><br><span class="line"> cl, component.getClassName(), r.intent);  </span><br><span class="line">StrictMode.incrementExpectedActivityCount(activity.getClass());  </span><br><span class="line">r.intent.setExtrasClassLoader(cl);</span><br></pre></td></tr></table></figure>
<p>也就是说，系统通过<code>ClassLoader</code>加载了需要的Activity类并通过反射调用构造函数创建出了Activity对象。如果Activity组件存在于独立于宿主程序的文件之中，系统的ClassLoader怎么知道去哪里加载呢？因此，如果不做额外的处理，插件中的Activity对象甚至都没有办法创建出来，谈何启动？</p>
<p>因此，要使存在于独立文件或者网络中的插件被成功启动，首先就需要解决这个<strong>插件类加载</strong>的问题。<br>下文将围绕此问题展开，完成『启动没有在AndroidManifest.xml中显示声明，并且存在于外部插件中的Activity』的任务。</p>
<p>阅读本文之前，可以先clone一份 <a href="https://github.com/tiann/understand-plugin-framework" target="_blank" rel="noopener">understand-plugin-framework</a>，参考此项目的<code>classloader-hook</code> 模块。另外，插件框架原理解析系列文章见<a href="http://weishu.me/2016/01/28/understand-plugin-framework-overview/" target="_blank" rel="noopener">索引</a>。</p>
<h2 id="ClassLoader机制"><a href="#ClassLoader机制" class="headerlink" title="ClassLoader机制"></a>ClassLoader机制</h2><p>或许有的童鞋还不太了解Java的ClassLoader机制，我这里简要介绍一下。</p>
<blockquote>
<p>Java虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校检、转换解析和初始化的，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。<br>与那些在编译时进行链连接工作的语言不同，在Java语言里面，类型的加载、连接和初始化都是在程序运行期间完成的，这种策略虽然会令类加载时稍微增加一些性能开销，但是会为Java应用程序提供高度的灵活性，Java里天生可以同代拓展的语言特性就是依赖运行期动态加载和动态链接这个特点实现的。例如，如果编写一个面相接口的应用程序，可以等到运行时在制定实际的实现类；用户可以通过Java与定义的和自定义的类加载器，让一个本地的应用程序可以在运行时从网络或其他地方加载一个二进制流作为代码的一部分，这种组装应用程序的方式目前已经广泛应用于Java程序之中。从最基础的Applet，JSP到复杂的OSGi技术，都使用了Java语言运行期类加载的特性。</p>
</blockquote>
<p>Java的类加载是一个相对复杂的过程；它包括加载、验证、准备、解析和初始化五个阶段；对于开发者来说，可控性最强的是<strong>加载阶段</strong>；加载阶段主要完成三件事：</p>
<ol>
<li>根据一个类的全限定名来获取定义此类的二进制字节流</li>
<li>将这个字节流所代表的静态存储结构转化为JVM方法区中的运行时数据结构</li>
<li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。</li>
</ol>
<p>『通过一个类的全限定名获取描述此类的二进制字节流』这个过程被抽象出来，就是Java的类加载器模块，也即JDK中ClassLoader API。</p>
<p>Android Framework提供了DexClassLoader这个类，简化了『通过一个类的全限定名获取描述次类的二进制字节流』这个过程；我们只需要告诉DexClassLoader一个dex文件或者apk文件的路径就能完成类的加载。因此本文的内容用一句话就可以概括：</p>
<p><strong>将插件的dex或者apk文件告诉『合适的』DexClassLoader，借助它完成插件类的加载</strong></p>
<p>关于CLassLoader机制更多的内容，请参阅『深入理解Java虚拟机』这本书。</p>
<h2 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h2><p>Android系统使用了ClassLoader机制来进行Activity等组件的加载；apk被安装之后，APK文件的代码以及资源会被系统存放在固定的目录（比如/data/app/package_name/base-1.apk )系统在进行类加载的时候，会自动去这一个或者几个特定的路径来寻找这个类；但是系统并不知道存在于插件中的Activity组件的信息(插件可以是任意位置，甚至是网络，系统无法提前预知)，因此正常情况下系统无法加载我们插件中的类；因此也没有办法创建Activity的对象，更不用谈启动组件了。</p>
<p>解决这个问题有两个思路，要么全盘接管这个类加载的过程；要么告知系统我们使用的插件存在于哪里，让系统帮忙加载；这两种方式或多或少都需要<strong>干预</strong>这个类加载的过程。老规矩，知己知彼，百战不殆。我们首先分析一下，系统是如果完成这个类加载过程的。</p>
<p>我们再次搬出Activity的创建过程的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">java.lang.ClassLoader cl &#x3D; r.packageInfo.getClassLoader();  </span><br><span class="line">activity &#x3D; mInstrumentation.newActivity(cl, component.getClassName(), r.intent);  </span><br><span class="line">StrictMode.incrementExpectedActivityCount(activity.getClass());  </span><br><span class="line">r.intent.setExtrasClassLoader(cl);</span><br></pre></td></tr></table></figure>
<p>这里可以很明显地看到，系统通过待启动的Activity的类名<code>className</code>，然后使用ClassLoader对象<code>cl</code>把这个类加载进虚拟机，最后使用反射创建了这个Activity类的实例对象。要想干预这个ClassLoader（告知它我们的路径或者替换他），我们首先得看看这玩意到底是个什么来头。（从哪里创建的）</p>
<p><code>cl</code>这个ClasssLoader对象通过<code>r.packageInfo</code>对象的getClassLoader()方法得到，r.packageInfo是一个LoadedApk类的对象；那么，LoadedApk到底是个什么东西？？</p>
<p>我们查阅LoadedApk类的文档，只有一句话，不过说的很明白：</p>
<blockquote>
<p>Local state maintained about a currently loaded .apk.</p>
</blockquote>
<p><strong>LoadedApk对象是APK文件在内存中的表示。</strong> Apk文件的相关信息，诸如Apk文件的代码和资源，甚至代码里面的Activity，Service等组件的信息我们都可以通过此对象获取。</p>
<p>OK, 我们知道这个LoadedApk是何方神圣了；接下来我们要搞清楚的是：这个 <code>r.packageInfo</code> 到底是从哪里获取的？</p>
<p>我们顺着 performLaunchActivity上溯，辗转handleLaunchActivity回到了 <code>H</code> 类的LAUNCH_ACTIVITY消息，找到了<code>r.packageInfo</code>的来源：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">final ActivityClientRecord r &#x3D; (ActivityClientRecord) msg.obj;  </span><br><span class="line">r.packageInfo &#x3D; getPackageInfoNoCheck(  </span><br><span class="line"> r.activityInfo.applicationInfo, r.compatInfo);  </span><br><span class="line">handleLaunchActivity(r, null);</span><br></pre></td></tr></table></figure>
<p>getPackageInfoNoCheck方法很简单，直接调用了getPackageInfo方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public final LoadedApk getPackageInfoNoCheck(ApplicationInfo ai,  </span><br><span class="line"> CompatibilityInfo compatInfo) &#123;  </span><br><span class="line"> return getPackageInfo(ai, compatInfo, null, false, true, false);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个getPackageInfo方法里面我们发现了端倪：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">private LoadedApk getPackageInfo(ApplicationInfo aInfo, CompatibilityInfo compatInfo,  </span><br><span class="line"> ClassLoader baseLoader, boolean securityViolation, boolean includeCode,  </span><br><span class="line"> boolean registerPackage) &#123;  </span><br><span class="line"> &#x2F;&#x2F; 获取userid信息  </span><br><span class="line"> final boolean differentUser &#x3D; (UserHandle.myUserId() !&#x3D; UserHandle.getUserId(aInfo.uid));  </span><br><span class="line"> synchronized (mResourcesManager) &#123;  </span><br><span class="line"> &#x2F;&#x2F; 尝试获取缓存信息  </span><br><span class="line"> WeakReference&lt;LoadedApk&gt; ref;  </span><br><span class="line"> if (differentUser) &#123;  </span><br><span class="line"> &#x2F;&#x2F; Caching not supported across users  </span><br><span class="line"> ref &#x3D; null;  </span><br><span class="line"> &#125; else if (includeCode) &#123;  </span><br><span class="line"> ref &#x3D; mPackages.get(aInfo.packageName);  </span><br><span class="line"> &#125; else &#123;  </span><br><span class="line"> ref &#x3D; mResourcePackages.get(aInfo.packageName);  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line"> LoadedApk packageInfo &#x3D; ref !&#x3D; null ? ref.get() : null;  </span><br><span class="line"> if (packageInfo &#x3D;&#x3D; null || (packageInfo.mResources !&#x3D; null  </span><br><span class="line"> &amp;&amp; !packageInfo.mResources.getAssets().isUpToDate())) &#123;  </span><br><span class="line"> &#x2F;&#x2F; 缓存没有命中，直接new  </span><br><span class="line"> packageInfo &#x3D;  </span><br><span class="line"> new LoadedApk(this, aInfo, compatInfo, baseLoader,  </span><br><span class="line"> securityViolation, includeCode &amp;&amp;  </span><br><span class="line"> (aInfo.flags&amp;ApplicationInfo.FLAG\_HAS\_CODE) !&#x3D; 0, registerPackage);  </span><br><span class="line">  </span><br><span class="line"> &#x2F;&#x2F; 省略。。更新缓存  </span><br><span class="line"> return packageInfo;  </span><br><span class="line"> &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法很重要，我们必须弄清楚每一步；</p>
<p>首先，它判断了调用方和或许App信息的一方是不是同一个userId；如果是同一个user，那么可以共享缓存数据（要么缓存的代码数据，要么缓存的资源数据）</p>
<p>接下来尝试获取缓存数据；如果没有命中缓存数据，才通过LoadedApk的构造函数创建了LoadedApk对象；创建成功之后，如果是同一个uid还放入了缓存。</p>
<p>提到缓存数据，看过<a href="http://weishu.me/2016/02/16/understand-plugin-framework-binder-hook/" target="_blank" rel="noopener">Hook机制之Binder Hook</a>的童鞋可能就知道了，我们之前成功借助ServiceManager的本地代理使用缓存的机制Hook了各种Binder；因此这里完全可以如法炮制——我们拿到这一份缓存数据，修改里面的ClassLoader；自己控制类加载的过程，这样加载插件中的Activity类的问题就解决了。这就引出了我们加载插件类的第一种方案：</p>
<h2 id="激进方案：Hook掉ClassLoader，自己操刀"><a href="#激进方案：Hook掉ClassLoader，自己操刀" class="headerlink" title="激进方案：Hook掉ClassLoader，自己操刀"></a>激进方案：Hook掉ClassLoader，自己操刀</h2><p>从上述分析中我们得知，在获取LoadedApk的过程中使用了一份缓存数据；这个缓存数据是一个<code>Map</code>，从包名到LoadedApk的一个映射。正常情况下，我们的插件肯定不会存在于这个对象里面；但是<strong>如果我们手动把我们插件的信息添加到里面呢？</strong>系统在查找缓存的过程中，会直接命中缓存！进而使用我们添加进去的LoadedApk的ClassLoader来加载这个特定的Activity类！这样我们就能接管我们自己插件类的加载过程了！</p>
<p>这个缓存对象<code>mPackages</code>存在于ActivityThread类中；老方法，我们首先获取这个对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 先获取到当前的ActivityThread对象  </span><br><span class="line">Class&lt;?&gt; activityThreadClass &#x3D; Class.forName(&quot;android.app.ActivityThread&quot;);  </span><br><span class="line">Method currentActivityThreadMethod &#x3D; activityThreadClass.getDeclaredMethod(&quot;currentActivityThread&quot;);  </span><br><span class="line">currentActivityThreadMethod.setAccessible(true);  </span><br><span class="line">Object currentActivityThread &#x3D; currentActivityThreadMethod.invoke(null);  </span><br><span class="line">  </span><br><span class="line">&#x2F;&#x2F; 获取到 mPackages 这个静态成员变量, 这里缓存了dex包的信息  </span><br><span class="line">Field mPackagesField &#x3D; activityThreadClass.getDeclaredField(&quot;mPackages&quot;);  </span><br><span class="line">mPackagesField.setAccessible(true);  </span><br><span class="line">Map mPackages &#x3D; (Map) mPackagesField.get(currentActivityThread);</span><br></pre></td></tr></table></figure>
<p>拿到这个Map之后接下来怎么办呢？<strong>我们需要填充这个map，把插件的信息塞进这个map里面</strong>，以便系统在查找的时候能命中缓存。但是这个填充这个Map我们出了需要包名之外，还需要一个LoadedApk对象；如何创建一个LoadedApk对象呢？</p>
<p>我们当然可以直接反射调用它的构造函数直接创建出需要的对象，但是万一哪里有疏漏，构造参数填错了怎么办？又或者Android的不同版本使用了不同的参数，导致我们创建出来的对象与系统创建出的对象不一致，无法work怎么办？</p>
<p>因此我们需要使用与系统完全相同的方式创建LoadedApk对象；从上文分析得知，系统创建LoadedApk对象是通过<code>getPackageInfo</code>来完成的，因此我们可以调用这个函数来创建LoadedApk对象；但是这个函数是<code>private</code>的，我们无法使用。</p>
<p>有的童鞋可能会有疑问了，<code>private</code>不是也能反射到吗？我们确实能够调用这个函数，但是<code>private</code>表明这个函数是内部实现，或许那一天Google高兴，把这个函数改个名字我们就直接GG了；但是public函数不同，public被导出的函数你无法保证是否有别人调用它，因此大部分情况下不会修改；我们最好调用public函数来保证尽可能少的遇到兼容性问题。（当然，如果实在木有路可以考虑调用私有方法，自己处理兼容性问题，这个我们以后也会遇到）</p>
<p>间接调用<code>getPackageInfo</code>这个私有函数的public函数有同名的getPackageInfo系列和getPackageInfoNoCheck；简单查看源代码发现，getPackageInfo除了获取包的信息，还检查了包的一些组件；为了绕过这些验证，我们选择使用<code>getPackageInfoNoCheck</code>获取LoadedApk信息。</p>
<h3 id="构建插件LoadedApk对象"><a href="#构建插件LoadedApk对象" class="headerlink" title="构建插件LoadedApk对象"></a>构建插件LoadedApk对象</h3><p>我们这一步的目的很明确，通过getPackageInfoNoCheck函数创建出我们需要的LoadedApk对象，以供接下来使用。</p>
<p>这个函数的签名如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public final LoadedApk getPackageInfoNoCheck(ApplicationInfo ai,  </span><br><span class="line"> CompatibilityInfo compatInfo) &#123;</span><br></pre></td></tr></table></figure>
<p>因此，为了调用这个函数，我们需要构造两个参数。其一是ApplicationInfo，其二是CompatibilityInfo；第二个参数顾名思义，代表这个App的兼容性信息，比如targetSDK版本等等，这里我们只需要提取出app的信息，因此直接使用默认的兼容性即可；在CompatibilityInfo类里面有一个公有字段DEFAULT_COMPATIBILITY_INFO代表默认兼容性信息；因此，我们的首要目标是获取这个ApplicationInfo信息。</p>
<h3 id="构建插件ApplicationInfo信息"><a href="#构建插件ApplicationInfo信息" class="headerlink" title="构建插件ApplicationInfo信息"></a>构建插件ApplicationInfo信息</h3><p>我们首先看看ApplicationInfo代表什么，这个类的文档说的很清楚：</p>
<blockquote>
<p>Information you can retrieve about a particular application. This corresponds to information collected from the AndroidManifest.xml’s <application> tag.</p>
</blockquote>
<p>也就是说，这个类就是AndroidManifest.xml里面的 这个标签下面的信息；这个AndroidManifest.xml无疑是一个标准的xml文件，因此我们完全可以自己使用parse来解析这个信息。</p>
<p>那么，系统是如何获取这个信息的呢？其实Framework就有一个这样的parser，也即PackageParser；理论上，我们也可以借用系统的parser来解析AndroidMAnifest.xml从而得到ApplicationInfo的信息。但遗憾的是，<strong>这个类的兼容性很差</strong>；Google几乎在每一个Android版本都对这个类动刀子，如果坚持使用系统的解析方式，必须写一系列兼容行代码！！DroidPlugin就选择了这种方式，相关类如下：</p>
<p><a href="http://7xp3xc.com1.z0.glb.clouddn.com/201601/1459829051777.png" target="_blank" rel="noopener" title="DroidPlugin的PackageParser"><img src="http://7xp3xc.com1.z0.glb.clouddn.com/201601/1459829051777.png" alt="DroidPlugin的PackageParser"></a></p>
<p><a href="http://7xp3xc.com1.z0.glb.clouddn.com/201601/1459829051777.png" target="_blank" rel="noopener" title="DroidPlugin的PackageParser">DroidPlugin的PackageParser</a></p>
<p>看到这里我就问你怕不怕！！！这也是我们之前提到的<strong>私有或者隐藏的API可以使用，但必须处理好兼容性问题</strong>；如果Android 7.0发布，这里估计得添加一个新的类PackageParseApi24。</p>
<p>我这里使用API 23作为演示，<strong>版本不同的可能无法运行</strong>请自行查阅 DroidPlugin 不同版本如何处理。</p>
<p>OK回到正题，我们决定使用PackageParser类来提取ApplicationInfo信息。下图是API 23上，PackageParser的部分类结构图：</p>
<p><a href="http://7xp3xc.com1.z0.glb.clouddn.com/201601/1459829674687.png" target="_blank" rel="noopener"><img src="http://7xp3xc.com1.z0.glb.clouddn.com/201601/1459829674687.png" alt=""></a></p>
<p>看起来有我们需要的方法 generateApplication；确实如此，依靠这个方法我们可以成功地拿到ApplicationInfo。<br>由于PackageParser是@hide的，因此我们需要通过反射进行调用。我们根据这个generateApplicationInfo方法的签名：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public static ApplicationInfo generateApplicationInfo(Package p, int flags,  </span><br><span class="line"> PackageUserState state)</span><br></pre></td></tr></table></figure>
<p>可以写出调用generateApplicationInfo的反射代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; packageParserClass &#x3D; Class.forName(&quot;android.content.pm.PackageParser&quot;);  </span><br><span class="line">&#x2F;&#x2F; 首先拿到我们得终极目标: generateApplicationInfo方法  </span><br><span class="line">&#x2F;&#x2F; API 23 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  </span><br><span class="line">&#x2F;&#x2F; public static ApplicationInfo generateApplicationInfo(Package p, int flags,  </span><br><span class="line">&#x2F;&#x2F;    PackageUserState state) &#123;  </span><br><span class="line">&#x2F;&#x2F; 其他Android版本不保证也是如此.  </span><br><span class="line">Class&lt;?&gt; packageParser$PackageClass &#x3D; Class.forName(&quot;android.content.pm.PackageParser$Package&quot;);  </span><br><span class="line">Class&lt;?&gt; packageUserStateClass &#x3D; Class.forName(&quot;android.content.pm.PackageUserState&quot;);  </span><br><span class="line">Method generateApplicationInfoMethod &#x3D; packageParserClass.getDeclaredMethod(&quot;generateApplicationInfo&quot;,  </span><br><span class="line"> packageParser$PackageClass,  </span><br><span class="line"> int.class,  </span><br><span class="line"> packageUserStateClass);</span><br></pre></td></tr></table></figure>
<p>要成功调用这个方法，还需要三个参数；因此接下来我们需要一步一步构建调用此函数的参数信息。</p>
<h4 id="构建PackageParser-Package"><a href="#构建PackageParser-Package" class="headerlink" title="构建PackageParser.Package"></a>构建PackageParser.Package</h4><p>generateApplicationInfo方法需要的第一个参数是PackageParser.Package；从名字上看这个类代表某个apk包的信息，我们看看文档怎么解释：</p>
<blockquote>
<p>Representation of a full package parsed from APK files on disk. A package consists of a single base APK, and zero or more split APKs.</p>
</blockquote>
<p>果然，这个类代表从PackageParser中解析得到的某个apk包的信息，是磁盘上apk文件在内存中的数据结构表示；因此，要获取这个类，肯定需要解析整个apk文件。PackageParser中解析apk的核心方法是parsePackage，这个方法返回的就是一个Package类型的实例，因此我们调用这个方法即可；使用反射代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 首先, 我们得创建出一个Package对象出来供这个方法调用  </span><br><span class="line">&#x2F;&#x2F; 而这个需要得对象可以通过 android.content.pm.PackageParser#parsePackage 这个方法返回得 Package对象得字段获取得到  </span><br><span class="line">&#x2F;&#x2F; 创建出一个PackageParser对象供使用  </span><br><span class="line">Object packageParser &#x3D; packageParserClass.newInstance();  </span><br><span class="line">&#x2F;&#x2F; 调用 PackageParser.parsePackage 解析apk的信息  </span><br><span class="line">Method parsePackageMethod &#x3D; packageParserClass.getDeclaredMethod(&quot;parsePackage&quot;, File.class, int.class);  </span><br><span class="line">  </span><br><span class="line">&#x2F;&#x2F; 实际上是一个 android.content.pm.PackageParser.Package 对象  </span><br><span class="line">Object packageObj &#x3D; parsePackageMethod.invoke(packageParser, apkFile, 0);</span><br></pre></td></tr></table></figure>
<p>这样，我们就得到了generateApplicationInfo的第一个参数；第二个参数是解析包使用的flag，我们直接选择解析全部信息，也就是0；</p>
<h4 id="构建PackageUserState"><a href="#构建PackageUserState" class="headerlink" title="构建PackageUserState"></a>构建PackageUserState</h4><p>第三个参数是PackageUserState，代表不同用户中包的信息。由于Android是一个多任务多用户系统，因此不同的用户同一个包可能有不同的状态；这里我们只需要获取包的信息，因此直接使用默认的即可；</p>
<p>至此，generateApplicaionInfo的参数我们已经全部构造完成，直接调用此方法即可得到我们需要的applicationInfo对象；在返回之前我们需要做一点小小的修改：使用系统系统的这个方法解析得到的ApplicationInfo对象中并没有apk文件本身的信息，所以我们把解析的apk文件的路径设置一下（ClassLoader依赖dex文件以及apk的路径）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 第三个参数 mDefaultPackageUserState 我们直接使用默认构造函数构造一个出来即可  </span><br><span class="line">Object defaultPackageUserState &#x3D; packageUserStateClass.newInstance();  </span><br><span class="line">  </span><br><span class="line">&#x2F;&#x2F; 万事具备!!!!!!!!!!!!!!  </span><br><span class="line">ApplicationInfo applicationInfo &#x3D; (ApplicationInfo) generateApplicationInfoMethod.invoke(packageParser,  </span><br><span class="line"> packageObj, 0, defaultPackageUserState);  </span><br><span class="line">String apkPath &#x3D; apkFile.getPath();  </span><br><span class="line">applicationInfo.sourceDir &#x3D; apkPath;  </span><br><span class="line">applicationInfo.publicSourceDir &#x3D; apkPath;</span><br></pre></td></tr></table></figure>

<h3 id="替换ClassLoader"><a href="#替换ClassLoader" class="headerlink" title="替换ClassLoader"></a>替换ClassLoader</h3><h4 id="获取LoadedApk信息"><a href="#获取LoadedApk信息" class="headerlink" title="获取LoadedApk信息"></a>获取LoadedApk信息</h4><p>方才为了获取ApplicationInfo我们费了好大一番精力；回顾一下我们的初衷：</p>
<p>我们最终的目的是调用getPackageInfoNoCheck得到LoadedApk的信息，并替换其中的mClassLoader然后把把添加到ActivityThread的mPackages缓存中；从而达到我们使用自己的ClassLoader加载插件中的类的目的。</p>
<p>现在我们已经拿到了getPackageInfoNoCheck这个方法中至关重要的第一个参数applicationInfo；上文提到第二个参数CompatibilityInfo代表设备兼容性信息，直接使用默认的值即可；因此，两个参数都已经构造出来，我们可以调用getPackageInfoNoCheck获取LoadedApk：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; android.content.res.CompatibilityInfo  </span><br><span class="line">Class&lt;?&gt; compatibilityInfoClass &#x3D; Class.forName(&quot;android.content.res.CompatibilityInfo&quot;);  </span><br><span class="line">Method getPackageInfoNoCheckMethod &#x3D; activityThreadClass.getDeclaredMethod(&quot;getPackageInfoNoCheck&quot;, ApplicationInfo.class, compatibilityInfoClass);  </span><br><span class="line">  </span><br><span class="line">Field defaultCompatibilityInfoField &#x3D; compatibilityInfoClass.getDeclaredField(&quot;DEFAULT\_COMPATIBILITY\_INFO&quot;);  </span><br><span class="line">defaultCompatibilityInfoField.setAccessible(true);  </span><br><span class="line">  </span><br><span class="line">Object defaultCompatibilityInfo &#x3D; defaultCompatibilityInfoField.get(null);  </span><br><span class="line">ApplicationInfo applicationInfo &#x3D; generateApplicationInfo(apkFile);  </span><br><span class="line">  </span><br><span class="line">Object loadedApk &#x3D; getPackageInfoNoCheckMethod.invoke(currentActivityThread, applicationInfo, defaultCompatibilityInfo);</span><br></pre></td></tr></table></figure>
<p>我们成功地构造出了LoadedAPK, 接下来我们需要替换其中的ClassLoader，然后把它添加进ActivityThread的mPackages中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String odexPath &#x3D; Utils.getPluginOptDexDir(applicationInfo.packageName).getPath();  </span><br><span class="line">String libDir &#x3D; Utils.getPluginLibDir(applicationInfo.packageName).getPath();  </span><br><span class="line">ClassLoader classLoader &#x3D; new CustomClassLoader(apkFile.getPath(), odexPath, libDir, ClassLoader.getSystemClassLoader());  </span><br><span class="line">Field mClassLoaderField &#x3D; loadedApk.getClass().getDeclaredField(&quot;mClassLoader&quot;);  </span><br><span class="line">mClassLoaderField.setAccessible(true);  </span><br><span class="line">mClassLoaderField.set(loadedApk, classLoader);  </span><br><span class="line">&#x2F;&#x2F; 由于是弱引用, 因此我们必须在某个地方存一份, 不然容易被GC; 那么就前功尽弃了.  </span><br><span class="line">sLoadedApk.put(applicationInfo.packageName, loadedApk);  </span><br><span class="line">  </span><br><span class="line">WeakReference weakReference &#x3D; new WeakReference(loadedApk);  </span><br><span class="line">mPackages.put(applicationInfo.packageName, weakReference);</span><br></pre></td></tr></table></figure>
<p>我们的这个CustomClassLoader非常简单，直接继承了DexClassLoader，什么都没有做；当然这里可以直接使用DexClassLoader，这里重新创建一个类是为了更有区分度；以后也可以通过修改这个类实现对于类加载的控制：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class CustomClassLoader extends DexClassLoader &#123;  </span><br><span class="line">  </span><br><span class="line"> public CustomClassLoader(String dexPath, String optimizedDirectory, String libraryPath, ClassLoader parent) &#123;  </span><br><span class="line"> super(dexPath, optimizedDirectory, libraryPath, parent);  </span><br><span class="line"> &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到这里，我们已经成功地把把插件的信息放入ActivityThread中，这样我们插件中的类能够成功地被加载；因此插件中的Activity实例能被成功第创建；由于整个流程较为复杂，我们简单梳理一下：</p>
<ol>
<li>在ActivityThread接收到IApplication的 scheduleLaunchActivity远程调用之后，将消息转发给<code>H</code></li>
<li><code>H</code>类在handleMessage的时候，调用了getPackageInfoNoCheck方法来获取待启动的组件信息。在这个方法中会优先查找<code>mPackages</code>中的缓存信息，而我们已经手动把插件信息添加进去；因此能够成功命中缓存，获取到独立存在的插件信息。</li>
<li><code>H</code>类然后调用handleLaunchActivity最终转发到performLaunchActivity方法；这个方法使用从getPackageInfoNoCheck中拿到LoadedApk中的mClassLoader来加载Activity类，进而使用反射创建Activity实例；接着创建Application，Context等完成Activity组件的启动。</li>
</ol>
<p>看起来好像已经天衣无缝万事大吉了；但是运行一下会出现一个异常，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">04-05 02:49:53.742  11759-11759&#x2F;com.weishu.upf.hook_classloader E&#x2F;AndroidRuntime﹕ FATAL EXCEPTION: main  </span><br><span class="line"> Process: com.weishu.upf.hook_classloader, PID: 11759  </span><br><span class="line"> java.lang.RuntimeException: Unable to start activity ComponentInfo&#123;com.weishu.upf.ams\_pms\_hook.app&#x2F;com.weishu.upf.ams\_pms\_hook.app.MainActivity&#125;: java.lang.RuntimeException: Unable to instantiate application android.app.Application: java.lang.IllegalStateException: Unable to get package info for com.weishu.upf.ams\_pms\_hook.app; is package not installed?</span><br></pre></td></tr></table></figure>

<p>错误提示说是无法实例化 <code>Application</code>，而Application的创建也是在performLaunchActivity中进行的，这里有些蹊跷，我们仔细查看一下。</p>
<h4 id="绕过系统检查"><a href="#绕过系统检查" class="headerlink" title="绕过系统检查"></a>绕过系统检查</h4><p>通过ActivityThread的performLaunchActivity方法可以得知，Application通过LoadedApk的makeApplication方法创建，我们查看这个方法，在源码中发现了上文异常抛出的位置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">try &#123;  </span><br><span class="line"> java.lang.ClassLoader cl &#x3D; getClassLoader();  </span><br><span class="line"> if (!mPackageName.equals(&quot;android&quot;)) &#123;  </span><br><span class="line"> initializeJavaContextClassLoader();  </span><br><span class="line"> &#125;  </span><br><span class="line"> ContextImpl appContext &#x3D; ContextImpl.createAppContext(mActivityThread, this);  </span><br><span class="line"> app &#x3D; mActivityThread.mInstrumentation.newApplication(  </span><br><span class="line"> cl, appClass, appContext);  </span><br><span class="line"> appContext.setOuterContext(app);  </span><br><span class="line">&#125; catch (Exception e) &#123;  </span><br><span class="line"> if (!mActivityThread.mInstrumentation.onException(app, e)) &#123;  </span><br><span class="line"> throw new RuntimeException(  </span><br><span class="line"> &quot;Unable to instantiate application &quot; \+ appClass  </span><br><span class="line"> \+ &quot;: &quot; \+ e.toString(), e);  </span><br><span class="line"> &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>木有办法，我们只有一行一行地查看到底是哪里抛出这个异常的了；所幸代码不多。（所以说，缩小异常范围是一件多么重要的事情！！！）</p>
<p>第一句 getClassLoader() 没什么可疑的，虽然方法很长，但是它木有抛出任何异常（当然，它调用的代码可能抛出异常，万一找不到只能进一步深搜了；所以我觉得这里应该使用受检异常）。</p>
<p>然后我们看第二句，如果包名不是<code>android</code>开头，那么调用了一个叫做initializeJavaContextClassLoader的方法；我们查阅这个方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">private void initializeJavaContextClassLoader() &#123;  </span><br><span class="line"> IPackageManager pm &#x3D; ActivityThread.getPackageManager();  </span><br><span class="line"> android.content.pm.PackageInfo pi;  </span><br><span class="line"> try &#123;  </span><br><span class="line"> pi &#x3D; pm.getPackageInfo(mPackageName, 0, UserHandle.myUserId());  </span><br><span class="line"> &#125; catch (RemoteException e) &#123;  </span><br><span class="line"> throw new IllegalStateException(&quot;Unable to get package info for &quot;  </span><br><span class="line"> \+ mPackageName + &quot;; is system dying?&quot;, e);  </span><br><span class="line"> &#125;  </span><br><span class="line"> if (pi &#x3D;&#x3D; null) &#123;  </span><br><span class="line"> throw new IllegalStateException(&quot;Unable to get package info for &quot;  </span><br><span class="line"> \+ mPackageName + &quot;; is package not installed?&quot;);  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line"> boolean sharedUserIdSet &#x3D; (pi.sharedUserId !&#x3D; null);  </span><br><span class="line"> boolean processNameNotDefault &#x3D;  </span><br><span class="line"> (pi.applicationInfo !&#x3D; null &amp;&amp;  </span><br><span class="line"> !mPackageName.equals(pi.applicationInfo.processName));  </span><br><span class="line"> boolean sharable &#x3D; (sharedUserIdSet || processNameNotDefault);  </span><br><span class="line"> ClassLoader contextClassLoader &#x3D;  </span><br><span class="line"> (sharable)  </span><br><span class="line"> ? new WarningContextClassLoader()  </span><br><span class="line"> : mClassLoader;  </span><br><span class="line"> Thread.currentThread().setContextClassLoader(contextClassLoader);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里，我们找出了这个异常的来源：原来这里调用了<code>getPackageInfo</code>方法获取包的信息；而我们的插件<strong>并没有安装在系统上</strong>，因此系统肯定认为插件没有安装，这个方法肯定返回null。所以，我们还要欺骗一下PMS，让系统觉得<strong>插件已经安装在系统上了</strong>；至于如何欺骗 PMS，<a href="http://weishu.me/2016/03/07/understand-plugin-framework-ams-pms-hook/" target="_blank" rel="noopener">Hook机制之AMS&amp;PMS</a> 有详细解释，这里直接给出代码，不赘述了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">private static void hookPackageManager() throws Exception &#123;  </span><br><span class="line">  </span><br><span class="line"> &#x2F;&#x2F; 这一步是因为 initializeJavaContextClassLoader 这个方法内部无意中检查了这个包是否在系统安装  </span><br><span class="line"> &#x2F;&#x2F; 如果没有安装, 直接抛出异常, 这里需要临时Hook掉 PMS, 绕过这个检查.  </span><br><span class="line">  </span><br><span class="line"> Class&lt;?&gt; activityThreadClass &#x3D; Class.forName(&quot;android.app.ActivityThread&quot;);  </span><br><span class="line"> Method currentActivityThreadMethod &#x3D; activityThreadClass.getDeclaredMethod(&quot;currentActivityThread&quot;);  </span><br><span class="line"> currentActivityThreadMethod.setAccessible(true);  </span><br><span class="line"> Object currentActivityThread &#x3D; currentActivityThreadMethod.invoke(null);  </span><br><span class="line">  </span><br><span class="line"> &#x2F;&#x2F; 获取ActivityThread里面原始的 sPackageManager  </span><br><span class="line"> Field sPackageManagerField &#x3D; activityThreadClass.getDeclaredField(&quot;sPackageManager&quot;);  </span><br><span class="line"> sPackageManagerField.setAccessible(true);  </span><br><span class="line"> Object sPackageManager &#x3D; sPackageManagerField.get(currentActivityThread);  </span><br><span class="line">  </span><br><span class="line"> &#x2F;&#x2F; 准备好代理对象, 用来替换原始的对象  </span><br><span class="line"> Class&lt;?&gt; iPackageManagerInterface &#x3D; Class.forName(&quot;android.content.pm.IPackageManager&quot;);  </span><br><span class="line"> Object proxy &#x3D; Proxy.newProxyInstance(iPackageManagerInterface.getClassLoader(),  </span><br><span class="line"> new Class&lt;?&gt;\[\] &#123; iPackageManagerInterface &#125;,  </span><br><span class="line"> new IPackageManagerHookHandler(sPackageManager));  </span><br><span class="line">  </span><br><span class="line"> &#x2F;&#x2F; 1\. 替换掉ActivityThread里面的 sPackageManager 字段  </span><br><span class="line"> sPackageManagerField.set(currentActivityThread, proxy);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>OK到这里，我们已经能够成功地加载<strong>简单的</strong>独立的存在于外部文件系统中的apk了。至此 关于 DroidPlugin 对于Activity生命周期的管理已经完全讲解完毕了；这是一种极其复杂的Activity管理方案，我们仅仅写一个用来理解的demo就Hook了相当多的东西，在Framework层来回牵扯；这其中的来龙去脉要完全把握清楚还请读者亲自翻阅源码。另外，我在此 对DroidPlugin 作者献上我的膝盖～这其中的玄妙让人叹为观止！</p>
<p>上文给出的方案中，我们全盘接管了插件中类的加载过程，这是一种相对暴力的解决方案；能不能更温柔一点呢？通俗来说，我们可以选择改革，而不是革命——告诉系统ClassLoader一些必要信息，让它帮忙完成插件类的加载。</p>
<h2 id="保守方案：委托系统，让系统帮忙加载"><a href="#保守方案：委托系统，让系统帮忙加载" class="headerlink" title="保守方案：委托系统，让系统帮忙加载"></a>保守方案：委托系统，让系统帮忙加载</h2><p>我们再次搬出ActivityThread中加载Activity类的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">java.lang.ClassLoader cl &#x3D; r.packageInfo.getClassLoader();  </span><br><span class="line">activity &#x3D; mInstrumentation.newActivity(  </span><br><span class="line"> cl, component.getClassName(), r.intent);  </span><br><span class="line">StrictMode.incrementExpectedActivityCount(activity.getClass());  </span><br><span class="line">r.intent.setExtrasClassLoader(cl);</span><br></pre></td></tr></table></figure>
<p>我们知道 这个r.packageInfo中的<code>r</code>是通过getPackageInfoNoCheck获取到的；在『激进方案』中我们把插件apk手动添加进缓存，采用自己加载办法解决；如果我们不干预这个过程，导致无法命中mPackages中的缓存，会发生什么？</p>
<p>查阅 getPackageInfo方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">private LoadedApk getPackageInfo(ApplicationInfo aInfo, CompatibilityInfo compatInfo,  </span><br><span class="line"> ClassLoader baseLoader, boolean securityViolation, boolean includeCode,  </span><br><span class="line"> boolean registerPackage) &#123;  </span><br><span class="line"> final boolean differentUser &#x3D; (UserHandle.myUserId() !&#x3D; UserHandle.getUserId(aInfo.uid));  </span><br><span class="line"> synchronized (mResourcesManager) &#123;  </span><br><span class="line"> WeakReference&lt;LoadedApk&gt; ref;  </span><br><span class="line"> if (differentUser) &#123;  </span><br><span class="line"> &#x2F;&#x2F; Caching not supported across users  </span><br><span class="line"> ref &#x3D; null;  </span><br><span class="line"> &#125; else if (includeCode) &#123;  </span><br><span class="line"> ref &#x3D; mPackages.get(aInfo.packageName);  </span><br><span class="line"> &#125; else &#123;  </span><br><span class="line"> ref &#x3D; mResourcePackages.get(aInfo.packageName);  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line"> LoadedApk packageInfo &#x3D; ref !&#x3D; null ? ref.get() : null;  </span><br><span class="line"> if (packageInfo &#x3D;&#x3D; null || (packageInfo.mResources !&#x3D; null  </span><br><span class="line"> &amp;&amp; !packageInfo.mResources.getAssets().isUpToDate())) &#123;  </span><br><span class="line"> packageInfo &#x3D;  </span><br><span class="line"> new LoadedApk(this, aInfo, compatInfo, baseLoader,  </span><br><span class="line"> securityViolation, includeCode &amp;&amp;  </span><br><span class="line"> (aInfo.flags&amp;ApplicationInfo.FLAG\_HAS\_CODE) !&#x3D; 0, registerPackage);  </span><br><span class="line">  </span><br><span class="line"> &#x2F;&#x2F; 略  </span><br><span class="line"> &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，没有命中缓存的情况下，系统直接new了一个LoadedApk；注意这个构造函数的第二个参数<code>aInfo</code>，这是一个ApplicationInfo类型的对象。在『激进方案』中我们为了获取独立插件的ApplicationInfo花了不少心思；那么如果不做任何处理这里传入的这个<code>aInfo</code>参数是什么？</p>
<p>追本溯源不难发现，这个aInfo是从我们的替身StubActivity中获取的！而StubActivity存在于宿主程序中，所以，这个<code>aInfo</code>对象代表的实际上就是宿主程序的Application信息！</p>
<p>我们知道，接下来会使用new出来的这个LoadedApk的getClassLoader()方法获取到ClassLoader来对插件的类进行加载；而获取到的这个ClassLoader是宿主程序使用的ClassLoader，因此现在还无法加载插件的类；那么，<strong>我们能不能让宿主的ClasLoader获得加载插件类的能力呢？</strong>；如果我们告诉宿主使用的ClassLoader插件使用的类在哪里，就能帮助他完成加载！</p>
<h3 id="宿主的ClassLoader在哪里，是唯一的吗？"><a href="#宿主的ClassLoader在哪里，是唯一的吗？" class="headerlink" title="宿主的ClassLoader在哪里，是唯一的吗？"></a>宿主的ClassLoader在哪里，是唯一的吗？</h3><p>上面说到，我们可以通过告诉宿主程序的ClassLoader插件使用的类，让宿主的ClasLoader完成对于插件类的加载；那么问题来了，我们如何获取到宿主的ClassLoader？宿主程序使用的ClasLoader默认情况下是全局唯一的吗？</p>
<p>答案是肯定的。</p>
<p>因为在FrameWork中宿主程序也是使用LoadedApk表示的，如同Activity启动是加载Activity类一样，宿主中的类也都是通过LoadedApk的getClassLoader()方法得到的ClassLoader加载的；由类加载机制的『双亲委派』特性，只要有一个应用程序类由某一个ClassLoader加载，那么它引用到的别的类除非父加载器能加载，否则都是由这同一个加载器加载的（不遵循双亲委派模型的除外）。</p>
<p>表示宿主的LoadedApk在Application类中有一个成员变量<code>mLoadedApk</code>，而这个变量是从ContextImpl中获取的；ContextImpl重写了getClassLoader方法，因此<strong>我们在Context环境中直接getClassLoader()获取到的就是宿主程序唯一的ClassLoader</strong>。</p>
<h3 id="LoadedApk的ClassLoader到底是什么？"><a href="#LoadedApk的ClassLoader到底是什么？" class="headerlink" title="LoadedApk的ClassLoader到底是什么？"></a>LoadedApk的ClassLoader到底是什么？</h3><p>现在我们确保了『使用宿主ClassLoader帮助加载插件类』可行性；那么我们应该如何完成这个过程呢？</p>
<p>知己知彼，百战不殆。</p>
<p>不论是宿主程序还是插件程序都是通过LoadedApk的getClassLoader()方法返回的ClassLoader进行类加载的，返回的这个ClassLoader到底是个什么东西？？这个方法源码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public ClassLoader getClassLoader() &#123;  </span><br><span class="line"> synchronized (this) &#123;  </span><br><span class="line"> if (mClassLoader !&#x3D; null) &#123;  </span><br><span class="line"> return mClassLoader;  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line"> if (mIncludeCode &amp;&amp; !mPackageName.equals(&quot;android&quot;)) &#123;  </span><br><span class="line"> &#x2F;&#x2F; 略...  </span><br><span class="line"> mClassLoader &#x3D; ApplicationLoaders.getDefault().getClassLoader(zip, lib,  </span><br><span class="line"> mBaseClassLoader);  </span><br><span class="line">  </span><br><span class="line"> StrictMode.setThreadPolicy(oldPolicy);  </span><br><span class="line"> &#125; else &#123;  </span><br><span class="line"> if (mBaseClassLoader &#x3D;&#x3D; null) &#123;  </span><br><span class="line"> mClassLoader &#x3D; ClassLoader.getSystemClassLoader();  </span><br><span class="line"> &#125; else &#123;  </span><br><span class="line"> mClassLoader &#x3D; mBaseClassLoader;  </span><br><span class="line"> &#125;  </span><br><span class="line"> &#125;  </span><br><span class="line"> return mClassLoader;  </span><br><span class="line"> &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，非<code>android</code>开头的包和<code>android</code>开头的包分别使用了两种不同的ClassLoader，我们只关心第一种；因此继续跟踪ApplicationLoaders类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public ClassLoader getClassLoader(String zip, String libPath, ClassLoader parent)  </span><br><span class="line">&#123;  </span><br><span class="line">  </span><br><span class="line"> ClassLoader baseParent &#x3D; ClassLoader.getSystemClassLoader().getParent();  </span><br><span class="line">  </span><br><span class="line"> synchronized (mLoaders) &#123;  </span><br><span class="line"> if (parent &#x3D;&#x3D; null) &#123;  </span><br><span class="line"> parent &#x3D; baseParent;  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line"> if (parent &#x3D;&#x3D; baseParent) &#123;  </span><br><span class="line"> ClassLoader loader &#x3D; mLoaders.get(zip);  </span><br><span class="line"> if (loader !&#x3D; null) &#123;  </span><br><span class="line"> return loader;  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line"> Trace.traceBegin(Trace.TRACE\_TAG\_ACTIVITY_MANAGER, zip);  </span><br><span class="line"> PathClassLoader pathClassloader &#x3D;  </span><br><span class="line"> new PathClassLoader(zip, libPath, parent);  </span><br><span class="line"> Trace.traceEnd(Trace.TRACE\_TAG\_ACTIVITY_MANAGER);  </span><br><span class="line">  </span><br><span class="line"> mLoaders.put(zip, pathClassloader);  </span><br><span class="line"> return pathClassloader;  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line"> Trace.traceBegin(Trace.TRACE\_TAG\_ACTIVITY_MANAGER, zip);  </span><br><span class="line"> PathClassLoader pathClassloader &#x3D; new PathClassLoader(zip, parent);  </span><br><span class="line"> Trace.traceEnd(Trace.TRACE\_TAG\_ACTIVITY_MANAGER);  </span><br><span class="line"> return pathClassloader;  </span><br><span class="line"> &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，应用程序使用的ClassLoader都是PathClassLoader类的实例。那么，这个PathClassLoader是什么呢？从Android SDK给出的源码只能看出这么多：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class PathClassLoader extends BaseDexClassLoader &#123;  </span><br><span class="line"> public PathClassLoader(String dexPath, ClassLoader parent) &#123;  </span><br><span class="line"> super((String)null, (File)null, (String)null, (ClassLoader)null);  </span><br><span class="line"> throw new RuntimeException(&quot;Stub!&quot;);  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line"> public PathClassLoader(String dexPath, String libraryPath, ClassLoader parent) &#123;  </span><br><span class="line"> super((String)null, (File)null, (String)null, (ClassLoader)null);  </span><br><span class="line"> throw new RuntimeException(&quot;Stub!&quot;);  </span><br><span class="line"> &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>SDK没有导出这个类的源码，我们去<a href="http://androidxref.com/6.0.1_r10/xref/libcore/dalvik/src/main/java/dalvik/system/PathClassLoader.java" target="_blank" rel="noopener">androidxref</a>上面看；发现其实这个类真的就这么多内容；我们继续查看它的父类<a href="http://androidxref.com/6.0.1_r10/xref/libcore/dalvik/src/main/java/dalvik/system/BaseDexClassLoader.java" target="_blank" rel="noopener">BaseDexClassLoader</a>；ClassLoader嘛，我们查看findClass或者defineClass方法，BaseDexClassLoader的findClass方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123;  </span><br><span class="line"> List&lt;Throwable&gt; suppressedExceptions &#x3D; new ArrayList&lt;Throwable&gt;();  </span><br><span class="line"> Class c &#x3D; pathList.findClass(name, suppressedExceptions);  </span><br><span class="line"> if (c &#x3D;&#x3D; null) &#123;  </span><br><span class="line"> ClassNotFoundException cnfe &#x3D; new ClassNotFoundException(&quot;Didn&#39;t find class \\&quot;&quot; \+ name + &quot;\\&quot; on path: &quot; \+ pathList);  </span><br><span class="line"> for (Throwable t : suppressedExceptions) &#123;  </span><br><span class="line"> cnfe.addSuppressed(t);  </span><br><span class="line"> &#125;  </span><br><span class="line"> throw cnfe;  </span><br><span class="line"> &#125;  </span><br><span class="line"> return c;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，查找Class的任务通过<code>pathList</code>完成；这个<code>pathList</code>是一个<code>DexPathList</code>类的对象，它的<code>findClass</code>方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public Class findClass(String name, List&lt;Throwable&gt; suppressed) &#123;  </span><br><span class="line"> for (Element element : dexElements) &#123;  </span><br><span class="line"> DexFile dex &#x3D; element.dexFile;  </span><br><span class="line">  </span><br><span class="line"> if (dex !&#x3D; null) &#123;  </span><br><span class="line"> Class clazz &#x3D; dex.loadClassBinaryName(name, definingContext, suppressed);  </span><br><span class="line"> if (clazz !&#x3D; null) &#123;  </span><br><span class="line"> return clazz;  </span><br><span class="line"> &#125;  </span><br><span class="line"> &#125;  </span><br><span class="line"> &#125;  </span><br><span class="line"> if (dexElementsSuppressedExceptions !&#x3D; null) &#123;  </span><br><span class="line"> suppressed.addAll(Arrays.asList(dexElementsSuppressedExceptions));  </span><br><span class="line"> &#125;  </span><br><span class="line"> return null;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个DexPathList内部有一个叫做dexElements的数组，然后findClass的时候会遍历这个数组来查找Class；<strong>如果我们把插件的信息塞进这个数组里面，那么不就能够完成类的加载过程吗？！！</strong></p>
<h3 id="给默认ClassLoader打补丁"><a href="#给默认ClassLoader打补丁" class="headerlink" title="给默认ClassLoader打补丁"></a>给默认ClassLoader打补丁</h3><p>通过上述分析，我们知道，可以把插件的相关信息放入BaseDexClassLoader的表示dex文件的数组里面，这样宿主程序的ClassLoader在进行类加载，遍历这个数组的时候，会自动遍历到我们添加进去的插件信息，从而完成插件类的加载！</p>
<p>接下来，我们实现这个过程；我们会用到一些较为复杂的反射技术哦～不过代码非常短：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public static void patchClassLoader(ClassLoader cl, File apkFile, File optDexFile)  </span><br><span class="line"> throws IllegalAccessException, NoSuchMethodException, IOException, InvocationTargetException, InstantiationException, NoSuchFieldException &#123;  </span><br><span class="line"> &#x2F;&#x2F; 获取 BaseDexClassLoader : pathList  </span><br><span class="line"> Field pathListField &#x3D; DexClassLoader.class.getSuperclass().getDeclaredField(&quot;pathList&quot;);  </span><br><span class="line"> pathListField.setAccessible(true);  </span><br><span class="line"> Object pathListObj &#x3D; pathListField.get(cl);  </span><br><span class="line">  </span><br><span class="line"> &#x2F;&#x2F; 获取 PathList: Element\[\] dexElements  </span><br><span class="line"> Field dexElementArray &#x3D; pathListObj.getClass().getDeclaredField(&quot;dexElements&quot;);  </span><br><span class="line"> dexElementArray.setAccessible(true);  </span><br><span class="line"> Object\[\] dexElements &#x3D; (Object\[\]) dexElementArray.get(pathListObj);  </span><br><span class="line">  </span><br><span class="line"> &#x2F;&#x2F; Element 类型  </span><br><span class="line"> Class&lt;?&gt; elementClass &#x3D; dexElements.getClass().getComponentType();  </span><br><span class="line">  </span><br><span class="line"> &#x2F;&#x2F; 创建一个数组, 用来替换原始的数组  </span><br><span class="line"> Object\[\] newElements &#x3D; (Object\[\]) Array.newInstance(elementClass, dexElements.length + 1);  </span><br><span class="line">  </span><br><span class="line"> &#x2F;&#x2F; 构造插件Element(File file, boolean isDirectory, File zip, DexFile dexFile) 这个构造函数  </span><br><span class="line"> Constructor&lt;?&gt; constructor &#x3D; elementClass.getConstructor(File.class, boolean.class, File.class, DexFile.class);  </span><br><span class="line"> Object o &#x3D; constructor.newInstance(apkFile, false, apkFile, DexFile.loadDex(apkFile.getCanonicalPath(), optDexFile.getAbsolutePath(), 0));  </span><br><span class="line">  </span><br><span class="line"> Object\[\] toAddElementArray &#x3D; new Object\[\] &#123; o &#125;;  </span><br><span class="line"> &#x2F;&#x2F; 把原始的elements复制进去  </span><br><span class="line"> System.arraycopy(dexElements, 0, newElements, 0, dexElements.length);  </span><br><span class="line"> &#x2F;&#x2F; 插件的那个element复制进去  </span><br><span class="line"> System.arraycopy(toAddElementArray, 0, newElements, dexElements.length, toAddElementArray.length);  </span><br><span class="line">  </span><br><span class="line"> &#x2F;&#x2F; 替换  </span><br><span class="line"> dexElementArray.set(pathListObj, newElements);  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>短短的二十几行代码，我们就完成了『委托宿主ClassLoader加载插件类』的任务；因此第二种方案也宣告完成！我们简要总结一下这种方式的原理：</p>
<ol>
<li>默认情况下performLacunchActivity会使用替身StubActivity的ApplicationInfo也就是宿主程序的CLassLoader加载所有的类；我们的思路是告诉宿主ClassLoader我们在哪，让其帮助完成类加载的过程。</li>
<li>宿主程序的ClassLoader最终继承自BaseDexClassLoader，BaseDexClassLoader通过DexPathList进行类的查找过程；而这个查找通过遍历一个dexElements的数组完成；<strong>我们通过把插件dex添加进这个数组</strong>就让宿主ClasLoader获取了加载插件类的能力。</li>
</ol>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文中我们采用两种方案成功完成了『启动没有在AndroidManifest.xml中显示声明，并且存在于外部插件中的Activity』的任务。</p>
<p>『激进方案』中我们自定义了插件的ClassLoader，并且绕开了Framework的检测；利用ActivityThread对于LoadedApk的缓存机制，我们把携带这个自定义的ClassLoader的插件信息添加进<code>mPackages</code>中，进而完成了类的加载过程。</p>
<p>『保守方案』中我们深入探究了系统使用ClassLoader findClass的过程，发现应用程序使用的非系统类都是通过同一个PathClassLoader加载的；而这个类的最终父类BaseDexClassLoader通过DexPathList完成类的查找过程；我们hack了这个查找过程，从而完成了插件类的加载。</p>
<p>这两种方案孰优孰劣呢？</p>
<p>很显然，『激进方案』比较麻烦，从代码量和分析过程就可以看出来，这种机制异常复杂；而且在解析apk的时候我们使用的PackageParser的兼容性非常差，我们不得不手动处理每一个版本的apk解析api；另外，它Hook的地方也有点多：不仅需要Hook AMS和<code>H</code>，还需要Hook ActivityThread的<code>mPackages</code>和PackageManager！</p>
<p>『保守方案』则简单得多（虽然原理也不简单），不仅代码很少，而且Hook的地方也不多；有一点正本清源的意思，从最最上层Hook住了整个类的加载过程。</p>
<p>但是，我们不能简单地说『保守方案』比『激进方案』好。从根本上说，这两种方案的差异在哪呢？</p>
<p>『激进方案』是<strong>多ClassLoader构架</strong>，每一个插件都有一个自己的ClassLoader，因此类的隔离性非常好——如果不同的插件使用了同一个库的不同版本，它们相安无事！『保守方案』是<strong>单ClassLoader方案</strong>，插件和宿主程序的类全部都通过宿主的ClasLoader加载，虽然代码简单，但是鲁棒性很差；一旦插件之间甚至插件与宿主之间使用的类库有冲突，那么直接GG。</p>
<p>多ClassLoader还有一个优点：可以真正完成代码的热加载！如果插件需要升级，直接重新创建一个自定的ClassLoader加载新的插件，然后替换掉原来的版本即可（Java中，不同ClassLoader加载的同一个类被认为是不同的类）；单ClassLoader的话实现非常麻烦，有可能需要重启进程。</p>
<p>在J2EE领域中广泛使用ClasLoader的地方均采用多ClassLoader架构，比如Tomcat服务器，Java模块化事实标准的OSGi技术；所以，我们有足够的理由认为<strong>选择多ClassLoader架构在大多数情况下是明智之举</strong>。</p>
<p>目前开源的插件方案中，DroidPlugin采用的『激进方案』，Small采用的『保守方案』那么，有没有两种优点兼顾的方案呢？？</p>
<p>答案自然是有的。</p>
<p>DroidPlugin和Small的共同点是<strong>两者都是非侵入式的插件框架</strong>；什么是『非侵入式』呢？打个比方，你启动一个插件Activity，直接使用<code>startActivity</code>即可，就跟开发普通的apk一样，开发插件和普通的程序对于开发者来说没有什么区别。</p>
<p>如果我们一定程度上放弃这种『侵入性』，那么我们就能实现一个两者优点兼而有之的插件框架！这里我先卖个关子～</p>
<p>OK，本文的内容就到这里了；关于『插件机制对于Activity的处理方式』也就此完结。要说明的是，在本文的『保守方案』其实只处理了代码的加载过程，它并不能加载有资源的apk！所以目前我这个实现基本没什么暖用；当然我这里只是就『代码加载』进行举例；至于资源，那牵扯到另外一个问题——<strong>插件系统的资源管理机制</strong>这个在后续文章的合适机会我会单独讲解。</p>
<p>接下来的文章，会讲述Android四大组件的另外三个<code>Service</code>，<code>BroadCastReceiver</code>, <code>ContentProvider</code>的处理方式。喜欢就点个赞吧～持续更新，请关注github项目 <a href="https://github.com/tiann/understand-plugin-framework" target="_blank" rel="noopener">understand-plugin-framework</a>和我的 <a href="http://weishu.me" target="_blank" rel="noopener">博客</a>! 这文章我前前后后准备了快两个星期，如果你看到了这里，还请支持一下 :)</p>
<p><a href="/tags/android/">#android</a> <a href="/tags/binder/">#binder</a> <a href="/tags/classloader/">#classloader</a> <a href="/tags/droidplugin/">#droidplugin</a> <a href="/tags/plugin-framework/">#plugin framework</a></p>
<p><a href="/2016/04/12/understand-plugin-framework-receiver/">Android插件化原理解析——广播的管理</a></p>
<p><a href="/2016/03/21/understand-plugin-framework-activity-management/">Android 插件化原理解析——Activity生命周期管理</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://reoger.tk/2018/08/26/android/android%E4%B8%AD%E7%9A%84%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="reoger">
      <meta itemprop="description" content="reoger">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="reoger的记录">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/08/26/android/android%E4%B8%AD%E7%9A%84%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/" class="post-title-link" itemprop="url">android中的测试</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-08-26 16:13:55" itemprop="dateCreated datePublished" datetime="2018-08-26T16:13:55+08:00">2018-08-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-12 22:55:09" itemprop="dateModified" datetime="2020-04-12T22:55:09+08:00">2020-04-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/android/" itemprop="url" rel="index"><span itemprop="name">android</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h1><p>在日常的开发过程中，为了保证代码的质量和减少代码出错的机率，我们常常会通过单元测试来验证我们的代码。<br>本篇博客就是用来记录单元测试的用法，以免遗忘。</p>
<h1 id="junit-工具类"><a href="#junit-工具类" class="headerlink" title="junit 工具类"></a>junit 工具类</h1><p>在android中编写单元测试的时候，用的最多的还是<code>junit 4</code>吧，在新版的android studio中，会默认添加依赖，如果是老项目，可能需要module在<code>build.gradle</code>中添加如下的依赖。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">testImplementation &#39;junit:junit:4.12&#39;</span><br></pre></td></tr></table></figure>
<p>好了，环境准备完毕，然后就可以开始进行单元测试了。首先我们还是编写一个需要测试的类，简单起见就编写一个<code>a+b</code>的实现吧，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Utils &#123;</span><br><span class="line"></span><br><span class="line">    public int add(Integer a, Integer b) throws ParseException&#123;</span><br><span class="line">        if (a &#x3D;&#x3D; null || b&#x3D;&#x3D; null)&#123;</span><br><span class="line">            throw new  ParseException(&quot;param is null&quot;,0);</span><br><span class="line">        &#125;</span><br><span class="line">        return a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，就可以编写单元测试了，在window环境下，直接按<code>ctrl+shift+T</code>即可快速创建一个单元测试。如图：<br><img src="http://ovec6nnof.bkt.clouddn.com/2018-08-27_200102.png" alt="图1"></p>
<p>其中的注解我们稍后介绍，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import org.junit.Test;</span><br><span class="line">import static org.junit.Assert.assertEquals;</span><br><span class="line"></span><br><span class="line">public class UtilsTest &#123;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void testAdd() throws Exception &#123;</span><br><span class="line">        Utils test &#x3D; new Utils();</span><br><span class="line">        assertEquals(3,test.add(1,3));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例如我们可以编写一个这样的测试类，使用<code>@Test</code>标识这是一个测试，利用<code>assertEquals</code>来进行判断结果是否符合预期。<br><img src="http://ovec6nnof.bkt.clouddn.com/2018-08-27_200631.png" alt="图2"><br>很明显，这个测试并没有通过，因为1+3的结果明显不是3，但这是我们的预期的结果就错了，所以就需要更改预期为4，运行后发现测试通过。<br>下面简单介绍其他的注解和方法的使用。</p>
<h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><table>
<thead>
<tr>
<th>注解名</th>
<th>注解含义</th>
</tr>
</thead>
<tbody><tr>
<td>@Test</td>
<td>表示此方法为测试方法</td>
</tr>
<tr>
<td>@Before</td>
<td>在每个测试方法前执行，可做初始化操作</td>
</tr>
<tr>
<td>@After</td>
<td>在每个测试方法后执行，可做释放资源操作</td>
</tr>
<tr>
<td>@Ignore</td>
<td>忽略的测试方法</td>
</tr>
<tr>
<td>@BeforeClass</td>
<td>在类中所有方法前运行。此注解修饰的方法必须是static void</td>
</tr>
<tr>
<td>@AfterClass</td>
<td>在类中最后运行。此注解修饰的方法必须是static void</td>
</tr>
<tr>
<td>@RunWith</td>
<td>指定该测试类使用某个运行器</td>
</tr>
<tr>
<td>@Parameters</td>
<td>指定测试类的测试数据集合</td>
</tr>
<tr>
<td>@Rule</td>
<td>重新制定测试类中方法的行为</td>
</tr>
<tr>
<td>@FixMethodOrder</td>
<td>指定测试类中方法的执行顺序</td>
</tr>
</tbody></table>
<p>在测试流程中，上述注解的方法执行的顺序为：<strong>@BeforeClass –&gt; @Before –&gt; @Test –&gt; @After –&gt; @AfterClass</strong><br>主语其他的非流程类的测试注解，<strong>@RunWith、@Parameters、@Rule、@FixMethodOrder</strong>，稍后会进一步介绍其用法。</p>
<h3 id="使用-Parameters配置多组测试数据"><a href="#使用-Parameters配置多组测试数据" class="headerlink" title="使用@Parameters配置多组测试数据"></a>使用<code>@Parameters</code>配置多组测试数据</h3><p>在需要进行多组数据进行测试的时候，我们可能会这么写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assertArrayEquals(new int[]&#123;3,5,9&#125;,new int[]&#123;test.add(1,2),test.add(2,3),test.add(4,5)&#125;);</span><br></pre></td></tr></table></figure>
<p>是的，上述方式可以实现测试多组数据，我们甚至可以将他们分开一条一条的测试，以便于我们快速找到测试不通过的地方。但是有一种更优雅的方式，我们可以这么写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@RunWith(Parameterized.class)</span><br><span class="line">public class UtilsTest &#123;</span><br><span class="line">    public Point point;</span><br><span class="line"></span><br><span class="line">    public UtilsTest(Point point) &#123;</span><br><span class="line">       this.point &#x3D; point;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void testAdd() throws Exception &#123;</span><br><span class="line">        Utils test &#x3D; new Utils();</span><br><span class="line">        assertEquals(point.x+point.y,test.add(point.x,point.y));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Parameterized.Parameters</span><br><span class="line">    public static Collection params()&#123;</span><br><span class="line">        return Arrays.asList(new Point(1,2),new Point(3,4),new Point(5,6));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，我们在<code>UtilsTest</code>，添加了注解<code>@RunWith(Parameterized.class)</code>，用于表示次测试类的参数是可变的，然后添加了一个有参的构造方法<code>public UtilsTest(Point point)</code>，用于接受可变的参数，最后使用<code>@Parameterized.Parameters</code> 来构造参数列表，如此我们的测试类就可以实现一次运行多个测试样例了。结果如下所示：<br><img src="http://ovec6nnof.bkt.clouddn.com/2018-08-27_205446.png" alt="图3"></p>
<h3 id="测试抛出异常"><a href="#测试抛出异常" class="headerlink" title="测试抛出异常"></a>测试抛出异常</h3><p>当我们需要测试传入异常参数时，是否会如预想的一样抛出异常，这个时候我们就可以使用到<code>@test</code>注解中的<code>expected</code>属性，例如，我们还是测试上面的a+b,测试代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Test(expected &#x3D; ParseException.class)</span><br><span class="line">public void testAdd() throws Exception &#123;</span><br><span class="line">    Utils test &#x3D; new Utils();</span><br><span class="line">    assertEquals(5,test.add(null,5));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在测试类中，我们传入了<code>null</code>到<code>add</code>方法中，我们预想这种肯定会出现异常，所以我们在<code>Test</code>注解中添加了<code>expected</code>来捕获<code>ParseException</code>异常，如果捕获到这个异常，此时通过，如果没有捕获到这个异常，则这个测试方法会主动抛出<code>ParseException</code>异常，并说名测试不通过。</p>
<h3 id="Assert类的主要用法"><a href="#Assert类的主要用法" class="headerlink" title="Assert类的主要用法"></a>Assert类的主要用法</h3><table>
<thead>
<tr>
<th>方法名</th>
<th>方法描述</th>
</tr>
</thead>
<tbody><tr>
<td>assertEquals</td>
<td>断言传入的预期值与实际值是相等的</td>
</tr>
<tr>
<td>assertNotEquals</td>
<td>断言传入的预期值与实际值是不相等的</td>
</tr>
<tr>
<td>assertArrayEquals</td>
<td>断言传入的预期数组与实际数组是相等的</td>
</tr>
<tr>
<td>assertNull</td>
<td>断言传入的对象是为空</td>
</tr>
<tr>
<td>assertNotNull</td>
<td>断言传入的对象是不为空</td>
</tr>
<tr>
<td>assertTrue</td>
<td>断言条件为真</td>
</tr>
<tr>
<td>assertFalse</td>
<td>断言条件为假</td>
</tr>
<tr>
<td>assertSame</td>
<td>断言两个对象引用同一个对象，相当于“==”</td>
</tr>
<tr>
<td>assertNotSame</td>
<td>断言两个对象引用不同的对象，相当于“!=”</td>
</tr>
<tr>
<td>assertThat</td>
<td>断言实际值是否满足指定的条件</td>
</tr>
</tbody></table>
<h2 id="匹配器"><a href="#匹配器" class="headerlink" title="匹配器"></a>匹配器</h2><table>
<thead>
<tr>
<th>匹配器</th>
<th>说明</th>
<th>例子</th>
</tr>
</thead>
<tbody><tr>
<td>is</td>
<td>断言参数等于后面给出的匹配表达式</td>
<td>assertThat(5, is (5));</td>
</tr>
<tr>
<td>not</td>
<td>断言参数不等于后面给出的匹配表达式</td>
<td>assertThat(5, not(6));</td>
</tr>
<tr>
<td>equalTo</td>
<td>断言参数相等</td>
<td>assertThat(30, equalTo(30));</td>
</tr>
<tr>
<td>equalToIgnoringCase</td>
<td>断言字符串相等忽略大小写</td>
<td>assertThat(“Ab”, equalToIgnoringCase(“ab”));</td>
</tr>
<tr>
<td>containsString</td>
<td>断言字符串包含某字符串</td>
<td>assertThat(“abc”, containsString(“bc”));</td>
</tr>
<tr>
<td>startsWith</td>
<td>断言字符串以某字符串开始</td>
<td>assertThat(“abc”, startsWith(“a”));</td>
</tr>
<tr>
<td>endsWith</td>
<td>断言字符串以某字符串结束</td>
<td>assertThat(“abc”, endsWith(“c”));</td>
</tr>
<tr>
<td>nullValue</td>
<td>断言参数的值为null</td>
<td>assertThat(null, nullValue());</td>
</tr>
<tr>
<td>notNullValue</td>
<td>断言参数的值不为null</td>
<td>assertThat(“abc”, notNullValue());</td>
</tr>
<tr>
<td>greaterThan</td>
<td>断言参数大于</td>
<td>assertThat(4, greaterThan(3));</td>
</tr>
<tr>
<td>lessThan</td>
<td>断言参数小于</td>
<td>assertThat(4, lessThan(6));</td>
</tr>
<tr>
<td>greaterThanOrEqualTo</td>
<td>断言参数大于等于</td>
<td>assertThat(4, greaterThanOrEqualTo(3));</td>
</tr>
<tr>
<td>lessThanOrEqualTo</td>
<td>断言参数小于等于</td>
<td>assertThat(4, lessThanOrEqualTo(6));</td>
</tr>
<tr>
<td>closeTo</td>
<td>断言浮点型数在某一范围内</td>
<td>assertThat(4.0, closeTo(2.6, 4.3));</td>
</tr>
<tr>
<td>allOf</td>
<td>断言符合所有条件，相当于&amp;&amp;</td>
<td>assertThat(4,allOf(greaterThan(3), lessThan(6)));</td>
</tr>
<tr>
<td>anyOf</td>
<td>断言符合某一条件，相当于或</td>
<td>assertThat(4,anyOf(greaterThan(9), lessThan(6)));</td>
</tr>
<tr>
<td>hasKey</td>
<td>断言Map集合含有此键</td>
<td>assertThat(map, hasKey(“key”));</td>
</tr>
<tr>
<td>hasValue</td>
<td>断言Map集合含有此值</td>
<td>assertThat(map, hasValue(value));</td>
</tr>
<tr>
<td>hasItem</td>
<td>断言迭代对象含有此元素</td>
<td>assertThat(list, hasItem(element));</td>
</tr>
</tbody></table>
<h1 id="UI测试"><a href="#UI测试" class="headerlink" title="UI测试"></a>UI测试</h1><p>上述的单元测试虽然功能很强大，但是局限性也很大，比如不能测试UI相关的，不能测试与<code>Context</code>相关的方法。我们可以利用Ui测试来进行这方面的测试。<br>关于ui测试，请参考这篇<a href="https://juejin.im/post/5b66de2c6fb9a04fbd1b4725" target="_blank" rel="noopener">博客</a>，实在写的太好了。<br>关于android studio中的Ui测试，可以参考<a href="https://developer.android.com/studio/test/espresso-test-recorder" target="_blank" rel="noopener">官方文档</a>。<br>这里仅记录一下使用心得：</p>
<h2 id="espresso必要的依赖"><a href="#espresso必要的依赖" class="headerlink" title="espresso必要的依赖"></a>espresso必要的依赖</h2><p>在<code>module</code>中的<code>build.gradle</code>中添加下面三条依赖：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">androidTestImplementation &#39;com.android.support.test:runner:1.0.2&#39;</span><br><span class="line">androidTestImplementation &#39;com.android.support.test:rules:1.0.2&#39;</span><br><span class="line">androidTestImplementation &#39;com.android.support.test.espresso:espresso-core:3.0.2&#39;</span><br></pre></td></tr></table></figure>
<p>使用示例：<br>譬如在<code>MainActivity</code>中添加有一个如下的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class MainActivity extends AppCompatActivity  &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">    * 需要测试的方法,简单的调起浏览器打开baidu首页</span><br><span class="line">    **&#x2F;</span><br><span class="line">    public static void startActiviy(Context context)&#123;</span><br><span class="line">        Uri uri &#x3D; Uri.parse(&quot;http:&#x2F;&#x2F;wwww.baidu.com&quot;);</span><br><span class="line">        Intent t &#x3D; new Intent(Intent.ACTION_VIEW);</span><br><span class="line">        t.setData(uri);</span><br><span class="line">        t.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</span><br><span class="line">        context.startActivity(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，我们还是可以选择<code>ctrl+shift+T</code>来创建测试类，选择<code>android test</code>目录即可。<br>然后我们可以编写一个类似于这样类来进行测试：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Instrumented test, which will execute on an Android device.</span><br><span class="line"> *</span><br><span class="line"> * @see &lt;a href&#x3D;&quot;http:&#x2F;&#x2F;d.android.com&#x2F;tools&#x2F;testing&quot;&gt;Testing documentation&lt;&#x2F;a&gt;</span><br><span class="line"> *&#x2F;</span><br><span class="line">@RunWith(AndroidJUnit4.class)</span><br><span class="line">public class ExampleInstrumentedTest &#123;</span><br><span class="line">    @Test</span><br><span class="line">    public void useAppContext() throws Exception &#123;</span><br><span class="line">        &#x2F;&#x2F; Context of the app under test.</span><br><span class="line">        Context appContext &#x3D; InstrumentationRegistry.getTargetContext();</span><br><span class="line"></span><br><span class="line">        assertEquals(&quot;com.example.cm.testpulgin&quot;, appContext.getPackageName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void testOpenUrl()&#123;</span><br><span class="line">        MainActivity.startActiviy(InstrumentationRegistry.getTargetContext());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void test1()&#123;</span><br><span class="line">        assertEquals(1,1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们选择运行，选择目标手机，即可在手机上实现测试。这里关键的一点是利用<code>InstrumentationRegistry.getTargetContext()</code>获取到了<code>Context</code>对象。<br>我们可以利用这个<code>Context</code>对象来测试与手机密切相关的一些属性了，前面的单元测试只能测试代码在jvm上是否运行正常，而到了这里我们就可以测试代码是否在手机上运行正常了。<br>譬如我们要测试一些用户的操作的行为是否符合预期，我们可以写一个类似于这样的测试类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@LargeTest</span><br><span class="line">@RunWith(AndroidJUnit4.class)</span><br><span class="line">public class MainActivityTest &#123;</span><br><span class="line"></span><br><span class="line">    @Rule</span><br><span class="line">    public ActivityTestRule&lt;MainActivity&gt; mActivityTestRule &#x3D; new ActivityTestRule&lt;&gt;(MainActivity.class);</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void mainActivityTest() &#123;</span><br><span class="line">        ViewInteraction button &#x3D; onView(</span><br><span class="line">                allOf(withId(R.id.but1),</span><br><span class="line">                        childAtPosition(</span><br><span class="line">                                childAtPosition(</span><br><span class="line">                                        withId(android.R.id.content),</span><br><span class="line">                                        0),</span><br><span class="line">                                0),</span><br><span class="line">                        isDisplayed()));</span><br><span class="line">        button.check(matches(isDisplayed()));</span><br><span class="line"></span><br><span class="line">        ViewInteraction appCompatButton &#x3D; onView(</span><br><span class="line">                allOf(withId(R.id.but1), withText(&quot;测试hook-ams&quot;),</span><br><span class="line">                        childAtPosition(</span><br><span class="line">                                childAtPosition(</span><br><span class="line">                                        withId(android.R.id.content),</span><br><span class="line">                                        0),</span><br><span class="line">                                0),</span><br><span class="line">                        isDisplayed()));</span><br><span class="line">        appCompatButton.perform(click());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static Matcher&lt;View&gt; childAtPosition(</span><br><span class="line">            final Matcher&lt;View&gt; parentMatcher, final int position) &#123;</span><br><span class="line"></span><br><span class="line">        return new TypeSafeMatcher&lt;View&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void describeTo(Description description) &#123;</span><br><span class="line">                description.appendText(&quot;Child at position &quot; + position + &quot; in parent &quot;);</span><br><span class="line">                parentMatcher.describeTo(description);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public boolean matchesSafely(View view) &#123;</span><br><span class="line">                ViewParent parent &#x3D; view.getParent();</span><br><span class="line">                return parent instanceof ViewGroup &amp;&amp; parentMatcher.matches(parent)</span><br><span class="line">                        &amp;&amp; view.equals(((ViewGroup) parent).getChildAt(position));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对其中的一些方法进行简单说明：</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>click()</td>
<td>点击view</td>
</tr>
<tr>
<td>clearText()</td>
<td>清除文本内容</td>
</tr>
<tr>
<td>swipeLeft()</td>
<td>从右往左滑</td>
</tr>
<tr>
<td>swipeRight()</td>
<td>从左往右滑</td>
</tr>
<tr>
<td>swipeDown()</td>
<td>从上往下滑</td>
</tr>
<tr>
<td>swipeUp()</td>
<td>从下往上滑</td>
</tr>
<tr>
<td>click()</td>
<td>点击view</td>
</tr>
<tr>
<td>closeSoftKeyboard()</td>
<td>关闭软键盘</td>
</tr>
<tr>
<td>pressBack()</td>
<td>按下物理返回键</td>
</tr>
<tr>
<td>doubleClick()</td>
<td>双击</td>
</tr>
<tr>
<td>longClick()</td>
<td>长按</td>
</tr>
<tr>
<td>scrollTo()</td>
<td>滚动</td>
</tr>
<tr>
<td>replaceText()</td>
<td>替换文本</td>
</tr>
<tr>
<td>openLinkWithText()</td>
<td>打开指定超链</td>
</tr>
</tbody></table>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul>
<li><a href="https://blog.csdn.net/qq_17766199/article/details/78243176" target="_blank" rel="noopener">Android单元测试(一)：JUnit框架的使用</a></li>
<li><a href="https://developer.android.com/studio/test/espresso-test-recorder" target="_blank" rel="noopener">使用 Espresso 测试记录器创建界面测试</a></li>
<li><a href="https://developer.android.com/studio/test/#run_a_test" target="_blank" rel="noopener">测试应用</a></li>
<li><a href="https://juejin.im/post/5b66de2c6fb9a04fbd1b4725" target="_blank" rel="noopener">解放双手 - Android 开发应该尝试的 UI 自动化测试</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://reoger.tk/2018/08/22/android/WebView%E7%BC%93%E5%AD%98%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%E5%92%8C%E5%BA%94%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="reoger">
      <meta itemprop="description" content="reoger">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="reoger的记录">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/08/22/android/WebView%E7%BC%93%E5%AD%98%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%E5%92%8C%E5%BA%94%E7%94%A8/" class="post-title-link" itemprop="url">散记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-08-22 14:44:55" itemprop="dateCreated datePublished" datetime="2018-08-22T14:44:55+08:00">2018-08-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-12 23:06:09" itemprop="dateModified" datetime="2020-04-12T23:06:09+08:00">2020-04-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%BD%AC%E8%BD%BD/" itemprop="url" rel="index"><span itemprop="name">转载</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="WebView缓存原理分析和应用"><a href="#WebView缓存原理分析和应用" class="headerlink" title="WebView缓存原理分析和应用"></a>WebView缓存原理分析和应用</h1><p>发表于 2017-05-13 | 分类于 <a href="http://unclechen.github.io/2017/05/13/WebView%E7%BC%93%E5%AD%98%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%E5%92%8C%E5%BA%94%E7%94%A8/" target="_blank" rel="noopener">技术</a> |<a href="/2017/05/13/WebView缓存原理分析和应用/#comments"></a></p>
<h1 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a><a href="#一、背景" title="一、背景"></a>一、背景</h1><p>现在的App开发，或多或少都会用到Hybrid模式，到了WebView这边，经常会加载一些js文件（例如和WebView用来Native通信的bridge.js），而这些js文件不会经常发生变化，所以我们希望js在WebView里面加载一次之后，如果js没有发生变化，下次就不用再发起网络请求去加载，从而减少流量和资源的占用。那么有什么方式可以达到这个目的呢？先得从WebView的缓存原理入手。</p>
<h1 id="二、WebView的缓存类型"><a href="#二、WebView的缓存类型" class="headerlink" title="二、WebView的缓存类型"></a><a href="#二、WebView的缓存类型" title="二、WebView的缓存类型"></a>二、WebView的缓存类型</h1><p>WebView主要包括两类缓存，<strong>一类是浏览器自带的网页数据缓存</strong>，这是所有的浏览器都支持的、由HTTP协议定义的缓存；<strong>另一类是H5缓存</strong>，这是由web页面的开发者设置的，H5缓存主要包括了App Cache、DOM Storage、Local Storage、Web SQL Database 存储机制等，这里我们主要介绍App Cache来缓存js文件。</p>
<h1 id="三、浏览器自带的网页数据缓存"><a href="#三、浏览器自带的网页数据缓存" class="headerlink" title="三、浏览器自带的网页数据缓存"></a><a href="#三、浏览器自带的网页数据缓存" title="三、浏览器自带的网页数据缓存"></a>三、浏览器自带的网页数据缓存</h1><h2 id="1-工作原理"><a href="#1-工作原理" class="headerlink" title="1.工作原理"></a><a href="#1-工作原理" title="1.工作原理"></a>1.工作原理</h2><p>浏览器缓存机制是通过HTTP协议Header里的Cache-Control（或Expires）和Last-Modified（或 Etag）等字段来控制文件缓存的机制。关于这几个字段的作用和浏览器的缓存更新机制，大家可以看看这两篇文章(<a href="http://bugly.qq.com/bbs/forum.php?mod=viewthread&tid=267" target="_blank" rel="noopener">H5 缓存机制浅析 移动端 Web 加载性能优化</a>，<a href="http://www.jianshu.com/p/5e7075f4875f" target="_blank" rel="noopener">Android：手把手教你构建 WebView 的缓存机制 &amp; 资源预加载方案</a>)，里面有详细的介绍。下面从我实际应用的角度，介绍一下通常会在HTTP协议中遇到的Header。</p>
<p>这两个字段是<strong>接收响应时，浏览器决定文件是否需要被缓存；或者需要加载文件时，浏览器决定是否需要发出请求</strong>的字段。</p>
<ul>
<li><p><strong>Cache-Control:max-age=315360000，</strong>这表示缓存时长为315360000秒。如果315360000秒内需要再次请求这个文件，那么浏览器不会发出请求，直接使用本地的缓存的文件。这是HTTP/1.1标准中的字段。</p>
</li>
<li><p><strong>Expires: Thu, 31 Dec 2037 23:55:55 GMT，</strong>这表示这个文件的过期时间是2037年12月31日晚上23点55分55秒，在这个时间之前浏览器都不会再次发出请求去获取这个文件。这是HTTP/1.0中的字段，如果客户端和服务器时间不同步会导致缓存出现问题，因此才有了上面的Cache-Control，当它们同时出现在HTTP Response的Header中时，Cache-Control优先级更高。</p>
</li>
</ul>
<p>下面两个字段是<strong>发起请求时，服务器决定文件是否需要更新</strong>的字段。</p>
<ul>
<li><p><strong>Last-Modified:Wed, 28 Sep 2016 09:24:35 GMT，</strong>这表示这个文件最后的修改时间是2016年9月28日9点24分35秒。这个字段对于浏览器来说，会在下次请求的时候，作为Request Header的If-Modified-Since字段带上。例如浏览器缓存的文件已经超过了Cache-Control（或者Expires），那么需要加载这个文件时，就会发出请求，请求的Header有一个字段为<code>If-Modified-Since：Wed, 28 Sep 2016 09:24:35 GMT</code>，服务器接收到请求后，会把文件的Last-Modified时间和这个时间对比，如果时间没变，那么浏览器将返回<code>304 Not Modified</code>给浏览器，且content-length肯定是0个字节。如果时间有变化，那么服务器会返回<code>200 OK</code>，并返回相应的内容给浏览器。</p>
</li>
<li><p><strong>ETag:”57eb8c5c-129”，</strong>这是文件的特征串。功能同上面的Last-Modified是一样的。只是在浏览器下次请求时，ETag是作为Request Header中的<code>If-None-Match:&quot;57eb8c5c-129&quot;</code>字段传到服务器。服务器和最新的文件特征串对比，如果相同那么返回<code>304 Not Modified</code>，不同则返回<code>200 OK</code>。当ETag和Last-Modified同时出现时，任何一个字段只要生效了，就认为文件是没有更新的。</p>
</li>
</ul>
<h2 id="2-WebView如何设置才能支持上面的协议"><a href="#2-WebView如何设置才能支持上面的协议" class="headerlink" title="2.WebView如何设置才能支持上面的协议"></a><a href="#2-WebView如何设置才能支持上面的协议" title="2.WebView如何设置才能支持上面的协议"></a>2.WebView如何设置才能支持上面的协议</h2><p>由上面的介绍可知，只要是个主流的、合格的浏览器，都应该能够支持HTTP协议层面的这几个字段。这不是我们开发者可以修改的，也不是我们应该修改的配置。在Android上，我们的WebView也支持这几个字段。但是我们可以通过代码去<strong>设置WebView的Cache Mode</strong>，而使得协议生效或者无效。WebView有下面几个Cache Mode：</p>
<ul>
<li>LOAD_CACHE_ONLY: 不使用网络，只读取本地缓存数据。</li>
<li>LOAD_DEFAULT: 根据cache-control决定是否从网络上取数据。</li>
<li>LOAD_CACHE_NORMAL: API level 17中已经废弃，从API level 11开始作用同LOAD_DEFAULT模式</li>
<li>LOAD_NO_CACHE: 不使用缓存，只从网络获取数据。</li>
<li>LOAD_CACHE_ELSE_NETWORK，只要本地有，无论是否过期，或者no-cache，都使用缓存中的数据。本地没有缓存时才从网络上获取。</li>
</ul>
<p>设置WebView缓存的Cache Mode示例代码如下：</p>
<p>1</p>
<p>2</p>
<p>WebSettings settings = webView.getSettings();</p>
<p>settings.setCacheMode(WebSettings.LOAD_DEFAULT);</p>
<p>网上很多人都说根据网络条件去选择Cache Mode，当有网络时，设置为LOAD_DEFAULT，当没有网络时设置为LOAD_CACHE_ELSE_NETWORK。但是在我的业务中，js文件的更新都是非覆盖式的更新，也就是时候每次改变js文件的时候，文件的url地址一定会发生变化，所以我希望浏览器能够缓存下来js，并且一直使用它，那么我就给它只设置为LOAD_CACHE_ELSE_NETWORK。当然如果你要是可以改js的cdn服务器的Cache-Control字段，那也行啊，用LOAD_DEFAULT就ok了。至于文件是应该采用覆盖式or非覆盖式的更新，不是我今天要讨论的内容，在web前端领域，这是一个可以聊聊的topic。</p>
<blockquote>
<p>关于iOS的WebView，我同事在实际测试的时候竟然发现，控制文件缓存的Response Header是Expires字段。。而且iOS无法针对整个WebView设置Cache Mode，只能针对每一个URLRequest去设置。。后续有机会要学习一下iOS那块的情况。</p>
</blockquote>
<h2 id="3-在手机里面的存储路径"><a href="#3-在手机里面的存储路径" class="headerlink" title="3.在手机里面的存储路径"></a><a href="#3-在手机里面的存储路径" title="3.在手机里面的存储路径"></a>3.在手机里面的存储路径</h2><p>浏览器默认缓存下来的文件是怎么被存储到了哪里呢？这个问题在接触到WebView以来，就一直是一个谜题。这次由于工作的需要，我特意root了两台手机，一台红米1（Android 4.4）和一台小米4c（Android 5.1），在root高系统版本（6.0和7.1）的两台Nexus都以失败告终之后，我决定还是先看看4.4和5.1系统上，WebView自带的缓存存到了哪里。</p>
<p>首先，不用思考就知道，这些文件一定是在<strong>/data/data/包名/</strong>目录下，在我之前的一篇博客里面提到过，这是每一个应用自己的内部存储目录。</p>
<p>接着，我们打开终端，使用adb连接手机，然后按照下面命令操作一下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 1.先进入shell</span><br><span class="line"></span><br><span class="line">adb shell</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 2.开启root账号 </span><br><span class="line"></span><br><span class="line">su</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 3.修改文件夹权限</span><br><span class="line"></span><br><span class="line">chmod 777 data&#x2F;data&#x2F;你的应用包名&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 4.修改子文件夹的权限，因为Android命令行不支持向Linux那样的-R命令实现递归式的chmod。。。</span><br><span class="line"></span><br><span class="line">chmod 777 data&#x2F;data&#x2F;你的应用包名&#x2F;*</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 5.所以如果你对应用目录层级更深，你就要进一步地chmod。。。</span><br><span class="line"></span><br><span class="line">chmod 777 data&#x2F;data&#x2F;你的应用包名&#x2F;*&#x2F;*</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 6.直到终端里提示你说，no such file or directory时，说明chmod完了，所有的内部存储里面的文件夹和文件都可以看到了，如果大家有更好的方法请一定告诉我，多谢了~</span><br></pre></td></tr></table></figure>

<ul>
<li>Android 4.4的目录：<code>/data/data/包名/app_webview/cache/</code>，如下图所示的第二个文件夹。</li>
</ul>
<p><a href="https://ww4.sinaimg.cn/large/006tNc79ly1ffjvarjyijj30jg05k0yr.jpg" target="_blank" rel="noopener"><img src="https://ww4.sinaimg.cn/large/006tNc79ly1ffjvarjyijj30jg05k0yr.jpg" alt="Android4.4系统WebView自带缓存路径"></a></p>
<p>可能你注意到了，第一个文件夹是叫Application Cache，我们后面再说它。</p>
<ul>
<li>Android 5.1的目录：<code>/data/data/包名/cache/org.chromium.android_webview/</code>下面，如下图所示。</li>
</ul>
<p><a href="https://ww2.sinaimg.cn/large/006tNc79ly1ffjvztg93zj30jg0a247x.jpg" target="_blank" rel="noopener"><img src="https://ww2.sinaimg.cn/large/006tNc79ly1ffjvztg93zj30jg0a247x.jpg" alt=""></a></p>
<p>但是在5.1系统上，<code>/data/data/包名/app_webview/</code>文件夹依然存在，只是4.4系统上面存储WebView自带缓存的<code>app_webview/cache</code>文件夹不再存在了（注意下App Cache目录还在），如下图所示。</p>
<p><a href="https://ww3.sinaimg.cn/large/006tNc79ly1ffjw46ygoqj30jg06443v.jpg" target="_blank" rel="noopener"><img src="https://ww3.sinaimg.cn/large/006tNc79ly1ffjw46ygoqj30jg06443v.jpg" alt="Android5.1系统WebView自带缓存路径"></a></p>
<p>综上所述，WebView自带的浏览器协议支持的缓存，在不同的系统版本上，位置是不一样的。也许除了我root过的4.4、5.1以外，其他版本系统的WebView自带缓存还可能存在于不同的目录里面。</p>
<p>另外一个是关于<strong>缓存文件的存储格式和索引格式</strong>，在不同的手机上可能也有差别，因为之前看到网上的人都说有叫<strong>webview.db</strong>或者<strong>webviewCache.db</strong>的文件，这个文件呢，还不是在<code>app_webview/cache</code>或者<code>org.chromium.android_webview</code>下面，而是在<code>/data/data/包名/database/</code>里面。但是，我这两台root过的手机都没有看到这种文件，而且我把<code>/data/data/包名/</code>下面所有的db文件都打开看了，并没有发现有存储url记录的table。。</p>
<p>实际上，以5.1系统为例，我看到了<code>/data/data/包名/cache/org.chromium.android_webview/</code>下面有叫<strong>index</strong>和<strong>/index-dir/the-real-index</strong>的文件，以及一堆名称为<strong>md5+下划线+数字</strong>的文件，上面的图中也可以看得到，这块的原理仍然有些疑问，也希望专业的大神可以解答一下。</p>
<h1 id="四、H5的缓存"><a href="#四、H5的缓存" class="headerlink" title="四、H5的缓存"></a><a href="#四、H5的缓存" title="四、H5的缓存"></a>四、H5的缓存</h1><p>讲完了WebView自带的缓存，下面讲一下H5里面的App Cache。这个Cache是由开发Web页面的开发者控制的，而不是由Native去控制的，但是Native里面的WebView也需要我们做一下设置才能支持H5的这个特性。</p>
<h2 id="1-工作原理-1"><a href="#1-工作原理-1" class="headerlink" title="1.工作原理"></a><a href="#1-工作原理-1" title="1.工作原理"></a>1.工作原理</h2><p>写Web页面代码时，指定manifest属性即可让页面使用App Cache。通常html页面代码会这么写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;html manifest&#x3D;&quot;xxx.appcache&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>
<p>xxx.appcache文件用的是相对路径，这时appcache文件的路径是和页面一样的。也可以使用的绝对路径，但是域名要保持和页面一致。</p>
<p>完整的xxx.appcache文件一般包括了3个section，基本格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">CACHE MANIFEST</span><br><span class="line"></span><br><span class="line">\# 2017-05-13 v1.0.0</span><br><span class="line"></span><br><span class="line">&#x2F;bridge.js</span><br><span class="line"></span><br><span class="line">NETWORK:</span><br><span class="line"></span><br><span class="line">*</span><br><span class="line"></span><br><span class="line">FALLBACK:</span><br><span class="line"></span><br><span class="line">&#x2F;404.html</span><br></pre></td></tr></table></figure>
<ul>
<li>CACHE MANIFEST下面文件就是要被浏览器缓存的文件</li>
<li>NETWORK下面的文件就是要被加载的文件</li>
<li>FALLBACK下面的文件是目标页面加载失败时的显示的页面</li>
</ul>
<p><strong>AppCache工作的原理：</strong>当一个设置了manifest文件的html页面被加载时，CACHE MANIFEST指定的文件就会被缓存到浏览器的App Cache目录下面。当下次加载这个页面时，会首先应用通过manifest已经缓存过的文件，然后发起一个加载xxx.appcache文件的请求到服务器，如果xxx.appcache文件没有被修改过，那么服务器会返回<code>304 Not Modified</code>给到浏览器，如果xxx.appcache文件被修改过，那么服务器会返回<code>200 OK</code>，并返回新的xxx.appcache文件的内容给浏览器，浏览器收到之后，再把新的xxx.appcache文件中指定的内容加载过来进行缓存。</p>
<p>可以看到，AppCache缓存需要在每次加载页面时都发出一个xxx.appcache的请求去检查manifest文件是不是有更新（byte by byte）。根据这篇文章（<a href="http://bugly.qq.com/bbs/forum.php?mod=viewthread&tid=267" target="_blank" rel="noopener">H5 缓存机制浅析 移动端 Web 加载性能优化</a>）的介绍，AppCache有一些坑的地方，且官方已经不推荐使用了，但目前主流的浏览器依然是支持的。文章里主要提到下面这些坑：</p>
<ul>
<li>要更新缓存的文件，需要更新包含它的 manifest 文件，那怕只加一个空格。常用的方法，是修改 manifest 文件注释中的版本号。如：# 2012-02-21 v1.0.0</li>
<li>被缓存的文件，浏览器是先使用，再通过检查 manifest 文件是否有更新来更新缓存文件。这样缓存文件可能用的不是最新的版本。</li>
<li>在更新缓存过程中，如果有一个文件更新失败，则整个更新会失败。</li>
<li>manifest 和引用它的HTML要在相同 HOST。</li>
<li>manifest 文件中的文件列表，如果是相对路径，则是相对 manifest 文件的相对路径。</li>
<li>manifest 也有可能更新出错，导致缓存文件更新失败。</li>
<li>没有缓存的资源在已经缓存的 HTML 中不能加载，即使有网络。例如：[url=]<a href="http://appcache-demo.s3-website-us-east-1.amazonaws.com/without-network/[/url" target="_blank" rel="noopener">http://appcache-demo.s3-website-us-east-1.amazonaws.com/without-network/[/url</a>]</li>
<li>manifest 文件本身不能被缓存，且 manifest 文件的更新使用的是浏览器缓存机制。所以 manifest 文件的 Cache-Control 缓存时间不能设置太长。</li>
</ul>
<h2 id="2-WebView如何设置才能支持AppCache"><a href="#2-WebView如何设置才能支持AppCache" class="headerlink" title="2.WebView如何设置才能支持AppCache"></a><a href="#2-WebView如何设置才能支持AppCache" title="2.WebView如何设置才能支持AppCache"></a>2.WebView如何设置才能支持AppCache</h2><p>WebView默认是没有开启AppCache支持的，需要添加下面这几行代码来设置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">WebSettings webSettings &#x3D; webView.getSettings();</span><br><span class="line"></span><br><span class="line">webSettings.setAppCacheEnabled(true);</span><br><span class="line"></span><br><span class="line">String cachePath &#x3D; getApplicationContext().getCacheDir().getPath(); &#x2F;&#x2F; 把内部私有缓存目录&#39;&#x2F;data&#x2F;data&#x2F;包名&#x2F;cache&#x2F;&#39;作为WebView的AppCache的存储路径</span><br><span class="line"></span><br><span class="line">webSettings.setAppCachePath(cachePath);</span><br><span class="line"></span><br><span class="line">webSettings.setAppCacheMaxSize(5 * 1024 * 1024);</span><br></pre></td></tr></table></figure>

<p>注意：WebSettings的setAppCacheEnabled和setAppCachePath都必须要调用才行。</p>
<h2 id="3-存储AppCache的路径"><a href="#3-存储AppCache的路径" class="headerlink" title="3.存储AppCache的路径"></a><a href="#3-存储AppCache的路径" title="3.存储AppCache的路径"></a>3.存储AppCache的路径</h2><p>按照Android SDK的API说明，setAppCachePath是可以用来设置AppCache路径的，但是我实际测试发现，不管你怎么设置这个路径，设置到应用自己的内部私有目录还是外部SD卡，都无法生效。AppCache缓存文件最终都会存到<code>/data/data/包名/app_webview/cache/Application Cache</code>这个文件夹下面，在上面的Android 4.4和5.1系统目录截图可以看得到，<strong>但是如果你不调用setAppCachePath方法，WebView将不会产生这个目录</strong>。这里有点让我觉得奇怪，我猜测可能从某一个系统版本开始，为了缓存文件的完整性和安全性考虑，SDK实现的时候就吧AppCache缓存目录设置到了内部私有存储。</p>
<h1 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a><a href="#五、总结" title="五、总结"></a>五、总结</h1><h2 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a><a href="#相同点" title="相同点"></a>相同点</h2><p>WebView自带的缓存和AppCache都是可以用来做文件级别的缓存的，基本上比较好地满足对于非覆盖式的js、css等文件更新。</p>
<h2 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a><a href="#不同点" title="不同点"></a>不同点</h2><ul>
<li>WebView自带的缓存是是协议层实现的（浏览器内核标准实现，开发者无法改变）；而AppCache是应用层实现的。</li>
<li>WebView的缓存目录在不同系统上可能是不同的；而对于AppCache而言，AppCache的存储路径虽然有方法设置，但是最终都存储到了一个固定的内部私有目录下。</li>
<li>WebView自带的缓存可以在缓存生效的时候不用再发HTTP请求；而AppCache一定会发出一个manifest文件的请求。</li>
<li>WebView自带的缓存可以通过设置CacheMode来改变WebView的缓存机制；而AppCache的缓存策略是由manifest文件控制的，也就是说是由web页面开发者控制的。</li>
</ul>
<p>最后说一下，其实很多时候，这两类缓存是共同在工作的，当manifest文件没有控制某些资源加载时，例如我上面写的xxx.appcache文件里，NETWORK section下面用的是*号，意思是所有不缓存的文件都要去网络加载。此时，这些资源就会走到WebView自带的缓存机制去，结合WebView的CacheMode，我们实际上对这些文件进行了一次WebView自带的缓存。搞清楚这两类缓存的原理有利于我们更好的设计自己的页面和App，尽可能减少网络请求，提高App运行效率。</p>
<ul>
<li><strong>本文作者：</strong>unclechen</li>
<li><strong>本文链接：</strong> <a href="/2017/05/13/WebView缓存原理分析和应用/" title="WebView缓存原理分析和应用">2017/05/13/WebView缓存原理分析和应用/</a></li>
<li><strong>版权声明：</strong> 本文采用<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议</a>进行许可。转载请注明出处！</li>
</ul>
<p><a href="/tags/Android/"># Android</a> <a href="/tags/WebView/"># WebView</a></p>
<p><a href="/2016/12/11/python利用beautifulsoup+selenium自动翻页抓取网页内容/" title="python利用beautifulsoup+selenium自动翻页抓取网页内容">python利用beautifulsoup+selenium自动翻页抓取网页内容</a></p>
<p><a href="/2017/06/16/使用ReactJS开发Chrome插件/" title="使用React.js开发Chrome插件">使用React.js开发Chrome插件</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://reoger.tk/2018/08/15/java/java%E4%B8%AD%E7%9A%84%E6%B3%9B%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="reoger">
      <meta itemprop="description" content="reoger">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="reoger的记录">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/08/15/java/java%E4%B8%AD%E7%9A%84%E6%B3%9B%E5%9E%8B/" class="post-title-link" itemprop="url">java中的泛型</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-08-15 14:44:55" itemprop="dateCreated datePublished" datetime="2018-08-15T14:44:55+08:00">2018-08-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-12 23:00:51" itemprop="dateModified" datetime="2020-04-12T23:00:51+08:00">2020-04-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/android/" itemprop="url" rel="index"><span itemprop="name">android</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="什么是泛型"><a href="#什么是泛型" class="headerlink" title="什么是泛型"></a>什么是泛型</h1><p>Java 泛型（generics）是 JDK 5 中引入的一个新特性, 泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。<br>泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。</p>
<hr>
<p>假定我们有这样一个需求：写一个排序方法，能够对整型数组、字符串数组甚至其他任何类型的数组进行排序，该如何实现？</p>
<p>答案是可以使用 Java 泛型。</p>
<p>使用 Java 泛型的概念，我们可以写一个泛型方法来对一个对象数组排序。然后，调用该泛型方法来对整型数组、浮点数数组、字符串数组等进行排序。</p>
<h1 id="泛型的分类"><a href="#泛型的分类" class="headerlink" title="泛型的分类"></a>泛型的分类</h1><p>根据泛型的使用场景，一般可以分成三类，分别是:<strong>泛型类</strong>、<strong>泛型方法</strong>、<strong>和泛型接口</strong>。</p>
<h1 id="泛型类型擦出"><a href="#泛型类型擦出" class="headerlink" title="泛型类型擦出"></a>泛型类型擦出</h1><p>Java中的泛型，只在编译阶段有效。在编译过程中，正确检验泛型结果后，会将泛型的相关信息擦出，并且在对象进入和离开方法的边界处添加类型检查和类型转换的方法。也就是说，泛型信息不会进入到运行时阶段。<br>用代码来说明就是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class test &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String args[])&#123;</span><br><span class="line">        List&lt;Integer&gt; a &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;String&gt;  b &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">        System.out.println(a.getClass().toString());</span><br><span class="line">        System.out.println(a.getClass().toString());</span><br><span class="line"></span><br><span class="line">        System.out.println(b.getClass().equals(a.getClass()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行的结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class java.util.ArrayList</span><br><span class="line">class java.util.ArrayList</span><br><span class="line">true</span><br></pre></td></tr></table></figure>
<p>可以看到，<code>List&lt;Integer&gt;</code>和<code>List&lt;String&gt;</code>的类是相同的。</p>
<p>总结成一句话就是：<strong>泛型类型在逻辑上看以看成是多个不同的类型，实际上都是相同的基本类型。</strong></p>
<h2 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h2><p>泛型类的使用非常简单,在类名添加<code>&lt;T&gt;</code> 或者类似于这类的泛型类声明即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Person&lt;T&gt;&#123;</span><br><span class="line">    private T t;</span><br><span class="line"></span><br><span class="line">    public Person(T t) &#123;</span><br><span class="line">        this.t &#x3D; t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public T getKey()&#123;</span><br><span class="line">        return t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们在使用这个泛型类的时候，就可以传入不同类型的参数来进行初始化，可以显示声明数据类型，也可以不声明，<code>jvm</code>会自动帮我们声明。使用实例代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Person p1 &#x3D; new Person&lt;Integer&gt;(12345);</span><br><span class="line">Person p2 &#x3D; new Person&lt;Double&gt;(8989.9);</span><br><span class="line">Person p3 &#x3D; new Person&lt;&gt;(true);</span><br><span class="line">Person p4 &#x3D; new Person&lt;&gt;(&quot;i am ok!&quot;);</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;p1 -&gt; &quot;+p1.getKey());</span><br><span class="line">System.out.println(&quot;p2 -&gt; &quot;+p2.getKey());</span><br><span class="line">System.out.println(&quot;p3 -&gt; &quot;+p3.getKey());</span><br><span class="line">System.out.println(&quot;p4 -&gt; &quot;+p4.getKey());</span><br></pre></td></tr></table></figure>
<p>输出的结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p1 -&gt; 12345</span><br><span class="line">p2 -&gt; 8989.9</span><br><span class="line">p3 -&gt; true</span><br><span class="line">p4 -&gt; i am ok!</span><br></pre></td></tr></table></figure>
<p>可以看到，使用泛型类非常简单，只需要在定义类的时候添加<code>&lt;T&gt;</code>、<code>&lt;K&gt;</code>、<code>&lt;V&gt;</code>这类的泛型类的定义即可。当然，如果有需要，我们可以限制其使用范围，例如<code>&lt;T extends Number&gt;</code> 就规定了传入的类型是只能是<code>Number</code>的子类。</p>
<h2 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h2><p>泛型方法的规则如下：</p>
<ol>
<li>所有泛型方法声明都有一个类型参数声明部分（由尖括号分隔），该类型参数声明部分在方法返回类型之前（在下面例子中的<E>）。</li>
<li>每一个类型参数声明部分包含一个或多个类型参数，参数间用逗号隔开。一个泛型参数，也被称为一个类型变量，是用于指定一个泛型类型名称的标识符。</li>
<li>类型参数能被用来声明返回值类型，并且能作为泛型方法得到的实际参数类型的占位符。</li>
<li>泛型方法体的声明和其他方法一样。注意类型参数只能代表引用型类型，不能是原始类型（像int,double,char的等）。</li>
</ol>
<p>泛型方法与泛型类的定义类似，泛型类的定义是在类名后加<code>&lt;T&gt;</code>这类的泛型修饰词，泛型方法的定义就是在方法的返回值添加<code>&lt;T&gt;</code>这类的修饰词。先来看泛型方法的定义示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private &lt;T&gt; void helloPerson(T t)&#123;</span><br><span class="line">       System.out.println(&quot;t &#x3D; [&quot; + t + &quot;]&quot;);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>注意，这里我们称他为泛型方法是因为<code>void</code>前面的<code>&lt;T&gt;</code>，而不是<code>helloPerson(T t)</code>中的<code>T</code>。<br>我们在泛型类的<code>Person</code>中的<code>public T getKey()</code> 就不能算一个泛型方法，因为这里的<code>T</code>只是<code>getKey</code>方法的一个返回值而已。<br>然后泛型方法的使用也很简单：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">helloPerson(123);</span><br><span class="line">helloPerson(12.3);</span><br><span class="line">helloPerson(true);</span><br><span class="line">helloPerson(&quot;i am ok&quot;);</span><br></pre></td></tr></table></figure>
<p>上面方法的运行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">t &#x3D; [123]</span><br><span class="line">t &#x3D; [12.3]</span><br><span class="line">t &#x3D; [true]</span><br><span class="line">t &#x3D; [i am ok]</span><br></pre></td></tr></table></figure>


<h2 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h2><p>泛型接口的定义同样很简单，只需要在接口的名字后加上<code>&lt;T&gt;</code>这类的泛型定义接口。例如下面是一个泛型接口的示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface IFunction&lt;T&gt; &#123;</span><br><span class="line">    void doSomeThing(T t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在泛型接口里面定义了泛型，我们就可以在对应的方法中使用其类型。<br>当然，接口的定义好之后还是需要去实现这个接口的，实现的方式有两种，一种是声明类型，一种是不声明类型。<br>下面是第一种，申明类型的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Eat implements IFunction&lt;String&gt; &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void doSomeThing(String s) &#123;</span><br><span class="line">        System.out.println(&quot;s &#x3D; [&quot; + s + &quot;]&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，在<code>Eat</code>的实现中，我们讲泛型显示声明成了<code>String</code>，如此我们在使用<code>Eat</code>类中的<code>doSomeThing</code>方法时，就只能传入<code>String</code>类型的。<br>另一种，是不声明具体类型的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Read&lt;T&gt; implements IFunction&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void doSomeThing(T t) &#123;</span><br><span class="line">        System.out.println(&quot;t &#x3D; [&quot; + t + &quot;]&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，其实<code>Read</code>就已经被声明成了一个泛型类，因为实现了泛型接口，我们要继续使用泛型来实现的话，就需要将类实现成泛型类。<br>我们来看其调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">IFunction f1 &#x3D; new Eat();</span><br><span class="line">IFunction f2 &#x3D; new Read();</span><br><span class="line"></span><br><span class="line">f1.doSomeThing(&quot;f1-&gt; only eat!&quot;);</span><br><span class="line">&#x2F;&#x2F;f1.doSomeThing(123456);</span><br><span class="line">&#x2F;&#x2F;这句编译不会报错，运行会抛出java.lang.Integer cannot be cast to java.lang.String 异常</span><br><span class="line"></span><br><span class="line">f2.doSomeThing(132);</span><br><span class="line">f2.doSomeThing(&quot;read&quot;);</span><br><span class="line">f2.doSomeThing(true);</span><br><span class="line">f2.doSomeThing(52.1);</span><br></pre></td></tr></table></figure>
<p>输出的结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s &#x3D; [f1-&gt; only eat!]</span><br><span class="line">t &#x3D; [132]</span><br><span class="line">t &#x3D; [read]</span><br><span class="line">t &#x3D; [true]</span><br><span class="line">t &#x3D; [52.1]</span><br></pre></td></tr></table></figure>
<p>可以看到，我们在继承泛型接口时，显示申明了其类型之后，我们调用时也只能使用对应的类型，如果传入其他的类型，编译器并不会报错，但是运行时会抛出 类型强转失败的异常 。</p>
<h1 id="泛型通配符"><a href="#泛型通配符" class="headerlink" title="泛型通配符"></a>泛型通配符</h1><p>类型通配符一般是使用<code>?</code>代替具体的类型参数。例如 List&lt;?&gt; 在逻辑上是List<String>,List<Integer> 等所有List&lt;具体类型实参&gt;的父类。注意，<code>?</code>可以代表<code>String</code>,<code>Interger</code>等其他具体的类型，但它是不确定的，而<code>&lt;T&gt;</code>表示一个类型参数，不能当作实际参数使用。说白了，就是<code>?</code>,表示不确定的类型，和<code>String</code>，<code>Integer</code>这种类型一样，是实实在在的类型，而<code>T</code>，只是表示类型参数，在使用时还是会转化成对应的实际参数的。<br>使用实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class TypeTest &#123;</span><br><span class="line">    public static void main(String args[])&#123;</span><br><span class="line">        TypeTest typeTest  &#x3D; new TypeTest();</span><br><span class="line">        typeTest.helloMan(Arrays.asList(&quot;1&quot;,&quot;hello&quot;));</span><br><span class="line">        typeTest.helloMan(Arrays.asList(1,2,3));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void helloMan(List&lt;?&gt; a)&#123;</span><br><span class="line">        System.out.println(&quot;a &#x3D; [&quot; + a + &quot;]&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，我往同一个方法出入不同类型的参数也时可以正常运行的，输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a &#x3D; [[1, hello]]</span><br><span class="line">a &#x3D; [[1, 2, 3]]</span><br></pre></td></tr></table></figure>
<p>还有，补充两点;</p>
<ol>
<li><code>&lt;? extends T&gt;</code>表示该通配符所代表的类型是<code>T</code>类型的子类。</li>
<li><code>&lt;? super T&gt;</code>表示该通配符所代表的类型是<code>T</code>类型的父类</li>
</ol>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul>
<li><a href="https://blog.csdn.net/s10461/article/details/53941091" target="_blank" rel="noopener">java 泛型详解</a></li>
<li><a href="http://www.runoob.com/java/java-generics.html" target="_blank" rel="noopener">Java 泛型</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">reoger</p>
  <div class="site-description" itemprop="description">reoger</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">58</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">32</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/reoger" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;reoger" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:reoger112@gmail.com" title="E-Mail → mailto:reoger112@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2018 – 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">reoger</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
