<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"reoger.tk","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="reoger">
<meta property="og:type" content="website">
<meta property="og:title" content="reoger的记录">
<meta property="og:url" content="http://reoger.tk/page/2/index.html">
<meta property="og:site_name" content="reoger的记录">
<meta property="og:description" content="reoger">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="reoger">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://reoger.tk/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>reoger的记录</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">reoger的记录</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">--以后的你会感激现在那么努力的自己</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>日程表</a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>公益 404</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://reoger.tk/2018/11/12/sourceCode/LinkedHashMap%E5%AE%9E%E7%8E%B0LRUCache/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="reoger">
      <meta itemprop="description" content="reoger">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="reoger的记录">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/11/12/sourceCode/LinkedHashMap%E5%AE%9E%E7%8E%B0LRUCache/" class="post-title-link" itemprop="url">LinkedHashMap实现LRUCache</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-11-12 23:14:55" itemprop="dateCreated datePublished" datetime="2018-11-12T23:14:55+08:00">2018-11-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-07-18 14:41:44" itemprop="dateModified" datetime="2020-07-18T14:41:44+08:00">2020-07-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/sourceCode/" itemprop="url" rel="index"><span itemprop="name">sourceCode</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="LinkedHashMap实现LRUCache"><a href="#LinkedHashMap实现LRUCache" class="headerlink" title="LinkedHashMap实现LRUCache"></a>LinkedHashMap实现LRUCache</h1><hr>
<h2 id="LinkedHashMap实现原理"><a href="#LinkedHashMap实现原理" class="headerlink" title="LinkedHashMap实现原理"></a>LinkedHashMap实现原理</h2><p>简单介绍一下LinkedHasMap的实现原理，针对JDK 8.0，在不同的版本上其实现可能有所区别。</p>
<h2 id="原理概括"><a href="#原理概括" class="headerlink" title="原理概括"></a>原理概括</h2><p><code>LinkedHasMap</code>就是基于<code>HashMap</code>，通过维护一个双向链表，达到在使用<code>HashMap</code>存储的情况下，记录其顺序。<br><code>linkedHashMap</code>结构图的示意图如图所示：<br><img src="https://images2015.cnblogs.com/blog/249993/201612/249993-20161215143120620-1544337380.png" alt="linkedHashMap结构图"></p>
<p>水平所限，本篇不会把所有的实现都呈现出来，只对其其中的几个关键性的方法函数进行解析。</p>
<h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p>其构造方法主要有三个，只介绍其中的一个。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public LinkedHashMap(int initialCapacity,</span><br><span class="line">                      float loadFactor,</span><br><span class="line">                      boolean accessOrder) &#123;</span><br><span class="line">     super(initialCapacity, loadFactor);</span><br><span class="line">     this.accessOrder &#x3D; accessOrder;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>这里的 <code>initialCapacity</code>表示初始的长度，<code>loadFactor</code>表示加载因子,<code>accessOrder</code>表示访问顺序，当其值为<code>true</code>时，表示当前的<code>LinkedHashMap</code>的顺序由访问数据时决定，即数据访问之后就会将这个数据放在<code>LinkedHashMap</code>数据项的前面来，而<code>accessOrder</code>为false时，则表示数据的访问数据由插入时就决定好了。</p>
<h2 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h2><p>往<code>LinkedHashMap</code>里面添加数据的方法就是通过<code>put</code>方法实现，在jdk 8.0中<code>LinkedHashMap</code>并没有自己实现<code>put</code>方法，而是由<code>HashMap</code>一同实现了。下面是具体的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">       return putVal(hash(key), key, value, false, true);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">final V putVal(int hash, K key, V value, boolean onlyIfAbsent,</span><br><span class="line">                  boolean evict) &#123;</span><br><span class="line">       Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;</span><br><span class="line">       if ((tab &#x3D; table) &#x3D;&#x3D; null || (n &#x3D; tab.length) &#x3D;&#x3D; 0)</span><br><span class="line">           n &#x3D; (tab &#x3D; resize()).length;</span><br><span class="line">       if ((p &#x3D; tab[i &#x3D; (n - 1) &amp; hash]) &#x3D;&#x3D; null)</span><br><span class="line">           tab[i] &#x3D; newNode(hash, key, value, null);</span><br><span class="line">       else &#123;</span><br><span class="line">           Node&lt;K,V&gt; e; K k;</span><br><span class="line">           if (p.hash &#x3D;&#x3D; hash &amp;&amp;</span><br><span class="line">               ((k &#x3D; p.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))</span><br><span class="line">               e &#x3D; p;</span><br><span class="line">           else if (p instanceof TreeNode)</span><br><span class="line">               e &#x3D; ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);</span><br><span class="line">           else &#123;</span><br><span class="line">               for (int binCount &#x3D; 0; ; ++binCount) &#123;</span><br><span class="line">                   if ((e &#x3D; p.next) &#x3D;&#x3D; null) &#123;</span><br><span class="line">                       p.next &#x3D; newNode(hash, key, value, null);</span><br><span class="line">                       if (binCount &gt;&#x3D; TREEIFY_THRESHOLD - 1) &#x2F;&#x2F; -1 for 1st</span><br><span class="line">                           treeifyBin(tab, hash);</span><br><span class="line">                       break;</span><br><span class="line">                   &#125;</span><br><span class="line">                   if (e.hash &#x3D;&#x3D; hash &amp;&amp;</span><br><span class="line">                       ((k &#x3D; e.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))</span><br><span class="line">                       break;</span><br><span class="line">                   p &#x3D; e;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           if (e !&#x3D; null) &#123; &#x2F;&#x2F; existing mapping for key</span><br><span class="line">               V oldValue &#x3D; e.value;</span><br><span class="line">               if (!onlyIfAbsent || oldValue &#x3D;&#x3D; null)</span><br><span class="line">                   e.value &#x3D; value;</span><br><span class="line">               afterNodeAccess(e);</span><br><span class="line">               return oldValue;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       ++modCount;</span><br><span class="line">       if (++size &gt; threshold)</span><br><span class="line">           resize();</span><br><span class="line">       afterNodeInsertion(evict);</span><br><span class="line">       return null;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>代码略长，长话短说，前面的大部分都是<code>hashMap</code>的实现，到了最后<code>afterNodeInsertion</code>，这个方法就是留给<code>LinkedHashMap</code>去实现其调换顺序的。我们直接看<code>LinkedHashMap</code>中这个方法的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void afterNodeInsertion(boolean evict) &#123; &#x2F;&#x2F; possibly remove eldest</span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; first;</span><br><span class="line">        if (evict &amp;&amp; (first &#x3D; head) !&#x3D; null &amp;&amp; removeEldestEntry(first)) &#123;</span><br><span class="line">            K key &#x3D; first.key;</span><br><span class="line">            removeNode(hash(key), key, null, false, true);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这个方法主要实现在某些情况下，需要将老的数据移除掉，移除就是通过<code>removeNode</code>实现的，我们不往下继续看，只关注其条件。我们观察到 需要移除老数据的添加有三个.</p>
<ol>
<li>evict的boolean为true</li>
<li>head ！= null</li>
<li>removeEldestEntry(first) 返回true<br>其中，<code>evict</code>在调用时就是传入的值true,而<code>head</code>在<code>LinkedHashMap</code>中初始化并添加数据后，就不会为null了，所以这里需要直接移除老数据的关键条件就是<code>removeEldestEntry</code>这个方法了，而这个方法在<code>LinkedHashMap</code>的实现中默认是范围false的，即默认不用移除掉老的数据。那么当我们需要<code>LinkedHashMap</code>存储的数据达到一定量的时候，移除掉老数据就需要重写<code>removeEldestEntry</code>这个方法了。</li>
</ol>
<h2 id="get"><a href="#get" class="headerlink" title="get"></a>get</h2><p>get的实现在<code>LinkedHashMap</code>重写了，实现也很简单，首先判断有没有这个key，如果有，在判断当前的<code>accessOrder</code>是不是为true，如果为true，则需要将顺序按照访问顺序调整一下，然后将数据返回回去。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public V get(Object key) &#123;</span><br><span class="line">       Node&lt;K,V&gt; e;</span><br><span class="line">       if ((e &#x3D; getNode(hash(key), key)) &#x3D;&#x3D; null)</span><br><span class="line">           return null;</span><br><span class="line">       if (accessOrder)</span><br><span class="line">           afterNodeAccess(e);</span><br><span class="line">       return e.value;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="利用HashMap实现LRUCache"><a href="#利用HashMap实现LRUCache" class="headerlink" title="利用HashMap实现LRUCache"></a>利用<code>HashMap</code>实现LRUCache</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">class LRUCache &#123;</span><br><span class="line">    </span><br><span class="line">    class Node &#123;</span><br><span class="line">        int key;</span><br><span class="line">        int value;</span><br><span class="line">        Node pre;</span><br><span class="line">        Node next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private int capacity;</span><br><span class="line">    </span><br><span class="line">    private Node head, tail;</span><br><span class="line">    </span><br><span class="line">    private Map&lt;Integer, Node&gt; map &#x3D; null;</span><br><span class="line"></span><br><span class="line">    public LRUCache(int capacity) &#123;</span><br><span class="line">        this.capacity &#x3D; capacity;</span><br><span class="line">        map &#x3D; new HashMap&lt;&gt;(capacity);</span><br><span class="line">        head &#x3D; new Node();</span><br><span class="line">        tail &#x3D; new Node();</span><br><span class="line">        head.pre &#x3D; null;</span><br><span class="line">        head.next &#x3D; tail;</span><br><span class="line">        tail.pre &#x3D; head;</span><br><span class="line">        tail.next &#x3D; null;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public int get(int key) &#123;</span><br><span class="line">        Node node &#x3D; map.get(key);</span><br><span class="line">        if (node &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        moveToHead(node);</span><br><span class="line">        return node.value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private void moveToHead(Node node) &#123;</span><br><span class="line">        removeNode(node);</span><br><span class="line">        addNode(node);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private void removeNode(Node node) &#123;</span><br><span class="line">        node.pre.next &#x3D; node.next;</span><br><span class="line">        node.next.pre &#x3D; node.pre;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private void addNode(Node node) &#123;</span><br><span class="line">        node.pre &#x3D; head;</span><br><span class="line">        node.next &#x3D; head.next;</span><br><span class="line">        head.next.pre &#x3D; node;</span><br><span class="line">        head.next &#x3D; node;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void put(int key, int value) &#123;</span><br><span class="line">        Node node &#x3D; map.get(key);</span><br><span class="line">        if (node &#x3D;&#x3D; null) &#123;</span><br><span class="line">            Node newNode &#x3D; new Node();</span><br><span class="line">            newNode.key &#x3D; key;</span><br><span class="line">            newNode.value &#x3D; value;</span><br><span class="line">            map.put(key, newNode);</span><br><span class="line">            addNode(newNode);</span><br><span class="line">            if (map.size() &gt; capacity) &#123;</span><br><span class="line">                Node tail &#x3D; popTail();</span><br><span class="line">                map.remove(tail.key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            node.value &#x3D; value;</span><br><span class="line">            moveToHead(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private Node popTail() &#123;</span><br><span class="line">        Node node &#x3D; tail.pre;</span><br><span class="line">        removeNode(node);</span><br><span class="line">        return node;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://reoger.tk/2018/11/12/java/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E9%98%B6%E6%AE%B5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="reoger">
      <meta itemprop="description" content="reoger">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="reoger的记录">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/11/12/java/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E9%98%B6%E6%AE%B5/" class="post-title-link" itemprop="url">虚拟机类加载阶段</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-11-12 00:23:48" itemprop="dateCreated datePublished" datetime="2018-11-12T00:23:48+08:00">2018-11-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-07-18 14:40:09" itemprop="dateModified" datetime="2020-07-18T14:40:09+08:00">2020-07-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="虚拟机类加载阶段"><a href="#虚拟机类加载阶段" class="headerlink" title="虚拟机类加载阶段"></a>虚拟机类加载阶段</h1><hr>
<p>类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载(Loading)、验证(Verifcation)、准备(Preparation)、解析(Resolution)、初始化(Initiializtion)、使用(Using)和卸载(Unloading) 7个阶段。<br>下面简单介绍这7个阶段。</p>
<h2 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h2><p>加载是类加载过程的一个阶段，加载阶段他需要完成以下3件事情：</p>
<ol>
<li>通过一个类的全限定名来获得定义此类的二进制字节流。</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li>
<li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法去的这个类的各种数据的访问入口。<br>在类的生命周期中，开发人员可控性最强的过程就是加载过程。我们可以通过控制类加载器和加载不同class文件，来实现对加载过程的控制。</li>
</ol>
<h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>为了保证程序的可执行和保证程序是无害的，虚拟机在类加载完了之后，有必要对其进行验证。当然，如果确保了类是安全可执行的，这一步也可以通过指定-X<br>验证阶段主要有四个验证动作：</p>
<ol>
<li>文件格式验证。<br> 主要验证文件格式是否符合要求，例如class文件是否以oxCAFEBAEF开头，版本号时候在有效范围内，常量池是否有不被支持的类型等等。</li>
<li>元数据验证。<br> 这一步是对字节码描述的信息记性语义分析，保证其描述符合java语言规范。主要验证内容包括类是否有父类，是否继承了final类；是否不是抽象类，但没有实现其继承的接口或者抽象类的方法。</li>
<li>字节码验证。<br> 这一步主要是验证数据流和控制流是合法的，是符合逻辑的。这一个主要验证的内容包括，方法体中的类型转换时有效的，跳转的方法是有效的等等。</li>
<li>符号应用验证。<br> 最后一步是校验符号引用是否能转化成直接引用，为下一个阶段的解析做准备。这一步主要校验的内容包括符号应用中通过字符串描述的全限定名是否能找到对应的类；在指定类中是否存在符合房费的字段描述符已经加单名称所描述的方法和字段，符号引用中的类、字段、方法的访问性是否能被当前类访问等等。</li>
</ol>
<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>准备阶段是正式为类变量分享内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。值得注意的一点是，这里只对其类变量（被static修饰）进行内存申请并是初始化，而成员变量的内存申请和初始化则在类初始化的时候一同进行。<br>还有一点，这个只对类变量进行初始化，并不对应赋值，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static int value &#x3D; 123;</span><br></pre></td></tr></table></figure>
<p>在准备之后，其初始化的值为0，而不是123，只有<code>staitc final</code>修饰的常亮才会在准备的时候指定值。例如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static final int value &#x3D; 123;</span><br></pre></td></tr></table></figure>
<p>在准备之后其值就是123了。</p>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>解析阶段是虚拟机将常量池内的符号引用替换成直接引用的过程。解析主要包括三种：</p>
<ol>
<li>类或接口的解析。</li>
<li>字段解析。</li>
<li>类方法解析。</li>
<li>接口方法解析。</li>
</ol>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>类初始化是类加载过程的最后一步，在初始化阶段，才真正开始执行类中定义的java程序代码。<br>在初始化阶段，会对类变量赋程序给定的值。</p>
<p><code>&lt;clinit&gt;</code> 方法是由编辑器自动收集类中所有类变量的赋值动作和静态语句块中的语句合并产生的，编辑器收集的顺序是由语句在源文件中出现的顺序所决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在他之后的变量。在前面的静态语句快可以赋值，但是不能访问。</p>
<hr>
<p>end</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://reoger.tk/2018/11/04/algorithm/%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="reoger">
      <meta itemprop="description" content="reoger">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="reoger的记录">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/11/04/algorithm/%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/" class="post-title-link" itemprop="url">括号生成</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-11-04 01:19:48" itemprop="dateCreated datePublished" datetime="2018-11-04T01:19:48+08:00">2018-11-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-12 23:13:57" itemprop="dateModified" datetime="2020-04-12T23:13:57+08:00">2020-04-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/" itemprop="url" rel="index"><span itemprop="name">algorithm</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="括号生成"><a href="#括号生成" class="headerlink" title="括号生成"></a><a href="https://leetcode-cn.com/problems/generate-parentheses/" target="_blank" rel="noopener">括号生成</a></h3><p>难度 <strong>中等</strong></p>
<p>给出 <em>n</em> 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且<strong>有效的</strong>括号组合。</p>
<p>例如，给出 <em>n</em> =3，生成结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &quot;((()))&quot;,</span><br><span class="line">  &quot;(()())&quot;,</span><br><span class="line">  &quot;(())()&quot;,</span><br><span class="line">  &quot;()(())&quot;,</span><br><span class="line">  &quot;()()()&quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>



<h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><p>Language: <strong>Java</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        traverse(res,<span class="string">""</span>, n, n);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">traverse</span><span class="params">(List&lt;String&gt; res,String single, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left == <span class="number">0</span> &amp;&amp; right == <span class="number">0</span>)&#123;</span><br><span class="line">            res.add(single);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">if</span> (left &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            traverse(res, single+<span class="string">"("</span>, left - <span class="number">1</span> , right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (right &gt; <span class="number">0</span> &amp;&amp; right &gt; left) &#123;</span><br><span class="line">            traverse(res, single+<span class="string">")"</span>, left, right - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>想一想这种生成括号的规则，其实隐含了一条信息：那就是始终左括号的数量要大于或等于右括号的数量。也就是说，剩余的左括号的数量要始终小于等于右括号。左括号只要有，就可以打印；而只有当剩余的右括号数量比左括号大时，才能打印右括号。为了方便理解，我现在假设n = 2，那么根据刚才我说的隐含信息，逻辑应该是这样的：</p>
<ol>
<li><p>肯定要先取一个左括号，此时左括号剩余的数量变为1，右括号剩余数量还是2</p>
</li>
<li><p>第二位取左括号也行，取右括号也行。如果取左括号，那么此时右括号剩余数量为2，左括号剩余数量为0，长成了这个样子”((“；如果取右括号，左右剩余数量都是1，长成这个样子”()”</p>
</li>
<li><p>第三位，如果剩余左括号没了，就只能跟进右括号了，连续两个，最终变成”(())”；而如果现在是”()”的，那么要先左后右，最终变成”()()”.</p>
</li>
</ol>
<p>发现，每一步都有两种选择：左或者右，当然不一定都可行，如果可行，那么往后继续，不可行，终止。</p>
<p>这是什么，二叉树。对于n = 2的情况，他的二叉树应该是这样的：<br><img src="https://img-blog.csdn.net/20160420095708833?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="二叉树"></p>
<p>这棵二叉树表达的东西其实跟我刚才说的是一样的，而我们所要的结果就是这棵二叉树遍历所有路径的结果。由此，不妨先来回忆一下之前“二叉树的所有路径”这道题目（详见：点击打开链接）可以仿照这个方法来解决我们当前的问题。所不同的是，这里我们没有一棵已经给出的二叉树，但是，此处，我们相当于知道了这棵二叉树的左右节点是否为空的条件（就是一开始的隐含信息，左括号要始终大于等于右括号，也就是说剩余的左括号要始终小于等于剩余的右括号），以及不为空时，节点的值（左括号为”(“，右括号为”)”）。</p>
<p>来源： &lt;<a href="https://blog.csdn.net/guoziqing506/article/details/51198069" target="_blank" rel="noopener">https://blog.csdn.net/guoziqing506/article/details/51198069</a> &gt;</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://reoger.tk/2018/11/01/algorithm/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="reoger">
      <meta itemprop="description" content="reoger">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="reoger的记录">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/11/01/algorithm/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/" class="post-title-link" itemprop="url">二叉搜索树的最近公共祖先</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-11-01 23:41:48" itemprop="dateCreated datePublished" datetime="2018-11-01T23:41:48+08:00">2018-11-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-12 23:09:00" itemprop="dateModified" datetime="2020-04-12T23:09:00+08:00">2020-04-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/" itemprop="url" rel="index"><span itemprop="name">algorithm</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="二叉搜索树的最近公共祖先"><a href="#二叉搜索树的最近公共祖先" class="headerlink" title="二叉搜索树的最近公共祖先"></a><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/" target="_blank" rel="noopener">二叉搜索树的最近公共祖先</a></h3><p>难度 <strong>简单</strong></p>
<p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p>
<p>中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。”</p>
<p>例如，给定如下二叉搜索树:  root = [6,2,8,0,4,7,9,null,null,3,5]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">     _______6______</span><br><span class="line">    &#x2F;              \</span><br><span class="line"> ___2__          ___8__</span><br><span class="line">&#x2F;      \        &#x2F;      \</span><br><span class="line">0      _4       7       9</span><br><span class="line">      &#x2F;  \</span><br><span class="line">      3   5</span><br></pre></td></tr></table></figure>

<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">**输入:** root &#x3D; [6,2,8,0,4,7,9,null,null,3,5], p &#x3D; 2, q &#x3D; 8</span><br><span class="line">**输出:** 6 </span><br><span class="line">**解释:** 节点 2 和节点 8 的最近公共祖先是 6。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">**输入:** root &#x3D; [6,2,8,0,4,7,9,null,null,3,5], p &#x3D; 2, q &#x3D; 4</span><br><span class="line">**输出:** 2</span><br><span class="line">**解释:** 节点 &#96;2&#96; 和节点 &#96;4&#96; 的最近公共祖先是 &#96;2&#96;, 因为根据定义最近公共祖先节点可以为节点本身。</span><br></pre></td></tr></table></figure>

<p><strong>说明:</strong></p>
<ul>
<li>所有节点的值都是唯一的。</li>
<li>p、q 为不同节点且均存在于给定的二叉搜索树中。</li>
</ul>
<h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><h3 id="解法1，自顶向下遍历"><a href="#解法1，自顶向下遍历" class="headerlink" title="解法1，自顶向下遍历"></a>解法1，自顶向下遍历</h3><p>我们可以从根结点出发，判断当前结点的左右子树是否包含这两个结点。如果左子树包含两个结点，则它们的最低公共祖先结点也一定在左子树中。如果右子树包含两个结点，则它们的最低公共祖先结点也一定在右子树中。如果一个结点在左子树，而另一个结点在右子树中，则当前结点就是它们的最低公共祖先结点。根据该思路写出代码如下，注意这里已经假定p和q是二叉树中的结点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123;</span><br><span class="line">       if (root &#x3D;&#x3D; null)</span><br><span class="line">           return null;</span><br><span class="line">      if (containTargetTreeNode(root.left, p)  &amp;&amp; containTargetTreeNode(root.left, q))&#123;</span><br><span class="line">          return lowestCommonAncestor(root.left, p, q);</span><br><span class="line">      &#125;else if (containTargetTreeNode(root.right, p)  &amp;&amp; containTargetTreeNode(root.right, q))&#123;</span><br><span class="line">          return lowestCommonAncestor(root.right, p, q);</span><br><span class="line">      &#125;</span><br><span class="line">       return root;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   private boolean containTargetTreeNode(TreeNode root, TreeNode targetNode) &#123;</span><br><span class="line">       if (root &#x3D;&#x3D; null)</span><br><span class="line">           return false;</span><br><span class="line">       if (root &#x3D;&#x3D; targetNode)</span><br><span class="line">           return true;</span><br><span class="line">       return containTargetTreeNode(root.left, targetNode) || containTargetTreeNode(root.right, targetNode);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="思路二：自顶向上"><a href="#思路二：自顶向上" class="headerlink" title="思路二：自顶向上"></a>思路二：自顶向上</h3><p>由于自顶向下的方法需要重复遍历结点，使用自底向上的方法可以避免这种情况。</p>
<p>自底向上遍历结点，一旦遇到结点等于p或者q，则将其向上传递给它的父结点。父结点会判断它的左右子树是否都包含其中一个结点，如果是，则父结点一定是这两个节点p和q的LCA，传递父结点到root。如果不是，我们向上传递其中的包含结点p或者q的子结点，或者NULL(如果子结点不包含任何一个)。该方法时间复杂度为O(N)。</p>
<p>Language: <strong>Java</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (p == root || q == root)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        TreeNode l = lowestCommonAncestor(root.left, p, q);</span><br><span class="line">        TreeNode r = lowestCommonAncestor(root.right, p, q);</span><br><span class="line">        <span class="keyword">if</span> (l != <span class="keyword">null</span> &amp;&amp; r != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">return</span> l == <span class="keyword">null</span> ? r : l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="思路三：利用搜索树的性质"><a href="#思路三：利用搜索树的性质" class="headerlink" title="思路三：利用搜索树的性质"></a>思路三：利用搜索树的性质</h3><p>因为树是二叉树，我们从根节点开始遍历，一定有顶点root的值大于p和q的值时，p、q的最近祖先一定在root的左子树下，当root的值小于p、q的值时，那么p、q的最近祖先一定在root的左子树下，不是上述两种情况的话，说明当前的root已经是最近的祖先了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor3</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (root.val &gt; p.val &amp;&amp; root.val &gt; q.val)</span><br><span class="line">            <span class="keyword">return</span> lowestCommonAncestor3(root.left, p, q);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (root.val &lt; p.val &amp;&amp; root.val &lt; q.val)</span><br><span class="line">            <span class="keyword">return</span> lowestCommonAncestor3(root.right, p, q);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://reoger.tk/2018/11/01/algorithm/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="reoger">
      <meta itemprop="description" content="reoger">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="reoger的记录">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/11/01/algorithm/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C/" class="post-title-link" itemprop="url">二叉树中的最大路径和</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-11-01 01:06:52" itemprop="dateCreated datePublished" datetime="2018-11-01T01:06:52+08:00">2018-11-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-12 23:09:29" itemprop="dateModified" datetime="2020-04-12T23:09:29+08:00">2020-04-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/" itemprop="url" rel="index"><span itemprop="name">algorithm</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="二叉树中的最大路径和"><a href="#二叉树中的最大路径和" class="headerlink" title="二叉树中的最大路径和"></a><a href="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/" target="_blank" rel="noopener">二叉树中的最大路径和</a></h3><p>难度 <strong>困难</strong></p>
<p>给定一个<strong>非空</strong>二叉树，返回其最大路径和。</p>
<p>本题中，路径被定义为一条从树中任意节点出发，达到任意节点的序列。该路径<strong>至少包含一个</strong>节点，且不一定经过根节点。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">**输入:** [1,2,3]</span><br><span class="line"></span><br><span class="line">       **1**</span><br><span class="line">      **&#x2F; \**</span><br><span class="line">     **2**   **3**</span><br><span class="line"></span><br><span class="line">**输出:** 6</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">**输入:** [-10,9,20,null,null,15,7]</span><br><span class="line"></span><br><span class="line">   -10</span><br><span class="line">   &#x2F; \</span><br><span class="line">  9  **20**</span><br><span class="line">    **&#x2F;  \**</span><br><span class="line">   **15   7**</span><br><span class="line"></span><br><span class="line">**输出:** 42</span><br></pre></td></tr></table></figure>

<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>需找一个最大的路径和，势必会以某一个节点为顶点，我们以某个顶点去寻找以其为顶点的最大的路径和，然后遍历二叉树上所有的节点，选出最大的路径和即可。</p>
<h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><p>Language: <strong>Java</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">         res = Integer.MIN_VALUE;</span><br><span class="line">        oneOther(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">oneOther</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = oneOther(root.left);</span><br><span class="line">        <span class="keyword">int</span> right = oneOther(root.right);</span><br><span class="line">        res = Math.max(Math.max(left, <span class="number">0</span>) + Math.max(right, <span class="number">0</span>) + root.val , res);</span><br><span class="line">           <span class="keyword">return</span> Math.max(Math.max(left,right), <span class="number">0</span>)+ root.val;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://reoger.tk/2018/10/31/algorithm/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%ACk%E4%B8%AA%E7%BB%93%E7%82%B9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="reoger">
      <meta itemprop="description" content="reoger">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="reoger的记录">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/10/31/algorithm/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%ACk%E4%B8%AA%E7%BB%93%E7%82%B9/" class="post-title-link" itemprop="url">二叉搜索树的第k个结点</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-10-31 00:08:52" itemprop="dateCreated datePublished" datetime="2018-10-31T00:08:52+08:00">2018-10-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-12 23:09:20" itemprop="dateModified" datetime="2020-04-12T23:09:20+08:00">2020-04-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/" itemprop="url" rel="index"><span itemprop="name">algorithm</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="二叉搜索树中第K小的元素"><a href="#二叉搜索树中第K小的元素" class="headerlink" title="二叉搜索树中第K小的元素"></a><a href="https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/" target="_blank" rel="noopener">二叉搜索树中第K小的元素</a></h3><p>难度 <strong>中等</strong></p>
<p>给定一个二叉搜索树，编写一个函数 <code>kthSmallest</code> 来查找其中第 *<em>k *</em>个最小的元素。</p>
<p><strong>说明：</strong><br>你可以假设 k 总是有效的，1 ≤ k ≤ 二叉搜索树元素个数。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">**输入:** root &#x3D; [3,1,4,null,2], k &#x3D; 1</span><br><span class="line">   3</span><br><span class="line">  &#x2F; \</span><br><span class="line"> 1   4</span><br><span class="line">  \</span><br><span class="line">   2</span><br><span class="line">**输出:** 1</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">**输入:** root &#x3D; [5,3,6,2,4,null,null,1], k &#x3D; 3</span><br><span class="line">       5</span><br><span class="line">      &#x2F; \</span><br><span class="line">     3   6</span><br><span class="line">    &#x2F; \</span><br><span class="line">   2   4</span><br><span class="line">  &#x2F;</span><br><span class="line"> 1</span><br><span class="line">**输出:** 3</span><br></pre></td></tr></table></figure>

<p><strong>进阶：</strong><br>如果二叉搜索树经常被修改（插入/删除操作）并且你需要频繁地查找第 k 小的值，你将如何优化 <code>kthSmallest</code> 函数？</p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>二叉搜索树 已经就是一个排好序的树了，我们只要按照中序遍历到第k个数，输出第k个数的值即可。</p>
<h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><p>Language: <strong>Java</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span> (root == <span class="keyword">null</span> || k &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        count = k;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> inOrder(root);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">inOrder</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> val = inOrder(root.left);</span><br><span class="line">        <span class="keyword">if</span>(count == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> val;</span><br><span class="line">        <span class="keyword">if</span>(--count == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> root.val;</span><br><span class="line">        <span class="keyword">return</span> inOrder(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者使用方法二：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">        private int index&#x3D;0;</span><br><span class="line">        public int kthSmallest(TreeNode root, int k) &#123;</span><br><span class="line">            if(root&#x3D;&#x3D;null)</span><br><span class="line">                return Integer.MAX_VALUE;</span><br><span class="line">            int ret&#x3D;kthSmallest(root.left,k);</span><br><span class="line">            if(ret!&#x3D;Integer.MAX_VALUE)</span><br><span class="line">                return ret;</span><br><span class="line">            index++;</span><br><span class="line">            if(index&#x3D;&#x3D;k)</span><br><span class="line">            &#123;</span><br><span class="line">                return root.val;</span><br><span class="line">            &#125;</span><br><span class="line">            return  kthSmallest(root.right,k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://reoger.tk/2018/10/14/java/Class%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84--%E5%B8%B8%E9%87%8F%E6%B1%A0%EF%BC%88%E4%B8%80%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="reoger">
      <meta itemprop="description" content="reoger">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="reoger的记录">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/10/14/java/Class%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84--%E5%B8%B8%E9%87%8F%E6%B1%A0%EF%BC%88%E4%B8%80%EF%BC%89/" class="post-title-link" itemprop="url">Class文件结构--常量池（一）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-10-14 14:56:55" itemprop="dateCreated datePublished" datetime="2018-10-14T14:56:55+08:00">2018-10-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-07-18 14:39:04" itemprop="dateModified" datetime="2020-07-18T14:39:04+08:00">2020-07-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Class文件结构–常量池（一）"><a href="#Class文件结构–常量池（一）" class="headerlink" title="Class文件结构–常量池（一）"></a>Class文件结构–常量池（一）</h1><hr>
<p>转载自<a href="https://www.jianshu.com/p/d8492e748c57" target="_blank" rel="noopener">https://www.jianshu.com/p/d8492e748c57</a></p>
<ul>
<li>字节码查看工具：WinHex</li>
</ul>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul>
<li>Java虚拟机实现语言无关性的基石就是Class文件<br><img src="https://upload-images.jianshu.io/upload_images/3458176-30ce955fde8883d1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/830/format/webp" alt="Java虚拟机提供的语言无关性"></li>
<li>这篇文章讲Class格式文件的的魔数、版本号和常量池。主要内容是常量池。</li>
</ul>
<h1 id="Class类文件的结构"><a href="#Class类文件的结构" class="headerlink" title="Class类文件的结构"></a>Class类文件的结构</h1><h2 id="全局规范"><a href="#全局规范" class="headerlink" title="全局规范"></a>全局规范</h2><ul>
<li><p><strong>1.任何一个Class文件都对应着唯一一个类或接口的定义信息，但反过来说，类或接口并不一定都得定义在文件里（譬如类或接口也可以通过类加载器直接生成）。本章中，只是通俗地将任意一个有效的类或接口所应当满足的格式称为“Class文件格式”，实际上它并不一定以磁盘文件的形式存在。“Class文件”应当是一串二进制的字节流，无论以何种形式存在。</strong></p>
</li>
<li><p>2.Class文件是一组以8位字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在Class文件之中，当遇到需要占用8位字节以上空间的数据项时，则会按照<strong>高位在前（Big-Endian）</strong>的方式分割成若干个8位字节进行存储。无符号数据类型最大占8个字节。</p>
</li>
<li><p>3.Class文件中存储数据的类型：无符号数和表。</p>
</li>
<li><p><strong>无符号数（基本数据类型）</strong>：以u1、u2、u4、u8来分别代表1个字节、2个字节、4个字节和8个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串值。</p>
</li>
<li><p><strong>表（复合数据类型）</strong>：是由多个无符号数或者其他表作为数据项构成的复合数据类型，所有表都习惯性地“_info”结尾。表用于描述有层次关系的复合结构的数据。表是一个统称，就好比把ArrayList、LinkedList、Set都是称为集合(Collection)，但是每个集合的内部结构都是不同的，Class中有很多不同的表。如下图中cp_info类型,是表类型，但是它是一个固定结构的类型吗？不是，它好比Collection集合下的List集合，只是一类集合的统称，实际上cp_info表是14种具体表类型的统称，constant_pool_count-1指出了有多少个cp_info表，那到底是哪些具体的表，就需要具体看了。</p>
</li>
<li><p>4.整个Class文件本质上就是一张表，下表就是Class文件格式。Class中所有内容都在这些类型中定义了。</p>
<ul>
<li><p><strong>注：表中的数据项，无论是顺序还是数量，甚至于数据存储的字节序（Byte Ordering,Class文件中字节序为Big-Endian）这样的细节，都是被严格限定的，哪个字节代表什么含义，长度是多少，先后顺序如何，都不允许改变。</strong>  </p>
<p><img src="https:https://upload-images.jianshu.io/upload_images/3458176-8fce946bab563076.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/972/format/webp" alt=""></p>
<p>Class文件格式</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3458176-183170e077348dd9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/847/format/webp" alt=""></p>
<p>class文件结构</p>
</li>
</ul>
</li>
<li><p>5.无论是无符号数还是表，当需要描述同一类型但数量不定的多个数据时，经常会使用一个前置的容量计数器加若干个连续的数据项的形式，这时称这一系列连续的某一类型的数据为某一类型的集合。</p>
</li>
<li><p><strong>如上表的描述常量池数据使用了一个constant_pool_count、多个constant_pool,其中constant_pool是表类型并且数量为constant_pool_count值减去1，把一个constant_pool_count和多个constant_pool数据项称为常量池集合</strong></p>
</li>
<li><p>从Class文件格式中可以看出有：常量池集合、接口索引集合、字段表集合、方法表集合、属性表集合。</p>
</li>
<li><p>6.具体的Class文件案例，以下讲解会通过这个TestClass类的<code>TestClass.class</code>文件来分析。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">package com.zlcook.clazz;</span><br><span class="line"></span><br><span class="line">public class TestClass&#123;</span><br><span class="line">  private int m;</span><br><span class="line">  public int inc()&#123;</span><br><span class="line">   return m+1;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="1-魔数与Class文件的版本"><a href="#1-魔数与Class文件的版本" class="headerlink" title="1. 魔数与Class文件的版本"></a>1. 魔数与Class文件的版本</h2><ul>
<li>由上表得Class文件的前三个数据类型存储了魔数（magic)、次版本号(minor_version)、主版本号(major_version)的值，数据类型分别为u4、u2、u2。共占8个字节。</li>
<li>魔数：0xCAFEBABE （16进制），值固定，唯一作用是确定这个文件是否为一个能被虚拟机接受的Class文件。</li>
<li>Class文件版本号：次版本号组成u2+主版本号u2。共占4个字节。</li>
<li><strong>高版本的JDK能向下兼容以前的版本的Class文件，但不能运行高版本的Class文件。</strong></li>
<li>JDK1.1的版本号为45.0-45.65535（10进制），之后每个大版本发布主版本号加1，如：JDK1.2：46.0~46.65535。</li>
<li>例如：Class文件中紧接着魔数的4个字节的16进制为： ox00000034，那么它代表的十进制版本号为：次版本号为ox0000=0，主版本号为：ox0034 = 52。所以ox00000034的版本号为52.0，对应的JDK版本为JDK1.8</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/3458176-4113215a9048a30f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/284/format/webp" alt=""></p>
<p><code>TestClass.class</code>文件的前8个字节</p>
<h2 id="2-常量池"><a href="#2-常量池" class="headerlink" title="2. 常量池"></a>2. 常量池</h2><ul>
<li>先了解常量池中需要存放哪些内容，再讨论用什么类来存放这些内容。</li>
</ul>
<h3 id="2-1-常量池中存放的内容"><a href="#2-1-常量池中存放的内容" class="headerlink" title="2.1 常量池中存放的内容"></a>2.1 常量池中存放的内容</h3><ul>
<li><p>Class文件中包含常量池，那么我就需要知道常量池会包含哪些内容，接下来才是关心class格式文件用什么类型来存放这些内容。</p>
</li>
<li><p><strong>字面量（Literal）</strong></p>
</li>
<li><p>字面量比较接近于Java语言层面的常量概念，如文本字符串、声明为final的常量值等。</p>
</li>
<li><p><strong>符号引用（Symbolic References）</strong></p>
</li>
<li><p>符号引用则属于编译原理方面的概念，包括了下面三类常量：<br>类和接口的全限定名（Fully Qualified Name）<br>字段的名称和描述符（Descriptor）<br>方法的名称和描述符</p>
</li>
<li><p><strong>其它：</strong>常量池中<strong>主要</strong>内容是上面2项，说明还有其它内容，这部分内容，在下面我们看到用来描述常量池内容的14种常量项的介绍时就发现标志为15、16、18的常量项类型是用来支持动态语言调用的（jdk1.7时才加入的）。</p>
</li>
<li><p>常量池：可以理解为Class文件之中的资源仓库，它是Class文件结构中与其他项目关联最多的数据类型（后面的很多数据类型都会指向此处），也是占用Class文件空间最大的数据项目之一。</p>
</li>
</ul>
<h3 id="2-2-常量池中为什么要包含这些内容"><a href="#2-2-常量池中为什么要包含这些内容" class="headerlink" title="2.2 常量池中为什么要包含这些内容"></a>2.2 常量池中为什么要包含这些内容</h3><ul>
<li>Java代码在进行Javac编译的时候，并不像C和C++那样有“连接”这一步骤，而是在虚拟机加载Class文件的时候进行动态连接。也就是说，在Class文件中不会保存各个方法、字段的最终内存布局信息，因此这些字段、方法的符号引用不经过运行期转换的话无法得到真正的内存入口地址，也就无法直接被虚拟机使用。当虚拟机运行时，需要从常量池获得对应的符号引用，再在类创建时或运行时解析、翻译到具体的内存地址之中。关于类的创建和动态连接的内容，在虚拟机类加载过程时再进行详细讲解。</li>
</ul>
<h3 id="2-3-Class文件中如何描述常量池中内容"><a href="#2-3-Class文件中如何描述常量池中内容" class="headerlink" title="2.3 Class文件中如何描述常量池中内容"></a>2.3 Class文件中如何描述常量池中内容</h3><ul>
<li><p>知道Class文件的常量池包含的内容后，我们下面就来看看class格式文件使用了哪些类型数据来存放常量池的内容。</p>
</li>
<li><p>由Class文件格式可得紧接着主版本号的是常量池入口。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
</tr>
</thead>
<tbody><tr>
<td>u2（无符号数）</td>
<td>constant_pool_count</td>
<td>1</td>
</tr>
<tr>
<td>cp_info（表）</td>
<td>constant_pool</td>
<td>constant_pool_count-1</td>
</tr>
</tbody></table>
<ul>
<li><p>占用的字节数：2+(constant_pool_count-1)个具体表所占字节。</p>
</li>
<li><p>由上表可见，Class文件使用了一个前置的容量计数器（constant_pool_count）加若干个连续的数据项（constant_pool）的形式来描述常量池内容。我们把这一系列连续常量池数据称为常量池集合。</p>
</li>
<li><p>先给看一下TestClass.class文件全局的内容，下面就来分析其中常量池中的内容，其它内容后面的文章在分析。从图片也可以看出常量池内容占据了class文件的很大一部分，当然TestClass类中代码比较少就更显得常量池内容的多了。</p>
</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/3458176-da04f13d9345d534.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/633/format/webp" alt="TestClass.class文件的16进制内容"></p>
<h4 id="2-3-1-constant-pool-count"><a href="#2-3-1-constant-pool-count" class="headerlink" title="2.3.1 constant_pool_count"></a>2.3.1 constant_pool_count</h4><ul>
<li><p>常量池容量计数值（u2类型）：<strong>从1开始</strong>，表示常量池中有多少项常量。即constant_pool_count=1表示常量池中有0个常量项。</p>
</li>
<li><p>设计者将第0项常量空出来是有特殊考虑的，这样做的目的在于满足后面某些指向常量池的索引值的数据在特定情况下需要表达“不引用任何一个常量池项目”的含义，这种情况就可以把索引值置为0来表示。Class文件结构中只有常量池的容量计数是从1开始，对于其他集合类型，包括接口索引集合、字段表集合、方法表集合等的容量计数都与一般习惯相同，是从0开始的。</p>
</li>
<li><p>TestClass.class文件中constant_pool_count的十进制值为19，表示常量池中有18项常量，索引范围1-18。</p>
</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/3458176-1708ec53425bf43f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/385/format/webp" alt=""></p>
<p>TestClass.class文件中constant_pool_count的十进制值为19</p>
<h4 id="2-3-2-constant-pool"><a href="#2-3-2-constant-pool" class="headerlink" title="2.3.2 constant_pool"></a>2.3.2 constant_pool</h4><ul>
<li>constant_pool_count表明了后面有多少个常量项。</li>
</ul>
<h5 id="14种常量项结构"><a href="#14种常量项结构" class="headerlink" title="14种常量项结构"></a>14种常量项结构</h5><ul>
<li>常量池中每一项常量都是一个表，JDK1.7之后共有14种不同的表结构数据。一个常量池中的每个常量项都逃不脱这14种结构。根据下图每个类型的描述我们也可以知道每个类型是用来描述常量池中哪些内容（主要是字面量、符号引用）的。比如：CONSTANT_Integer_info是用来描述常量池中字面量信息的，而且只是整型字面量信息。而标志为15、16、18的常量项类型是用来支持动态语言调用的（jdk1.7时才加入的）。</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/3458176-cc110223178a4215.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/977/format/webp" alt="常量池中的14种项目类型"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/3458176-8b9bb010f69e4a93.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/701/format/webp" alt="常量池中的14种常量项的结构总表"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/3458176-878fa839b1e28cf3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/694/format/webp" alt="常量池中的14种常量项的结构总表（续）"></p>
<ul>
<li><p>这14种表（或者常量项结构）的共同点是：表开始的第一位是一个u1类型的标志位（tag），代表当前这个常量项使用的是哪种表结构，即哪种常量类型。</p>
</li>
<li><p>这14种常量项结构还有一个特点是，其中13表占用得字节固定，只有CONSTANT_Utf8_info占用字节不固定，其大小由length决定。为什么呢？因为从常量池存放的内容可知，其存放的是字面量和符号引用，最终这些内容都会是一个字符串，这些字符串的大小是在编写程序时才确定，比如你定义一个类，类名可以取长取短，所以在没编译前，无法确定大小不固定，编译后，通过utf-8编码，就可以知道其长度。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>表</th>
<th>占用字节</th>
</tr>
</thead>
<tbody><tr>
<td>CONSTANT_Class_info</td>
<td>3</td>
</tr>
<tr>
<td>CONSTANT_Integer_info</td>
<td>5</td>
</tr>
<tr>
<td>CONSTANT_Fieldref_info</td>
<td>5</td>
</tr>
<tr>
<td>CONSTANT_Methodref_info</td>
<td>5</td>
</tr>
<tr>
<td>CONSTANT_Utf8_info</td>
<td>不固定，取决于length大小</td>
</tr>
</tbody></table>
<h2 id="2-4-查找testClass-class文件的第一个常量项内容"><a href="#2-4-查找testClass-class文件的第一个常量项内容" class="headerlink" title="2.4 查找testClass.class文件的第一个常量项内容"></a>2.4 查找testClass.class文件的第一个常量项内容</h2><ul>
<li>由上面constant_pool_count得到值为19，因为从1开始计数，所以说明后面有18个常量项，由于每个常量项的表结构都不同但是第一位相同，所以读到第一位就可以确定表结构了。下面我们就来查看第一个常量项包含得内容，至于其它17个常量项内容类似，最后还会介绍java提供得一个工具命令javap来帮我们分析class文件字节码内容。</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/3458176-22b038defbeda453.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/655/format/webp" alt="第一个表的tag为10"></p>
<ul>
<li>由上图可知常量池中第一项常量标志的16进制值是0x0A=10,查表发现这个常量属于CONSTANT_Methodref_info类型，此类型表示类中方法的符号引用。查看该类型的结构如下：</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/3458176-18d7609da23c0b93.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/851/format/webp" alt="CONSTANT\_Methodref\_info类型结构"></p>
<ul>
<li>CONSTANT_Methodref_info型常量的第二个数据项为index，类型是u2，index存储的是一个索引值，从class文件中查得该值为oX0004=4，即它指向常量池中第4个常量；第三个数据项也是索引其值为0X000F=15，指向常量池种第15个常量。</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/3458176-1a800d5b071be1b3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/623/format/webp" alt=""></p>
<p>Paste_Image.png</p>
<ul>
<li>到此为止，第一个常量项是CONSTANT_Methodref_info型常量项，该类型常量项用来表示类中方法的符号引用，其内容为tag=10,index1=4,index2=15，因为其表示的是类中方法的符号引用，所以index中存放的不是一个具体得内容，而是一个索引位置，所以说其具体内容存放在另一个常量项中。下面我们就来看看其索引指向的常量项（即第4个常量项）的内容到底是什么？</li>
<li>找第4个常量项之前需要知道第4个常量项的开始位置，所以需要知道前3个常量项所占字节数。那好就看第2个常量项，由于第一个常量项共占了5个字节，则紧接着的字节就为第二个常量项的tag，如下图可得其值为0X09=9，说明第2个常量项得项目类型为CONSTANT_Fieldref_info。查表得其该类型得字节长度固定占5个字节。</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/3458176-b27b29fd146c1371.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/638/format/webp" alt=""></p>
<p>第二个常量项</p>
<ul>
<li>依次类推查的第3,4个常量项为CONSTANT_Class_info型。如下图：</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/3458176-9dedb81d1b044555.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/646/format/webp" alt="前4个常量项"></p>
<ul>
<li>下面就看第四个常量项CONSTANT_Class_info的内容0X070012。 CONSTANT_Class_info存放的是指向类或接口的符号引用。</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/3458176-31580b94471eec94.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/641/format/webp" alt="CONSTANT\_Class\_info型常量项"></p>
<p>根据CONSTANT_Class_info项常量项的结构可知其index数据项又是一个索引项，指向全限定名常量项索引，index数据项的值为0X12=18，表示指向第18个常量项，根据constant_pool_count的值为19可得，常量池中一共有18个常量项，巧了正好在最后一个，但是要知道18个常量项必须知道前17个常量项所占字节，这里就不一一找了，最后找到第18个常量项CONSTANT_Utf8_info在class文件中包含的内容如下：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3458176-942c562db653d825.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/649/format/webp" alt="第18个常量项"></p>
<ul>
<li><img src="https://upload-images.jianshu.io/upload_images/3458176-6d21f61844e69dc4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/851/format/webp" alt="CONSTANT\_Utf8\_info型表的结构"></li>
</ul>
<ul>
<li><p>根据tag等于1得第18项是CONSTANT_Utf8_info型，该类型存储UTF-8编码的字符串，在TestClass.class文件种该常量项种个数据项的内容如下：</p>
<ul>
<li>length(u2):表示UTF-8编码的字符串占用的字节数，值为0x0010=16.</li>
<li>bytes(u1):表示长度为length的UTF-8编码的字符串.</li>
<li>因为length=16，所以 length后面紧跟的长度为16个字节的连续数据是一个使用<strong>UTF-8缩略编码</strong>表示的字符串。后面紧跟的第一个字节为0x6A=106，那该编码代表的字符为j，我们发现106其实就是字符j对应的<a href="https://link.jianshu.com?t=http://baike.baidu.com/link?url=yWgaMCeHhkhUQfJByEHL7PwMq1jWtYH8sGqB063JSCSy4Si2bWfVPzVMClgYqGyhW8tpLBd6qKWYLISuGI1024oRv9HEUOV_XaIi4QeCE2GTKQHAVU8DcVtr6Gu2UFDZhImE37QR1-FVFHKkg66k3a" target="_blank" rel="noopener">ASCII码</a>。后面16个字节代表的字符就是: java/lang/Object</li>
</ul>
</li>
</ul>
<p>到此为止，我们得到了第一个常量项CONSTANT_Methodref_info的第二个数据项index指向的内容为CONSTANT_Class_info常量项，CONSTANT_Class_info常量的第二个数据项index指向CONSTANT_Utf8_info常量项，CONSTANT_Utf8_info常量项的内容为 java/lang/Object 。<br>当然CONSTANT_Methodref_info常量项还有第三个数据项index，其存放的也是一个其他常量的索引。</p>
<ul>
<li>根据上面的找法我们就可以找出常量池中包含的内容：字面量和符号引用。</li>
</ul>
<h2 id="2-5-采用javap命令分析class文件"><a href="#2-5-采用javap命令分析class文件" class="headerlink" title="2.5 采用javap命令分析class文件"></a>2.5 采用javap命令分析class文件</h2><ul>
<li><p>根据上面的找法我们就可以找出常量池中包含的内容：字面量和符号引用。java考虑到这种找法太麻烦了，所以提供了一个命令javap来帮助我们分析class文件的内容。</p>
</li>
<li><p>javap分析class文件用法：javap -verbose class文件名</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">$ javap -verbose TestClass.class</span><br><span class="line">Classfile &#x2F;E:&#x2F;studytry&#x2F;com&#x2F;zlcook&#x2F;clazz&#x2F;TestClass.class</span><br><span class="line">  Last modified 2017-4-7; size 292 bytes</span><br><span class="line">  MD5 checksum 486567c6d4d7432fc359230fed9c92c7</span><br><span class="line">  Compiled from &quot;TestClass.java&quot;</span><br><span class="line">public class com.zlcook.clazz.TestClass</span><br><span class="line">  SourceFile: &quot;TestClass.java&quot;</span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: 52</span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #1 &#x3D; Methodref          #4.#15         &#x2F;&#x2F;  java&#x2F;lang&#x2F;Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #2 &#x3D; Fieldref           #3.#16         &#x2F;&#x2F;  com&#x2F;zlcook&#x2F;clazz&#x2F;TestClass.m:I</span><br><span class="line">   #3 &#x3D; Class              #17            &#x2F;&#x2F;  com&#x2F;zlcook&#x2F;clazz&#x2F;TestClass</span><br><span class="line">   #4 &#x3D; Class              #18            &#x2F;&#x2F;  java&#x2F;lang&#x2F;Object</span><br><span class="line">   #5 &#x3D; Utf8               m</span><br><span class="line">   #6 &#x3D; Utf8               I</span><br><span class="line">   #7 &#x3D; Utf8               &lt;init&gt;</span><br><span class="line">   #8 &#x3D; Utf8               ()V</span><br><span class="line">   #9 &#x3D; Utf8               Code</span><br><span class="line">  #10 &#x3D; Utf8               LineNumberTable</span><br><span class="line">  #11 &#x3D; Utf8               inc</span><br><span class="line">  #12 &#x3D; Utf8               ()I</span><br><span class="line">  #13 &#x3D; Utf8               SourceFile</span><br><span class="line">  #14 &#x3D; Utf8               TestClass.java</span><br><span class="line">  #15 &#x3D; NameAndType        #7:#8          &#x2F;&#x2F;  &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #16 &#x3D; NameAndType        #5:#6          &#x2F;&#x2F;  m:I</span><br><span class="line">  #17 &#x3D; Utf8               com&#x2F;zlcook&#x2F;clazz&#x2F;TestClass</span><br><span class="line">  #18 &#x3D; Utf8               java&#x2F;lang&#x2F;Object</span><br><span class="line">&#123;</span><br><span class="line">  public com.zlcook.clazz.TestClass();</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack&#x3D;1, locals&#x3D;1, args_size&#x3D;1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: invokespecial #1                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         4: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 2: 0</span><br><span class="line"></span><br><span class="line">  public int inc();</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack&#x3D;2, locals&#x3D;1, args_size&#x3D;1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: getfield      #2                  &#x2F;&#x2F; Field m:I</span><br><span class="line">         4: iconst_1</span><br><span class="line">         5: iadd</span><br><span class="line">         6: ireturn</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 6: 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>上面通过javap命令得到的结果，该结果显示的很友好，由过上面的理论我们可以很清楚的看到常量池一共18项：其中第一项如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#1 &#x3D; Methodref          #4.#15       &#x2F;&#x2F;  java&#x2F;lang&#x2F;Object.&quot;&lt;init&gt;&quot;:()V</span><br></pre></td></tr></table></figure>
</li>
<li><p>和我们通过手动方式查看第一个常量项CONSTANT_Methodref_info对比一下就知道javap显示的内容是多么友好了。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>第一个常量项</th>
<th>第几个</th>
<th>tag</th>
<th>index</th>
<th>index</th>
<th>最终代表的内容</th>
</tr>
</thead>
<tbody><tr>
<td>class中16进制值</td>
<td>0X0A</td>
<td>0X004</td>
<td>0X000F</td>
<td></td>
<td></td>
</tr>
<tr>
<td>转换成10进制值</td>
<td>10</td>
<td>4</td>
<td>15</td>
<td>查完4和15才知道</td>
<td></td>
</tr>
<tr>
<td>javap分析显示的友好值</td>
<td>#1</td>
<td>Methodref</td>
<td>#4</td>
<td>#15</td>
<td>java/lang/Object.”&lt;init&gt;”:()V</td>
</tr>
</tbody></table>
<h2 id="2-6-class文件中包含的内容"><a href="#2-6-class文件中包含的内容" class="headerlink" title="2.6 class文件中包含的内容"></a>2.6 class文件中包含的内容</h2><ul>
<li><p>下面我们来看一下class文件中常量池的内容和java源码中的内容。</p>
</li>
<li><p>TestClass.java代码内容</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">package com.zlcook.clazz;</span><br><span class="line"></span><br><span class="line">public class TestClass&#123;</span><br><span class="line">  private int m;</span><br><span class="line">  public int inc()&#123;</span><br><span class="line">   return m+1;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>TestClass.class中常量池内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Constant pool:</span><br><span class="line">   #1 &#x3D; Methodref          #4.#15         &#x2F;&#x2F;  java&#x2F;lang&#x2F;Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #2 &#x3D; Fieldref           #3.#16         &#x2F;&#x2F;  com&#x2F;zlcook&#x2F;clazz&#x2F;TestClass.m:I</span><br><span class="line">   #3 &#x3D; Class              #17            &#x2F;&#x2F;  com&#x2F;zlcook&#x2F;clazz&#x2F;TestClass</span><br><span class="line">   #4 &#x3D; Class              #18            &#x2F;&#x2F;  java&#x2F;lang&#x2F;Object</span><br><span class="line">   #5 &#x3D; Utf8               m</span><br><span class="line">   #6 &#x3D; Utf8               I</span><br><span class="line">   #7 &#x3D; Utf8               &lt;init&gt;</span><br><span class="line">   #8 &#x3D; Utf8               ()V</span><br><span class="line">   #9 &#x3D; Utf8               Code</span><br><span class="line">  #10 &#x3D; Utf8               LineNumberTable</span><br><span class="line">  #11 &#x3D; Utf8               inc</span><br><span class="line">  #12 &#x3D; Utf8               ()I</span><br><span class="line">  #13 &#x3D; Utf8               SourceFile</span><br><span class="line">  #14 &#x3D; Utf8               TestClass.java</span><br><span class="line">  #15 &#x3D; NameAndType        #7:#8          &#x2F;&#x2F;  &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #16 &#x3D; NameAndType        #5:#6          &#x2F;&#x2F;  m:I</span><br><span class="line">  #17 &#x3D; Utf8               com&#x2F;zlcook&#x2F;clazz&#x2F;TestClass</span><br><span class="line">  #18 &#x3D; Utf8               java&#x2F;lang&#x2F;Object</span><br></pre></td></tr></table></figure>
</li>
<li><p>再复习一下常量池中主要存放字面量：如文本字符串、声明为final的常量值等。和符号引用：类和接口的全限定名、字段的名称和描述符、方法的名称和描述符。</p>
</li>
<li><p>所以出现com/zlcook/clazz/TestClass、java/lang/Object、m、inc都是应该的，那么I、V、<init>、LineNumberTable都是什么？那肯定是字段描述符或者是方法描述符了。这部分是编译时自动生成的，它们会被class文件中其它部分（字段表field_info、方法表method_info、属性表attribute_info）引用到，它们会用来描述一些不方便使用“固定字节”进行表达的内容。譬如描述方法的返回值是什么？有几个参数？每个参数的类型是什么？因为Java中的“类”是无穷无尽的，无法通过简单的无符号字节来描述一个方法用到了什么类，因此在描述方法的这些信息时，需要引用常量表中的符号引用进行表达。</p>
</li>
</ul>
<h2 id="3-哪些字面量会进入常量池中"><a href="#3-哪些字面量会进入常量池中" class="headerlink" title="3. 哪些字面量会进入常量池中"></a>3. 哪些字面量会进入常量池中</h2><ul>
<li>我们知道class文件存放字面量：如文本字符串、声明为final的常量值等。这里的“等”就挺烦人。</li>
<li>下面我们来看看哪些字面量会进入常量池。（jdk1.8.0环境）</li>
</ul>
<p><strong>8种基本类型：</strong></p>
<p>测试案例：</p>
<ul>
<li>final类型 FinalTest.java代码</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class FinalTest&#123;</span><br><span class="line"></span><br><span class="line">   private final int int_num &#x3D;12;</span><br><span class="line">   private final char char_num &#x3D; &#39;a&#39;;</span><br><span class="line">   private final short short_num &#x3D;30;</span><br><span class="line">   private final float float_num &#x3D; 45.3f;</span><br><span class="line">   private final double double_num &#x3D;39.8;</span><br><span class="line">   private final byte byte_num &#x3D;121;</span><br><span class="line">   private final long long_num &#x3D; 2323L;</span><br><span class="line">   private final boolean boolean_flage &#x3D; true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>非final类型 test.java代码<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class test&#123;</span><br><span class="line"></span><br><span class="line">   private int int_num &#x3D;12;</span><br><span class="line">   private char char_num &#x3D; &#39;a&#39;;</span><br><span class="line">   private short short_num &#x3D;30;</span><br><span class="line">   private float float_num &#x3D; 45.3f;</span><br><span class="line">   private double double_num &#x3D;39.8;</span><br><span class="line">   private byte byte_num &#x3D;121;</span><br><span class="line">   private long long_num &#x3D; 2323L;</span><br><span class="line">   private long long_delay_num ;</span><br><span class="line">   private boolean boolean_flage &#x3D; true;</span><br><span class="line"></span><br><span class="line">   public void init()&#123;</span><br><span class="line">     this.long_delay_num &#x3D; 5555L;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>上面代码测试结果：</p>
<ul>
<li>final类型的8种基本类型的值会进入常量池。</li>
<li>非final类型的8种基本类型的值double、float、long的值会进入常量池，包括long_delay_num的值。</li>
</ul>
<p><strong>String类型</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">*   StringTest.java代码：</span><br><span class="line"></span><br><span class="line">    public class StringTest&#123;</span><br><span class="line">    </span><br><span class="line">          private String str1 &#x3D; &quot;zl&quot;+&quot;cook&quot;;</span><br><span class="line">          private String str2 &#x3D; str1+&quot;hello&quot;;</span><br><span class="line">          private String str3 &#x3D; new String(&quot;zlcook here?&quot;);</span><br><span class="line">          private String str4 &#x3D; &quot;everybody &quot;+ new String(&quot;here?&quot;);</span><br><span class="line">    </span><br><span class="line">          private final String fin1 &#x3D; &quot;boy&quot;;</span><br><span class="line">          private final String fin2 &#x3D; fin1+ &quot;is boy&quot;;</span><br><span class="line">          private final String fin3 &#x3D; str1+ &quot;is boy&quot;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>StringTest.class的常量池种包含内容：</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/3458176-adab40db73749fe0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/709/format/webp" alt="常量池中包含的字符串类型字面量"></p>
<p>所有测试数据github： <a href="https://link.jianshu.com?t=https://github.com/zlcook/JVM/tree/master/constant" target="_blank" rel="noopener">测试数据</a></p>
<h1 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h1><ul>
<li>这一节主要讲了Class文件魔数、版本号和常量池，比较详细介绍了常量池包含的内容以及用到的14种常量项结构。记住本节讲的常量池是class文件中的常量池，要记住还有运行时常量池，每个class文件中的常量池内容在类加载侯会进入方法区的运行时常量池中存放。当然运行时常量池的内容不仅包含这些还包含运行期加入的常量，常见的就是String类的intern()方法。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://reoger.tk/2018/10/13/system/%E4%BF%AE%E6%94%B9ubuntu%E4%B8%8B%E7%9A%84dns/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="reoger">
      <meta itemprop="description" content="reoger">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="reoger的记录">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/10/13/system/%E4%BF%AE%E6%94%B9ubuntu%E4%B8%8B%E7%9A%84dns/" class="post-title-link" itemprop="url">修改ubuntu下的dns</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-10-13 19:08:55" itemprop="dateCreated datePublished" datetime="2018-10-13T19:08:55+08:00">2018-10-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-07-18 14:41:56" itemprop="dateModified" datetime="2020-07-18T14:41:56+08:00">2020-07-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/system/" itemprop="url" rel="index"><span itemprop="name">system</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="修改ubuntu下的dns"><a href="#修改ubuntu下的dns" class="headerlink" title="修改ubuntu下的dns"></a>修改ubuntu下的dns</h1><p>适用环境：oracle vm 虚拟机下的ununtu-14.04.5版本。</p>
<h2 id="验证有效的方法：https-blog-csdn-net-u014453443-article-details-80878061"><a href="#验证有效的方法：https-blog-csdn-net-u014453443-article-details-80878061" class="headerlink" title="验证有效的方法：https://blog.csdn.net/u014453443/article/details/80878061"></a>验证有效的方法：<a href="https://blog.csdn.net/u014453443/article/details/80878061" target="_blank" rel="noopener">https://blog.csdn.net/u014453443/article/details/80878061</a></h2><p>基本步骤：</p>
<ol>
<li><p>查看当前dns配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat &#x2F;etc&#x2F;resolv.conf</span><br></pre></td></tr></table></figure></li>
<li><p>添加dns配置,在interfaces文件下添加需要的dns配置，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vi &#x2F;etc&#x2F;network&#x2F;interfaces</span><br></pre></td></tr></table></figure>
<p>参考的dns配置地址：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dns-nameservers 8.8.8.8 </span><br><span class="line">dns-nameservers 8.8.4.4</span><br></pre></td></tr></table></figure>
<p>参考配置如下：<br><img src="https://upload-images.jianshu.io/upload_images/2178834-3b11eca15608f683.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
</li>
<li><p>重启，后验证dns</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat &#x2F;etc&#x2F;resolv.conf</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p><img src="https://upload-images.jianshu.io/upload_images/2178834-41be0ea18ebb5d5d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>dns修改成功！ </p>
<h2 id="可能有效的方法-https-blog-csdn-net-qq-27818541-article-details-75730125"><a href="#可能有效的方法-https-blog-csdn-net-qq-27818541-article-details-75730125" class="headerlink" title="可能有效的方法 https://blog.csdn.net/qq_27818541/article/details/75730125"></a>可能有效的方法 <a href="https://blog.csdn.net/qq_27818541/article/details/75730125" target="_blank" rel="noopener">https://blog.csdn.net/qq_27818541/article/details/75730125</a></h2><h2 id="验证无效，但是其他版本可能有效的方法-https-blog-csdn-net-zd147896325-article-details-81078414"><a href="#验证无效，但是其他版本可能有效的方法-https-blog-csdn-net-zd147896325-article-details-81078414" class="headerlink" title="验证无效，但是其他版本可能有效的方法 https://blog.csdn.net/zd147896325/article/details/81078414"></a>验证无效，但是其他版本可能有效的方法 <a href="https://blog.csdn.net/zd147896325/article/details/81078414" target="_blank" rel="noopener">https://blog.csdn.net/zd147896325/article/details/81078414</a></h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://reoger.tk/2018/08/31/algorithm/Android%20%E6%8F%92%E4%BB%B6%E5%8C%96%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90%E2%80%94%E2%80%94%E6%8F%92%E4%BB%B6%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="reoger">
      <meta itemprop="description" content="reoger">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="reoger的记录">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/08/31/algorithm/Android%20%E6%8F%92%E4%BB%B6%E5%8C%96%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90%E2%80%94%E2%80%94%E6%8F%92%E4%BB%B6%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/" class="post-title-link" itemprop="url">Android 插件化原理解析——插件加载机制</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-08-31 11:13:55" itemprop="dateCreated datePublished" datetime="2018-08-31T11:13:55+08:00">2018-08-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-12 22:54:20" itemprop="dateModified" datetime="2020-04-12T22:54:20+08:00">2020-04-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%BD%AC%E8%BD%BD/" itemprop="url" rel="index"><span itemprop="name">转载</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Android-插件化原理解析——插件加载机制"><a href="#Android-插件化原理解析——插件加载机制" class="headerlink" title="Android 插件化原理解析——插件加载机制"></a>Android 插件化原理解析——插件加载机制</h1><p>本文转载自<a href="http://weishu.me/2016/04/05/understand-plugin-framework-classloader/" target="_blank" rel="noopener">http://weishu.me/2016/04/05/understand-plugin-framework-classloader/</a>。</p>
<p>上文 <a href="http://weishu.me/2016/03/21/understand-plugin-framework-activity-management/" target="_blank" rel="noopener">Activity生命周期管理</a> 中我们地完成了『启动没有在AndroidManifest.xml中显式声明的Activity』的任务；通过Hook <code>AMS</code>和拦截ActivityThread中<code>H</code>类对于组件调度我们成功地绕过了AndroidMAnifest.xml的限制。</p>
<p>但是我们启动的『没有在AndroidManifet.xml中显式声明』的Activity和宿主程序存在于同一个Apk中；通常情况下，插件均以独立的文件存在甚至通过网络获取，这时候插件中的Activity能否成功启动呢？</p>
<p>要启动Activity组件肯定先要创建对应的Activity类的对象，从上文 <a href="http://weishu.me/2016/03/21/understand-plugin-framework-activity-management/" target="_blank" rel="noopener">Activity生命周期管理</a> 知道，创建Activity类对象的过程如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">java.lang.ClassLoader cl &#x3D; r.packageInfo.getClassLoader();  </span><br><span class="line">activity &#x3D; mInstrumentation.newActivity(  </span><br><span class="line"> cl, component.getClassName(), r.intent);  </span><br><span class="line">StrictMode.incrementExpectedActivityCount(activity.getClass());  </span><br><span class="line">r.intent.setExtrasClassLoader(cl);</span><br></pre></td></tr></table></figure>
<p>也就是说，系统通过<code>ClassLoader</code>加载了需要的Activity类并通过反射调用构造函数创建出了Activity对象。如果Activity组件存在于独立于宿主程序的文件之中，系统的ClassLoader怎么知道去哪里加载呢？因此，如果不做额外的处理，插件中的Activity对象甚至都没有办法创建出来，谈何启动？</p>
<p>因此，要使存在于独立文件或者网络中的插件被成功启动，首先就需要解决这个<strong>插件类加载</strong>的问题。<br>下文将围绕此问题展开，完成『启动没有在AndroidManifest.xml中显示声明，并且存在于外部插件中的Activity』的任务。</p>
<p>阅读本文之前，可以先clone一份 <a href="https://github.com/tiann/understand-plugin-framework" target="_blank" rel="noopener">understand-plugin-framework</a>，参考此项目的<code>classloader-hook</code> 模块。另外，插件框架原理解析系列文章见<a href="http://weishu.me/2016/01/28/understand-plugin-framework-overview/" target="_blank" rel="noopener">索引</a>。</p>
<h2 id="ClassLoader机制"><a href="#ClassLoader机制" class="headerlink" title="ClassLoader机制"></a>ClassLoader机制</h2><p>或许有的童鞋还不太了解Java的ClassLoader机制，我这里简要介绍一下。</p>
<blockquote>
<p>Java虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校检、转换解析和初始化的，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。<br>与那些在编译时进行链连接工作的语言不同，在Java语言里面，类型的加载、连接和初始化都是在程序运行期间完成的，这种策略虽然会令类加载时稍微增加一些性能开销，但是会为Java应用程序提供高度的灵活性，Java里天生可以同代拓展的语言特性就是依赖运行期动态加载和动态链接这个特点实现的。例如，如果编写一个面相接口的应用程序，可以等到运行时在制定实际的实现类；用户可以通过Java与定义的和自定义的类加载器，让一个本地的应用程序可以在运行时从网络或其他地方加载一个二进制流作为代码的一部分，这种组装应用程序的方式目前已经广泛应用于Java程序之中。从最基础的Applet，JSP到复杂的OSGi技术，都使用了Java语言运行期类加载的特性。</p>
</blockquote>
<p>Java的类加载是一个相对复杂的过程；它包括加载、验证、准备、解析和初始化五个阶段；对于开发者来说，可控性最强的是<strong>加载阶段</strong>；加载阶段主要完成三件事：</p>
<ol>
<li>根据一个类的全限定名来获取定义此类的二进制字节流</li>
<li>将这个字节流所代表的静态存储结构转化为JVM方法区中的运行时数据结构</li>
<li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。</li>
</ol>
<p>『通过一个类的全限定名获取描述此类的二进制字节流』这个过程被抽象出来，就是Java的类加载器模块，也即JDK中ClassLoader API。</p>
<p>Android Framework提供了DexClassLoader这个类，简化了『通过一个类的全限定名获取描述次类的二进制字节流』这个过程；我们只需要告诉DexClassLoader一个dex文件或者apk文件的路径就能完成类的加载。因此本文的内容用一句话就可以概括：</p>
<p><strong>将插件的dex或者apk文件告诉『合适的』DexClassLoader，借助它完成插件类的加载</strong></p>
<p>关于CLassLoader机制更多的内容，请参阅『深入理解Java虚拟机』这本书。</p>
<h2 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h2><p>Android系统使用了ClassLoader机制来进行Activity等组件的加载；apk被安装之后，APK文件的代码以及资源会被系统存放在固定的目录（比如/data/app/package_name/base-1.apk )系统在进行类加载的时候，会自动去这一个或者几个特定的路径来寻找这个类；但是系统并不知道存在于插件中的Activity组件的信息(插件可以是任意位置，甚至是网络，系统无法提前预知)，因此正常情况下系统无法加载我们插件中的类；因此也没有办法创建Activity的对象，更不用谈启动组件了。</p>
<p>解决这个问题有两个思路，要么全盘接管这个类加载的过程；要么告知系统我们使用的插件存在于哪里，让系统帮忙加载；这两种方式或多或少都需要<strong>干预</strong>这个类加载的过程。老规矩，知己知彼，百战不殆。我们首先分析一下，系统是如果完成这个类加载过程的。</p>
<p>我们再次搬出Activity的创建过程的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">java.lang.ClassLoader cl &#x3D; r.packageInfo.getClassLoader();  </span><br><span class="line">activity &#x3D; mInstrumentation.newActivity(cl, component.getClassName(), r.intent);  </span><br><span class="line">StrictMode.incrementExpectedActivityCount(activity.getClass());  </span><br><span class="line">r.intent.setExtrasClassLoader(cl);</span><br></pre></td></tr></table></figure>
<p>这里可以很明显地看到，系统通过待启动的Activity的类名<code>className</code>，然后使用ClassLoader对象<code>cl</code>把这个类加载进虚拟机，最后使用反射创建了这个Activity类的实例对象。要想干预这个ClassLoader（告知它我们的路径或者替换他），我们首先得看看这玩意到底是个什么来头。（从哪里创建的）</p>
<p><code>cl</code>这个ClasssLoader对象通过<code>r.packageInfo</code>对象的getClassLoader()方法得到，r.packageInfo是一个LoadedApk类的对象；那么，LoadedApk到底是个什么东西？？</p>
<p>我们查阅LoadedApk类的文档，只有一句话，不过说的很明白：</p>
<blockquote>
<p>Local state maintained about a currently loaded .apk.</p>
</blockquote>
<p><strong>LoadedApk对象是APK文件在内存中的表示。</strong> Apk文件的相关信息，诸如Apk文件的代码和资源，甚至代码里面的Activity，Service等组件的信息我们都可以通过此对象获取。</p>
<p>OK, 我们知道这个LoadedApk是何方神圣了；接下来我们要搞清楚的是：这个 <code>r.packageInfo</code> 到底是从哪里获取的？</p>
<p>我们顺着 performLaunchActivity上溯，辗转handleLaunchActivity回到了 <code>H</code> 类的LAUNCH_ACTIVITY消息，找到了<code>r.packageInfo</code>的来源：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">final ActivityClientRecord r &#x3D; (ActivityClientRecord) msg.obj;  </span><br><span class="line">r.packageInfo &#x3D; getPackageInfoNoCheck(  </span><br><span class="line"> r.activityInfo.applicationInfo, r.compatInfo);  </span><br><span class="line">handleLaunchActivity(r, null);</span><br></pre></td></tr></table></figure>
<p>getPackageInfoNoCheck方法很简单，直接调用了getPackageInfo方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public final LoadedApk getPackageInfoNoCheck(ApplicationInfo ai,  </span><br><span class="line"> CompatibilityInfo compatInfo) &#123;  </span><br><span class="line"> return getPackageInfo(ai, compatInfo, null, false, true, false);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个getPackageInfo方法里面我们发现了端倪：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">private LoadedApk getPackageInfo(ApplicationInfo aInfo, CompatibilityInfo compatInfo,  </span><br><span class="line"> ClassLoader baseLoader, boolean securityViolation, boolean includeCode,  </span><br><span class="line"> boolean registerPackage) &#123;  </span><br><span class="line"> &#x2F;&#x2F; 获取userid信息  </span><br><span class="line"> final boolean differentUser &#x3D; (UserHandle.myUserId() !&#x3D; UserHandle.getUserId(aInfo.uid));  </span><br><span class="line"> synchronized (mResourcesManager) &#123;  </span><br><span class="line"> &#x2F;&#x2F; 尝试获取缓存信息  </span><br><span class="line"> WeakReference&lt;LoadedApk&gt; ref;  </span><br><span class="line"> if (differentUser) &#123;  </span><br><span class="line"> &#x2F;&#x2F; Caching not supported across users  </span><br><span class="line"> ref &#x3D; null;  </span><br><span class="line"> &#125; else if (includeCode) &#123;  </span><br><span class="line"> ref &#x3D; mPackages.get(aInfo.packageName);  </span><br><span class="line"> &#125; else &#123;  </span><br><span class="line"> ref &#x3D; mResourcePackages.get(aInfo.packageName);  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line"> LoadedApk packageInfo &#x3D; ref !&#x3D; null ? ref.get() : null;  </span><br><span class="line"> if (packageInfo &#x3D;&#x3D; null || (packageInfo.mResources !&#x3D; null  </span><br><span class="line"> &amp;&amp; !packageInfo.mResources.getAssets().isUpToDate())) &#123;  </span><br><span class="line"> &#x2F;&#x2F; 缓存没有命中，直接new  </span><br><span class="line"> packageInfo &#x3D;  </span><br><span class="line"> new LoadedApk(this, aInfo, compatInfo, baseLoader,  </span><br><span class="line"> securityViolation, includeCode &amp;&amp;  </span><br><span class="line"> (aInfo.flags&amp;ApplicationInfo.FLAG\_HAS\_CODE) !&#x3D; 0, registerPackage);  </span><br><span class="line">  </span><br><span class="line"> &#x2F;&#x2F; 省略。。更新缓存  </span><br><span class="line"> return packageInfo;  </span><br><span class="line"> &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法很重要，我们必须弄清楚每一步；</p>
<p>首先，它判断了调用方和或许App信息的一方是不是同一个userId；如果是同一个user，那么可以共享缓存数据（要么缓存的代码数据，要么缓存的资源数据）</p>
<p>接下来尝试获取缓存数据；如果没有命中缓存数据，才通过LoadedApk的构造函数创建了LoadedApk对象；创建成功之后，如果是同一个uid还放入了缓存。</p>
<p>提到缓存数据，看过<a href="http://weishu.me/2016/02/16/understand-plugin-framework-binder-hook/" target="_blank" rel="noopener">Hook机制之Binder Hook</a>的童鞋可能就知道了，我们之前成功借助ServiceManager的本地代理使用缓存的机制Hook了各种Binder；因此这里完全可以如法炮制——我们拿到这一份缓存数据，修改里面的ClassLoader；自己控制类加载的过程，这样加载插件中的Activity类的问题就解决了。这就引出了我们加载插件类的第一种方案：</p>
<h2 id="激进方案：Hook掉ClassLoader，自己操刀"><a href="#激进方案：Hook掉ClassLoader，自己操刀" class="headerlink" title="激进方案：Hook掉ClassLoader，自己操刀"></a>激进方案：Hook掉ClassLoader，自己操刀</h2><p>从上述分析中我们得知，在获取LoadedApk的过程中使用了一份缓存数据；这个缓存数据是一个<code>Map</code>，从包名到LoadedApk的一个映射。正常情况下，我们的插件肯定不会存在于这个对象里面；但是<strong>如果我们手动把我们插件的信息添加到里面呢？</strong>系统在查找缓存的过程中，会直接命中缓存！进而使用我们添加进去的LoadedApk的ClassLoader来加载这个特定的Activity类！这样我们就能接管我们自己插件类的加载过程了！</p>
<p>这个缓存对象<code>mPackages</code>存在于ActivityThread类中；老方法，我们首先获取这个对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 先获取到当前的ActivityThread对象  </span><br><span class="line">Class&lt;?&gt; activityThreadClass &#x3D; Class.forName(&quot;android.app.ActivityThread&quot;);  </span><br><span class="line">Method currentActivityThreadMethod &#x3D; activityThreadClass.getDeclaredMethod(&quot;currentActivityThread&quot;);  </span><br><span class="line">currentActivityThreadMethod.setAccessible(true);  </span><br><span class="line">Object currentActivityThread &#x3D; currentActivityThreadMethod.invoke(null);  </span><br><span class="line">  </span><br><span class="line">&#x2F;&#x2F; 获取到 mPackages 这个静态成员变量, 这里缓存了dex包的信息  </span><br><span class="line">Field mPackagesField &#x3D; activityThreadClass.getDeclaredField(&quot;mPackages&quot;);  </span><br><span class="line">mPackagesField.setAccessible(true);  </span><br><span class="line">Map mPackages &#x3D; (Map) mPackagesField.get(currentActivityThread);</span><br></pre></td></tr></table></figure>
<p>拿到这个Map之后接下来怎么办呢？<strong>我们需要填充这个map，把插件的信息塞进这个map里面</strong>，以便系统在查找的时候能命中缓存。但是这个填充这个Map我们出了需要包名之外，还需要一个LoadedApk对象；如何创建一个LoadedApk对象呢？</p>
<p>我们当然可以直接反射调用它的构造函数直接创建出需要的对象，但是万一哪里有疏漏，构造参数填错了怎么办？又或者Android的不同版本使用了不同的参数，导致我们创建出来的对象与系统创建出的对象不一致，无法work怎么办？</p>
<p>因此我们需要使用与系统完全相同的方式创建LoadedApk对象；从上文分析得知，系统创建LoadedApk对象是通过<code>getPackageInfo</code>来完成的，因此我们可以调用这个函数来创建LoadedApk对象；但是这个函数是<code>private</code>的，我们无法使用。</p>
<p>有的童鞋可能会有疑问了，<code>private</code>不是也能反射到吗？我们确实能够调用这个函数，但是<code>private</code>表明这个函数是内部实现，或许那一天Google高兴，把这个函数改个名字我们就直接GG了；但是public函数不同，public被导出的函数你无法保证是否有别人调用它，因此大部分情况下不会修改；我们最好调用public函数来保证尽可能少的遇到兼容性问题。（当然，如果实在木有路可以考虑调用私有方法，自己处理兼容性问题，这个我们以后也会遇到）</p>
<p>间接调用<code>getPackageInfo</code>这个私有函数的public函数有同名的getPackageInfo系列和getPackageInfoNoCheck；简单查看源代码发现，getPackageInfo除了获取包的信息，还检查了包的一些组件；为了绕过这些验证，我们选择使用<code>getPackageInfoNoCheck</code>获取LoadedApk信息。</p>
<h3 id="构建插件LoadedApk对象"><a href="#构建插件LoadedApk对象" class="headerlink" title="构建插件LoadedApk对象"></a>构建插件LoadedApk对象</h3><p>我们这一步的目的很明确，通过getPackageInfoNoCheck函数创建出我们需要的LoadedApk对象，以供接下来使用。</p>
<p>这个函数的签名如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public final LoadedApk getPackageInfoNoCheck(ApplicationInfo ai,  </span><br><span class="line"> CompatibilityInfo compatInfo) &#123;</span><br></pre></td></tr></table></figure>
<p>因此，为了调用这个函数，我们需要构造两个参数。其一是ApplicationInfo，其二是CompatibilityInfo；第二个参数顾名思义，代表这个App的兼容性信息，比如targetSDK版本等等，这里我们只需要提取出app的信息，因此直接使用默认的兼容性即可；在CompatibilityInfo类里面有一个公有字段DEFAULT_COMPATIBILITY_INFO代表默认兼容性信息；因此，我们的首要目标是获取这个ApplicationInfo信息。</p>
<h3 id="构建插件ApplicationInfo信息"><a href="#构建插件ApplicationInfo信息" class="headerlink" title="构建插件ApplicationInfo信息"></a>构建插件ApplicationInfo信息</h3><p>我们首先看看ApplicationInfo代表什么，这个类的文档说的很清楚：</p>
<blockquote>
<p>Information you can retrieve about a particular application. This corresponds to information collected from the AndroidManifest.xml’s <application> tag.</p>
</blockquote>
<p>也就是说，这个类就是AndroidManifest.xml里面的 这个标签下面的信息；这个AndroidManifest.xml无疑是一个标准的xml文件，因此我们完全可以自己使用parse来解析这个信息。</p>
<p>那么，系统是如何获取这个信息的呢？其实Framework就有一个这样的parser，也即PackageParser；理论上，我们也可以借用系统的parser来解析AndroidMAnifest.xml从而得到ApplicationInfo的信息。但遗憾的是，<strong>这个类的兼容性很差</strong>；Google几乎在每一个Android版本都对这个类动刀子，如果坚持使用系统的解析方式，必须写一系列兼容行代码！！DroidPlugin就选择了这种方式，相关类如下：</p>
<p><a href="http://7xp3xc.com1.z0.glb.clouddn.com/201601/1459829051777.png" target="_blank" rel="noopener" title="DroidPlugin的PackageParser"><img src="http://7xp3xc.com1.z0.glb.clouddn.com/201601/1459829051777.png" alt="DroidPlugin的PackageParser"></a></p>
<p><a href="http://7xp3xc.com1.z0.glb.clouddn.com/201601/1459829051777.png" target="_blank" rel="noopener" title="DroidPlugin的PackageParser">DroidPlugin的PackageParser</a></p>
<p>看到这里我就问你怕不怕！！！这也是我们之前提到的<strong>私有或者隐藏的API可以使用，但必须处理好兼容性问题</strong>；如果Android 7.0发布，这里估计得添加一个新的类PackageParseApi24。</p>
<p>我这里使用API 23作为演示，<strong>版本不同的可能无法运行</strong>请自行查阅 DroidPlugin 不同版本如何处理。</p>
<p>OK回到正题，我们决定使用PackageParser类来提取ApplicationInfo信息。下图是API 23上，PackageParser的部分类结构图：</p>
<p><a href="http://7xp3xc.com1.z0.glb.clouddn.com/201601/1459829674687.png" target="_blank" rel="noopener"><img src="http://7xp3xc.com1.z0.glb.clouddn.com/201601/1459829674687.png" alt=""></a></p>
<p>看起来有我们需要的方法 generateApplication；确实如此，依靠这个方法我们可以成功地拿到ApplicationInfo。<br>由于PackageParser是@hide的，因此我们需要通过反射进行调用。我们根据这个generateApplicationInfo方法的签名：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public static ApplicationInfo generateApplicationInfo(Package p, int flags,  </span><br><span class="line"> PackageUserState state)</span><br></pre></td></tr></table></figure>
<p>可以写出调用generateApplicationInfo的反射代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; packageParserClass &#x3D; Class.forName(&quot;android.content.pm.PackageParser&quot;);  </span><br><span class="line">&#x2F;&#x2F; 首先拿到我们得终极目标: generateApplicationInfo方法  </span><br><span class="line">&#x2F;&#x2F; API 23 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  </span><br><span class="line">&#x2F;&#x2F; public static ApplicationInfo generateApplicationInfo(Package p, int flags,  </span><br><span class="line">&#x2F;&#x2F;    PackageUserState state) &#123;  </span><br><span class="line">&#x2F;&#x2F; 其他Android版本不保证也是如此.  </span><br><span class="line">Class&lt;?&gt; packageParser$PackageClass &#x3D; Class.forName(&quot;android.content.pm.PackageParser$Package&quot;);  </span><br><span class="line">Class&lt;?&gt; packageUserStateClass &#x3D; Class.forName(&quot;android.content.pm.PackageUserState&quot;);  </span><br><span class="line">Method generateApplicationInfoMethod &#x3D; packageParserClass.getDeclaredMethod(&quot;generateApplicationInfo&quot;,  </span><br><span class="line"> packageParser$PackageClass,  </span><br><span class="line"> int.class,  </span><br><span class="line"> packageUserStateClass);</span><br></pre></td></tr></table></figure>
<p>要成功调用这个方法，还需要三个参数；因此接下来我们需要一步一步构建调用此函数的参数信息。</p>
<h4 id="构建PackageParser-Package"><a href="#构建PackageParser-Package" class="headerlink" title="构建PackageParser.Package"></a>构建PackageParser.Package</h4><p>generateApplicationInfo方法需要的第一个参数是PackageParser.Package；从名字上看这个类代表某个apk包的信息，我们看看文档怎么解释：</p>
<blockquote>
<p>Representation of a full package parsed from APK files on disk. A package consists of a single base APK, and zero or more split APKs.</p>
</blockquote>
<p>果然，这个类代表从PackageParser中解析得到的某个apk包的信息，是磁盘上apk文件在内存中的数据结构表示；因此，要获取这个类，肯定需要解析整个apk文件。PackageParser中解析apk的核心方法是parsePackage，这个方法返回的就是一个Package类型的实例，因此我们调用这个方法即可；使用反射代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 首先, 我们得创建出一个Package对象出来供这个方法调用  </span><br><span class="line">&#x2F;&#x2F; 而这个需要得对象可以通过 android.content.pm.PackageParser#parsePackage 这个方法返回得 Package对象得字段获取得到  </span><br><span class="line">&#x2F;&#x2F; 创建出一个PackageParser对象供使用  </span><br><span class="line">Object packageParser &#x3D; packageParserClass.newInstance();  </span><br><span class="line">&#x2F;&#x2F; 调用 PackageParser.parsePackage 解析apk的信息  </span><br><span class="line">Method parsePackageMethod &#x3D; packageParserClass.getDeclaredMethod(&quot;parsePackage&quot;, File.class, int.class);  </span><br><span class="line">  </span><br><span class="line">&#x2F;&#x2F; 实际上是一个 android.content.pm.PackageParser.Package 对象  </span><br><span class="line">Object packageObj &#x3D; parsePackageMethod.invoke(packageParser, apkFile, 0);</span><br></pre></td></tr></table></figure>
<p>这样，我们就得到了generateApplicationInfo的第一个参数；第二个参数是解析包使用的flag，我们直接选择解析全部信息，也就是0；</p>
<h4 id="构建PackageUserState"><a href="#构建PackageUserState" class="headerlink" title="构建PackageUserState"></a>构建PackageUserState</h4><p>第三个参数是PackageUserState，代表不同用户中包的信息。由于Android是一个多任务多用户系统，因此不同的用户同一个包可能有不同的状态；这里我们只需要获取包的信息，因此直接使用默认的即可；</p>
<p>至此，generateApplicaionInfo的参数我们已经全部构造完成，直接调用此方法即可得到我们需要的applicationInfo对象；在返回之前我们需要做一点小小的修改：使用系统系统的这个方法解析得到的ApplicationInfo对象中并没有apk文件本身的信息，所以我们把解析的apk文件的路径设置一下（ClassLoader依赖dex文件以及apk的路径）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 第三个参数 mDefaultPackageUserState 我们直接使用默认构造函数构造一个出来即可  </span><br><span class="line">Object defaultPackageUserState &#x3D; packageUserStateClass.newInstance();  </span><br><span class="line">  </span><br><span class="line">&#x2F;&#x2F; 万事具备!!!!!!!!!!!!!!  </span><br><span class="line">ApplicationInfo applicationInfo &#x3D; (ApplicationInfo) generateApplicationInfoMethod.invoke(packageParser,  </span><br><span class="line"> packageObj, 0, defaultPackageUserState);  </span><br><span class="line">String apkPath &#x3D; apkFile.getPath();  </span><br><span class="line">applicationInfo.sourceDir &#x3D; apkPath;  </span><br><span class="line">applicationInfo.publicSourceDir &#x3D; apkPath;</span><br></pre></td></tr></table></figure>

<h3 id="替换ClassLoader"><a href="#替换ClassLoader" class="headerlink" title="替换ClassLoader"></a>替换ClassLoader</h3><h4 id="获取LoadedApk信息"><a href="#获取LoadedApk信息" class="headerlink" title="获取LoadedApk信息"></a>获取LoadedApk信息</h4><p>方才为了获取ApplicationInfo我们费了好大一番精力；回顾一下我们的初衷：</p>
<p>我们最终的目的是调用getPackageInfoNoCheck得到LoadedApk的信息，并替换其中的mClassLoader然后把把添加到ActivityThread的mPackages缓存中；从而达到我们使用自己的ClassLoader加载插件中的类的目的。</p>
<p>现在我们已经拿到了getPackageInfoNoCheck这个方法中至关重要的第一个参数applicationInfo；上文提到第二个参数CompatibilityInfo代表设备兼容性信息，直接使用默认的值即可；因此，两个参数都已经构造出来，我们可以调用getPackageInfoNoCheck获取LoadedApk：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; android.content.res.CompatibilityInfo  </span><br><span class="line">Class&lt;?&gt; compatibilityInfoClass &#x3D; Class.forName(&quot;android.content.res.CompatibilityInfo&quot;);  </span><br><span class="line">Method getPackageInfoNoCheckMethod &#x3D; activityThreadClass.getDeclaredMethod(&quot;getPackageInfoNoCheck&quot;, ApplicationInfo.class, compatibilityInfoClass);  </span><br><span class="line">  </span><br><span class="line">Field defaultCompatibilityInfoField &#x3D; compatibilityInfoClass.getDeclaredField(&quot;DEFAULT\_COMPATIBILITY\_INFO&quot;);  </span><br><span class="line">defaultCompatibilityInfoField.setAccessible(true);  </span><br><span class="line">  </span><br><span class="line">Object defaultCompatibilityInfo &#x3D; defaultCompatibilityInfoField.get(null);  </span><br><span class="line">ApplicationInfo applicationInfo &#x3D; generateApplicationInfo(apkFile);  </span><br><span class="line">  </span><br><span class="line">Object loadedApk &#x3D; getPackageInfoNoCheckMethod.invoke(currentActivityThread, applicationInfo, defaultCompatibilityInfo);</span><br></pre></td></tr></table></figure>
<p>我们成功地构造出了LoadedAPK, 接下来我们需要替换其中的ClassLoader，然后把它添加进ActivityThread的mPackages中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String odexPath &#x3D; Utils.getPluginOptDexDir(applicationInfo.packageName).getPath();  </span><br><span class="line">String libDir &#x3D; Utils.getPluginLibDir(applicationInfo.packageName).getPath();  </span><br><span class="line">ClassLoader classLoader &#x3D; new CustomClassLoader(apkFile.getPath(), odexPath, libDir, ClassLoader.getSystemClassLoader());  </span><br><span class="line">Field mClassLoaderField &#x3D; loadedApk.getClass().getDeclaredField(&quot;mClassLoader&quot;);  </span><br><span class="line">mClassLoaderField.setAccessible(true);  </span><br><span class="line">mClassLoaderField.set(loadedApk, classLoader);  </span><br><span class="line">&#x2F;&#x2F; 由于是弱引用, 因此我们必须在某个地方存一份, 不然容易被GC; 那么就前功尽弃了.  </span><br><span class="line">sLoadedApk.put(applicationInfo.packageName, loadedApk);  </span><br><span class="line">  </span><br><span class="line">WeakReference weakReference &#x3D; new WeakReference(loadedApk);  </span><br><span class="line">mPackages.put(applicationInfo.packageName, weakReference);</span><br></pre></td></tr></table></figure>
<p>我们的这个CustomClassLoader非常简单，直接继承了DexClassLoader，什么都没有做；当然这里可以直接使用DexClassLoader，这里重新创建一个类是为了更有区分度；以后也可以通过修改这个类实现对于类加载的控制：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class CustomClassLoader extends DexClassLoader &#123;  </span><br><span class="line">  </span><br><span class="line"> public CustomClassLoader(String dexPath, String optimizedDirectory, String libraryPath, ClassLoader parent) &#123;  </span><br><span class="line"> super(dexPath, optimizedDirectory, libraryPath, parent);  </span><br><span class="line"> &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到这里，我们已经成功地把把插件的信息放入ActivityThread中，这样我们插件中的类能够成功地被加载；因此插件中的Activity实例能被成功第创建；由于整个流程较为复杂，我们简单梳理一下：</p>
<ol>
<li>在ActivityThread接收到IApplication的 scheduleLaunchActivity远程调用之后，将消息转发给<code>H</code></li>
<li><code>H</code>类在handleMessage的时候，调用了getPackageInfoNoCheck方法来获取待启动的组件信息。在这个方法中会优先查找<code>mPackages</code>中的缓存信息，而我们已经手动把插件信息添加进去；因此能够成功命中缓存，获取到独立存在的插件信息。</li>
<li><code>H</code>类然后调用handleLaunchActivity最终转发到performLaunchActivity方法；这个方法使用从getPackageInfoNoCheck中拿到LoadedApk中的mClassLoader来加载Activity类，进而使用反射创建Activity实例；接着创建Application，Context等完成Activity组件的启动。</li>
</ol>
<p>看起来好像已经天衣无缝万事大吉了；但是运行一下会出现一个异常，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">04-05 02:49:53.742  11759-11759&#x2F;com.weishu.upf.hook_classloader E&#x2F;AndroidRuntime﹕ FATAL EXCEPTION: main  </span><br><span class="line"> Process: com.weishu.upf.hook_classloader, PID: 11759  </span><br><span class="line"> java.lang.RuntimeException: Unable to start activity ComponentInfo&#123;com.weishu.upf.ams\_pms\_hook.app&#x2F;com.weishu.upf.ams\_pms\_hook.app.MainActivity&#125;: java.lang.RuntimeException: Unable to instantiate application android.app.Application: java.lang.IllegalStateException: Unable to get package info for com.weishu.upf.ams\_pms\_hook.app; is package not installed?</span><br></pre></td></tr></table></figure>

<p>错误提示说是无法实例化 <code>Application</code>，而Application的创建也是在performLaunchActivity中进行的，这里有些蹊跷，我们仔细查看一下。</p>
<h4 id="绕过系统检查"><a href="#绕过系统检查" class="headerlink" title="绕过系统检查"></a>绕过系统检查</h4><p>通过ActivityThread的performLaunchActivity方法可以得知，Application通过LoadedApk的makeApplication方法创建，我们查看这个方法，在源码中发现了上文异常抛出的位置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">try &#123;  </span><br><span class="line"> java.lang.ClassLoader cl &#x3D; getClassLoader();  </span><br><span class="line"> if (!mPackageName.equals(&quot;android&quot;)) &#123;  </span><br><span class="line"> initializeJavaContextClassLoader();  </span><br><span class="line"> &#125;  </span><br><span class="line"> ContextImpl appContext &#x3D; ContextImpl.createAppContext(mActivityThread, this);  </span><br><span class="line"> app &#x3D; mActivityThread.mInstrumentation.newApplication(  </span><br><span class="line"> cl, appClass, appContext);  </span><br><span class="line"> appContext.setOuterContext(app);  </span><br><span class="line">&#125; catch (Exception e) &#123;  </span><br><span class="line"> if (!mActivityThread.mInstrumentation.onException(app, e)) &#123;  </span><br><span class="line"> throw new RuntimeException(  </span><br><span class="line"> &quot;Unable to instantiate application &quot; \+ appClass  </span><br><span class="line"> \+ &quot;: &quot; \+ e.toString(), e);  </span><br><span class="line"> &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>木有办法，我们只有一行一行地查看到底是哪里抛出这个异常的了；所幸代码不多。（所以说，缩小异常范围是一件多么重要的事情！！！）</p>
<p>第一句 getClassLoader() 没什么可疑的，虽然方法很长，但是它木有抛出任何异常（当然，它调用的代码可能抛出异常，万一找不到只能进一步深搜了；所以我觉得这里应该使用受检异常）。</p>
<p>然后我们看第二句，如果包名不是<code>android</code>开头，那么调用了一个叫做initializeJavaContextClassLoader的方法；我们查阅这个方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">private void initializeJavaContextClassLoader() &#123;  </span><br><span class="line"> IPackageManager pm &#x3D; ActivityThread.getPackageManager();  </span><br><span class="line"> android.content.pm.PackageInfo pi;  </span><br><span class="line"> try &#123;  </span><br><span class="line"> pi &#x3D; pm.getPackageInfo(mPackageName, 0, UserHandle.myUserId());  </span><br><span class="line"> &#125; catch (RemoteException e) &#123;  </span><br><span class="line"> throw new IllegalStateException(&quot;Unable to get package info for &quot;  </span><br><span class="line"> \+ mPackageName + &quot;; is system dying?&quot;, e);  </span><br><span class="line"> &#125;  </span><br><span class="line"> if (pi &#x3D;&#x3D; null) &#123;  </span><br><span class="line"> throw new IllegalStateException(&quot;Unable to get package info for &quot;  </span><br><span class="line"> \+ mPackageName + &quot;; is package not installed?&quot;);  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line"> boolean sharedUserIdSet &#x3D; (pi.sharedUserId !&#x3D; null);  </span><br><span class="line"> boolean processNameNotDefault &#x3D;  </span><br><span class="line"> (pi.applicationInfo !&#x3D; null &amp;&amp;  </span><br><span class="line"> !mPackageName.equals(pi.applicationInfo.processName));  </span><br><span class="line"> boolean sharable &#x3D; (sharedUserIdSet || processNameNotDefault);  </span><br><span class="line"> ClassLoader contextClassLoader &#x3D;  </span><br><span class="line"> (sharable)  </span><br><span class="line"> ? new WarningContextClassLoader()  </span><br><span class="line"> : mClassLoader;  </span><br><span class="line"> Thread.currentThread().setContextClassLoader(contextClassLoader);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里，我们找出了这个异常的来源：原来这里调用了<code>getPackageInfo</code>方法获取包的信息；而我们的插件<strong>并没有安装在系统上</strong>，因此系统肯定认为插件没有安装，这个方法肯定返回null。所以，我们还要欺骗一下PMS，让系统觉得<strong>插件已经安装在系统上了</strong>；至于如何欺骗 PMS，<a href="http://weishu.me/2016/03/07/understand-plugin-framework-ams-pms-hook/" target="_blank" rel="noopener">Hook机制之AMS&amp;PMS</a> 有详细解释，这里直接给出代码，不赘述了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">private static void hookPackageManager() throws Exception &#123;  </span><br><span class="line">  </span><br><span class="line"> &#x2F;&#x2F; 这一步是因为 initializeJavaContextClassLoader 这个方法内部无意中检查了这个包是否在系统安装  </span><br><span class="line"> &#x2F;&#x2F; 如果没有安装, 直接抛出异常, 这里需要临时Hook掉 PMS, 绕过这个检查.  </span><br><span class="line">  </span><br><span class="line"> Class&lt;?&gt; activityThreadClass &#x3D; Class.forName(&quot;android.app.ActivityThread&quot;);  </span><br><span class="line"> Method currentActivityThreadMethod &#x3D; activityThreadClass.getDeclaredMethod(&quot;currentActivityThread&quot;);  </span><br><span class="line"> currentActivityThreadMethod.setAccessible(true);  </span><br><span class="line"> Object currentActivityThread &#x3D; currentActivityThreadMethod.invoke(null);  </span><br><span class="line">  </span><br><span class="line"> &#x2F;&#x2F; 获取ActivityThread里面原始的 sPackageManager  </span><br><span class="line"> Field sPackageManagerField &#x3D; activityThreadClass.getDeclaredField(&quot;sPackageManager&quot;);  </span><br><span class="line"> sPackageManagerField.setAccessible(true);  </span><br><span class="line"> Object sPackageManager &#x3D; sPackageManagerField.get(currentActivityThread);  </span><br><span class="line">  </span><br><span class="line"> &#x2F;&#x2F; 准备好代理对象, 用来替换原始的对象  </span><br><span class="line"> Class&lt;?&gt; iPackageManagerInterface &#x3D; Class.forName(&quot;android.content.pm.IPackageManager&quot;);  </span><br><span class="line"> Object proxy &#x3D; Proxy.newProxyInstance(iPackageManagerInterface.getClassLoader(),  </span><br><span class="line"> new Class&lt;?&gt;\[\] &#123; iPackageManagerInterface &#125;,  </span><br><span class="line"> new IPackageManagerHookHandler(sPackageManager));  </span><br><span class="line">  </span><br><span class="line"> &#x2F;&#x2F; 1\. 替换掉ActivityThread里面的 sPackageManager 字段  </span><br><span class="line"> sPackageManagerField.set(currentActivityThread, proxy);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>OK到这里，我们已经能够成功地加载<strong>简单的</strong>独立的存在于外部文件系统中的apk了。至此 关于 DroidPlugin 对于Activity生命周期的管理已经完全讲解完毕了；这是一种极其复杂的Activity管理方案，我们仅仅写一个用来理解的demo就Hook了相当多的东西，在Framework层来回牵扯；这其中的来龙去脉要完全把握清楚还请读者亲自翻阅源码。另外，我在此 对DroidPlugin 作者献上我的膝盖～这其中的玄妙让人叹为观止！</p>
<p>上文给出的方案中，我们全盘接管了插件中类的加载过程，这是一种相对暴力的解决方案；能不能更温柔一点呢？通俗来说，我们可以选择改革，而不是革命——告诉系统ClassLoader一些必要信息，让它帮忙完成插件类的加载。</p>
<h2 id="保守方案：委托系统，让系统帮忙加载"><a href="#保守方案：委托系统，让系统帮忙加载" class="headerlink" title="保守方案：委托系统，让系统帮忙加载"></a>保守方案：委托系统，让系统帮忙加载</h2><p>我们再次搬出ActivityThread中加载Activity类的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">java.lang.ClassLoader cl &#x3D; r.packageInfo.getClassLoader();  </span><br><span class="line">activity &#x3D; mInstrumentation.newActivity(  </span><br><span class="line"> cl, component.getClassName(), r.intent);  </span><br><span class="line">StrictMode.incrementExpectedActivityCount(activity.getClass());  </span><br><span class="line">r.intent.setExtrasClassLoader(cl);</span><br></pre></td></tr></table></figure>
<p>我们知道 这个r.packageInfo中的<code>r</code>是通过getPackageInfoNoCheck获取到的；在『激进方案』中我们把插件apk手动添加进缓存，采用自己加载办法解决；如果我们不干预这个过程，导致无法命中mPackages中的缓存，会发生什么？</p>
<p>查阅 getPackageInfo方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">private LoadedApk getPackageInfo(ApplicationInfo aInfo, CompatibilityInfo compatInfo,  </span><br><span class="line"> ClassLoader baseLoader, boolean securityViolation, boolean includeCode,  </span><br><span class="line"> boolean registerPackage) &#123;  </span><br><span class="line"> final boolean differentUser &#x3D; (UserHandle.myUserId() !&#x3D; UserHandle.getUserId(aInfo.uid));  </span><br><span class="line"> synchronized (mResourcesManager) &#123;  </span><br><span class="line"> WeakReference&lt;LoadedApk&gt; ref;  </span><br><span class="line"> if (differentUser) &#123;  </span><br><span class="line"> &#x2F;&#x2F; Caching not supported across users  </span><br><span class="line"> ref &#x3D; null;  </span><br><span class="line"> &#125; else if (includeCode) &#123;  </span><br><span class="line"> ref &#x3D; mPackages.get(aInfo.packageName);  </span><br><span class="line"> &#125; else &#123;  </span><br><span class="line"> ref &#x3D; mResourcePackages.get(aInfo.packageName);  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line"> LoadedApk packageInfo &#x3D; ref !&#x3D; null ? ref.get() : null;  </span><br><span class="line"> if (packageInfo &#x3D;&#x3D; null || (packageInfo.mResources !&#x3D; null  </span><br><span class="line"> &amp;&amp; !packageInfo.mResources.getAssets().isUpToDate())) &#123;  </span><br><span class="line"> packageInfo &#x3D;  </span><br><span class="line"> new LoadedApk(this, aInfo, compatInfo, baseLoader,  </span><br><span class="line"> securityViolation, includeCode &amp;&amp;  </span><br><span class="line"> (aInfo.flags&amp;ApplicationInfo.FLAG\_HAS\_CODE) !&#x3D; 0, registerPackage);  </span><br><span class="line">  </span><br><span class="line"> &#x2F;&#x2F; 略  </span><br><span class="line"> &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，没有命中缓存的情况下，系统直接new了一个LoadedApk；注意这个构造函数的第二个参数<code>aInfo</code>，这是一个ApplicationInfo类型的对象。在『激进方案』中我们为了获取独立插件的ApplicationInfo花了不少心思；那么如果不做任何处理这里传入的这个<code>aInfo</code>参数是什么？</p>
<p>追本溯源不难发现，这个aInfo是从我们的替身StubActivity中获取的！而StubActivity存在于宿主程序中，所以，这个<code>aInfo</code>对象代表的实际上就是宿主程序的Application信息！</p>
<p>我们知道，接下来会使用new出来的这个LoadedApk的getClassLoader()方法获取到ClassLoader来对插件的类进行加载；而获取到的这个ClassLoader是宿主程序使用的ClassLoader，因此现在还无法加载插件的类；那么，<strong>我们能不能让宿主的ClasLoader获得加载插件类的能力呢？</strong>；如果我们告诉宿主使用的ClassLoader插件使用的类在哪里，就能帮助他完成加载！</p>
<h3 id="宿主的ClassLoader在哪里，是唯一的吗？"><a href="#宿主的ClassLoader在哪里，是唯一的吗？" class="headerlink" title="宿主的ClassLoader在哪里，是唯一的吗？"></a>宿主的ClassLoader在哪里，是唯一的吗？</h3><p>上面说到，我们可以通过告诉宿主程序的ClassLoader插件使用的类，让宿主的ClasLoader完成对于插件类的加载；那么问题来了，我们如何获取到宿主的ClassLoader？宿主程序使用的ClasLoader默认情况下是全局唯一的吗？</p>
<p>答案是肯定的。</p>
<p>因为在FrameWork中宿主程序也是使用LoadedApk表示的，如同Activity启动是加载Activity类一样，宿主中的类也都是通过LoadedApk的getClassLoader()方法得到的ClassLoader加载的；由类加载机制的『双亲委派』特性，只要有一个应用程序类由某一个ClassLoader加载，那么它引用到的别的类除非父加载器能加载，否则都是由这同一个加载器加载的（不遵循双亲委派模型的除外）。</p>
<p>表示宿主的LoadedApk在Application类中有一个成员变量<code>mLoadedApk</code>，而这个变量是从ContextImpl中获取的；ContextImpl重写了getClassLoader方法，因此<strong>我们在Context环境中直接getClassLoader()获取到的就是宿主程序唯一的ClassLoader</strong>。</p>
<h3 id="LoadedApk的ClassLoader到底是什么？"><a href="#LoadedApk的ClassLoader到底是什么？" class="headerlink" title="LoadedApk的ClassLoader到底是什么？"></a>LoadedApk的ClassLoader到底是什么？</h3><p>现在我们确保了『使用宿主ClassLoader帮助加载插件类』可行性；那么我们应该如何完成这个过程呢？</p>
<p>知己知彼，百战不殆。</p>
<p>不论是宿主程序还是插件程序都是通过LoadedApk的getClassLoader()方法返回的ClassLoader进行类加载的，返回的这个ClassLoader到底是个什么东西？？这个方法源码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public ClassLoader getClassLoader() &#123;  </span><br><span class="line"> synchronized (this) &#123;  </span><br><span class="line"> if (mClassLoader !&#x3D; null) &#123;  </span><br><span class="line"> return mClassLoader;  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line"> if (mIncludeCode &amp;&amp; !mPackageName.equals(&quot;android&quot;)) &#123;  </span><br><span class="line"> &#x2F;&#x2F; 略...  </span><br><span class="line"> mClassLoader &#x3D; ApplicationLoaders.getDefault().getClassLoader(zip, lib,  </span><br><span class="line"> mBaseClassLoader);  </span><br><span class="line">  </span><br><span class="line"> StrictMode.setThreadPolicy(oldPolicy);  </span><br><span class="line"> &#125; else &#123;  </span><br><span class="line"> if (mBaseClassLoader &#x3D;&#x3D; null) &#123;  </span><br><span class="line"> mClassLoader &#x3D; ClassLoader.getSystemClassLoader();  </span><br><span class="line"> &#125; else &#123;  </span><br><span class="line"> mClassLoader &#x3D; mBaseClassLoader;  </span><br><span class="line"> &#125;  </span><br><span class="line"> &#125;  </span><br><span class="line"> return mClassLoader;  </span><br><span class="line"> &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，非<code>android</code>开头的包和<code>android</code>开头的包分别使用了两种不同的ClassLoader，我们只关心第一种；因此继续跟踪ApplicationLoaders类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public ClassLoader getClassLoader(String zip, String libPath, ClassLoader parent)  </span><br><span class="line">&#123;  </span><br><span class="line">  </span><br><span class="line"> ClassLoader baseParent &#x3D; ClassLoader.getSystemClassLoader().getParent();  </span><br><span class="line">  </span><br><span class="line"> synchronized (mLoaders) &#123;  </span><br><span class="line"> if (parent &#x3D;&#x3D; null) &#123;  </span><br><span class="line"> parent &#x3D; baseParent;  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line"> if (parent &#x3D;&#x3D; baseParent) &#123;  </span><br><span class="line"> ClassLoader loader &#x3D; mLoaders.get(zip);  </span><br><span class="line"> if (loader !&#x3D; null) &#123;  </span><br><span class="line"> return loader;  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line"> Trace.traceBegin(Trace.TRACE\_TAG\_ACTIVITY_MANAGER, zip);  </span><br><span class="line"> PathClassLoader pathClassloader &#x3D;  </span><br><span class="line"> new PathClassLoader(zip, libPath, parent);  </span><br><span class="line"> Trace.traceEnd(Trace.TRACE\_TAG\_ACTIVITY_MANAGER);  </span><br><span class="line">  </span><br><span class="line"> mLoaders.put(zip, pathClassloader);  </span><br><span class="line"> return pathClassloader;  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line"> Trace.traceBegin(Trace.TRACE\_TAG\_ACTIVITY_MANAGER, zip);  </span><br><span class="line"> PathClassLoader pathClassloader &#x3D; new PathClassLoader(zip, parent);  </span><br><span class="line"> Trace.traceEnd(Trace.TRACE\_TAG\_ACTIVITY_MANAGER);  </span><br><span class="line"> return pathClassloader;  </span><br><span class="line"> &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，应用程序使用的ClassLoader都是PathClassLoader类的实例。那么，这个PathClassLoader是什么呢？从Android SDK给出的源码只能看出这么多：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class PathClassLoader extends BaseDexClassLoader &#123;  </span><br><span class="line"> public PathClassLoader(String dexPath, ClassLoader parent) &#123;  </span><br><span class="line"> super((String)null, (File)null, (String)null, (ClassLoader)null);  </span><br><span class="line"> throw new RuntimeException(&quot;Stub!&quot;);  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line"> public PathClassLoader(String dexPath, String libraryPath, ClassLoader parent) &#123;  </span><br><span class="line"> super((String)null, (File)null, (String)null, (ClassLoader)null);  </span><br><span class="line"> throw new RuntimeException(&quot;Stub!&quot;);  </span><br><span class="line"> &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>SDK没有导出这个类的源码，我们去<a href="http://androidxref.com/6.0.1_r10/xref/libcore/dalvik/src/main/java/dalvik/system/PathClassLoader.java" target="_blank" rel="noopener">androidxref</a>上面看；发现其实这个类真的就这么多内容；我们继续查看它的父类<a href="http://androidxref.com/6.0.1_r10/xref/libcore/dalvik/src/main/java/dalvik/system/BaseDexClassLoader.java" target="_blank" rel="noopener">BaseDexClassLoader</a>；ClassLoader嘛，我们查看findClass或者defineClass方法，BaseDexClassLoader的findClass方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123;  </span><br><span class="line"> List&lt;Throwable&gt; suppressedExceptions &#x3D; new ArrayList&lt;Throwable&gt;();  </span><br><span class="line"> Class c &#x3D; pathList.findClass(name, suppressedExceptions);  </span><br><span class="line"> if (c &#x3D;&#x3D; null) &#123;  </span><br><span class="line"> ClassNotFoundException cnfe &#x3D; new ClassNotFoundException(&quot;Didn&#39;t find class \\&quot;&quot; \+ name + &quot;\\&quot; on path: &quot; \+ pathList);  </span><br><span class="line"> for (Throwable t : suppressedExceptions) &#123;  </span><br><span class="line"> cnfe.addSuppressed(t);  </span><br><span class="line"> &#125;  </span><br><span class="line"> throw cnfe;  </span><br><span class="line"> &#125;  </span><br><span class="line"> return c;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，查找Class的任务通过<code>pathList</code>完成；这个<code>pathList</code>是一个<code>DexPathList</code>类的对象，它的<code>findClass</code>方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public Class findClass(String name, List&lt;Throwable&gt; suppressed) &#123;  </span><br><span class="line"> for (Element element : dexElements) &#123;  </span><br><span class="line"> DexFile dex &#x3D; element.dexFile;  </span><br><span class="line">  </span><br><span class="line"> if (dex !&#x3D; null) &#123;  </span><br><span class="line"> Class clazz &#x3D; dex.loadClassBinaryName(name, definingContext, suppressed);  </span><br><span class="line"> if (clazz !&#x3D; null) &#123;  </span><br><span class="line"> return clazz;  </span><br><span class="line"> &#125;  </span><br><span class="line"> &#125;  </span><br><span class="line"> &#125;  </span><br><span class="line"> if (dexElementsSuppressedExceptions !&#x3D; null) &#123;  </span><br><span class="line"> suppressed.addAll(Arrays.asList(dexElementsSuppressedExceptions));  </span><br><span class="line"> &#125;  </span><br><span class="line"> return null;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个DexPathList内部有一个叫做dexElements的数组，然后findClass的时候会遍历这个数组来查找Class；<strong>如果我们把插件的信息塞进这个数组里面，那么不就能够完成类的加载过程吗？！！</strong></p>
<h3 id="给默认ClassLoader打补丁"><a href="#给默认ClassLoader打补丁" class="headerlink" title="给默认ClassLoader打补丁"></a>给默认ClassLoader打补丁</h3><p>通过上述分析，我们知道，可以把插件的相关信息放入BaseDexClassLoader的表示dex文件的数组里面，这样宿主程序的ClassLoader在进行类加载，遍历这个数组的时候，会自动遍历到我们添加进去的插件信息，从而完成插件类的加载！</p>
<p>接下来，我们实现这个过程；我们会用到一些较为复杂的反射技术哦～不过代码非常短：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public static void patchClassLoader(ClassLoader cl, File apkFile, File optDexFile)  </span><br><span class="line"> throws IllegalAccessException, NoSuchMethodException, IOException, InvocationTargetException, InstantiationException, NoSuchFieldException &#123;  </span><br><span class="line"> &#x2F;&#x2F; 获取 BaseDexClassLoader : pathList  </span><br><span class="line"> Field pathListField &#x3D; DexClassLoader.class.getSuperclass().getDeclaredField(&quot;pathList&quot;);  </span><br><span class="line"> pathListField.setAccessible(true);  </span><br><span class="line"> Object pathListObj &#x3D; pathListField.get(cl);  </span><br><span class="line">  </span><br><span class="line"> &#x2F;&#x2F; 获取 PathList: Element\[\] dexElements  </span><br><span class="line"> Field dexElementArray &#x3D; pathListObj.getClass().getDeclaredField(&quot;dexElements&quot;);  </span><br><span class="line"> dexElementArray.setAccessible(true);  </span><br><span class="line"> Object\[\] dexElements &#x3D; (Object\[\]) dexElementArray.get(pathListObj);  </span><br><span class="line">  </span><br><span class="line"> &#x2F;&#x2F; Element 类型  </span><br><span class="line"> Class&lt;?&gt; elementClass &#x3D; dexElements.getClass().getComponentType();  </span><br><span class="line">  </span><br><span class="line"> &#x2F;&#x2F; 创建一个数组, 用来替换原始的数组  </span><br><span class="line"> Object\[\] newElements &#x3D; (Object\[\]) Array.newInstance(elementClass, dexElements.length + 1);  </span><br><span class="line">  </span><br><span class="line"> &#x2F;&#x2F; 构造插件Element(File file, boolean isDirectory, File zip, DexFile dexFile) 这个构造函数  </span><br><span class="line"> Constructor&lt;?&gt; constructor &#x3D; elementClass.getConstructor(File.class, boolean.class, File.class, DexFile.class);  </span><br><span class="line"> Object o &#x3D; constructor.newInstance(apkFile, false, apkFile, DexFile.loadDex(apkFile.getCanonicalPath(), optDexFile.getAbsolutePath(), 0));  </span><br><span class="line">  </span><br><span class="line"> Object\[\] toAddElementArray &#x3D; new Object\[\] &#123; o &#125;;  </span><br><span class="line"> &#x2F;&#x2F; 把原始的elements复制进去  </span><br><span class="line"> System.arraycopy(dexElements, 0, newElements, 0, dexElements.length);  </span><br><span class="line"> &#x2F;&#x2F; 插件的那个element复制进去  </span><br><span class="line"> System.arraycopy(toAddElementArray, 0, newElements, dexElements.length, toAddElementArray.length);  </span><br><span class="line">  </span><br><span class="line"> &#x2F;&#x2F; 替换  </span><br><span class="line"> dexElementArray.set(pathListObj, newElements);  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>短短的二十几行代码，我们就完成了『委托宿主ClassLoader加载插件类』的任务；因此第二种方案也宣告完成！我们简要总结一下这种方式的原理：</p>
<ol>
<li>默认情况下performLacunchActivity会使用替身StubActivity的ApplicationInfo也就是宿主程序的CLassLoader加载所有的类；我们的思路是告诉宿主ClassLoader我们在哪，让其帮助完成类加载的过程。</li>
<li>宿主程序的ClassLoader最终继承自BaseDexClassLoader，BaseDexClassLoader通过DexPathList进行类的查找过程；而这个查找通过遍历一个dexElements的数组完成；<strong>我们通过把插件dex添加进这个数组</strong>就让宿主ClasLoader获取了加载插件类的能力。</li>
</ol>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文中我们采用两种方案成功完成了『启动没有在AndroidManifest.xml中显示声明，并且存在于外部插件中的Activity』的任务。</p>
<p>『激进方案』中我们自定义了插件的ClassLoader，并且绕开了Framework的检测；利用ActivityThread对于LoadedApk的缓存机制，我们把携带这个自定义的ClassLoader的插件信息添加进<code>mPackages</code>中，进而完成了类的加载过程。</p>
<p>『保守方案』中我们深入探究了系统使用ClassLoader findClass的过程，发现应用程序使用的非系统类都是通过同一个PathClassLoader加载的；而这个类的最终父类BaseDexClassLoader通过DexPathList完成类的查找过程；我们hack了这个查找过程，从而完成了插件类的加载。</p>
<p>这两种方案孰优孰劣呢？</p>
<p>很显然，『激进方案』比较麻烦，从代码量和分析过程就可以看出来，这种机制异常复杂；而且在解析apk的时候我们使用的PackageParser的兼容性非常差，我们不得不手动处理每一个版本的apk解析api；另外，它Hook的地方也有点多：不仅需要Hook AMS和<code>H</code>，还需要Hook ActivityThread的<code>mPackages</code>和PackageManager！</p>
<p>『保守方案』则简单得多（虽然原理也不简单），不仅代码很少，而且Hook的地方也不多；有一点正本清源的意思，从最最上层Hook住了整个类的加载过程。</p>
<p>但是，我们不能简单地说『保守方案』比『激进方案』好。从根本上说，这两种方案的差异在哪呢？</p>
<p>『激进方案』是<strong>多ClassLoader构架</strong>，每一个插件都有一个自己的ClassLoader，因此类的隔离性非常好——如果不同的插件使用了同一个库的不同版本，它们相安无事！『保守方案』是<strong>单ClassLoader方案</strong>，插件和宿主程序的类全部都通过宿主的ClasLoader加载，虽然代码简单，但是鲁棒性很差；一旦插件之间甚至插件与宿主之间使用的类库有冲突，那么直接GG。</p>
<p>多ClassLoader还有一个优点：可以真正完成代码的热加载！如果插件需要升级，直接重新创建一个自定的ClassLoader加载新的插件，然后替换掉原来的版本即可（Java中，不同ClassLoader加载的同一个类被认为是不同的类）；单ClassLoader的话实现非常麻烦，有可能需要重启进程。</p>
<p>在J2EE领域中广泛使用ClasLoader的地方均采用多ClassLoader架构，比如Tomcat服务器，Java模块化事实标准的OSGi技术；所以，我们有足够的理由认为<strong>选择多ClassLoader架构在大多数情况下是明智之举</strong>。</p>
<p>目前开源的插件方案中，DroidPlugin采用的『激进方案』，Small采用的『保守方案』那么，有没有两种优点兼顾的方案呢？？</p>
<p>答案自然是有的。</p>
<p>DroidPlugin和Small的共同点是<strong>两者都是非侵入式的插件框架</strong>；什么是『非侵入式』呢？打个比方，你启动一个插件Activity，直接使用<code>startActivity</code>即可，就跟开发普通的apk一样，开发插件和普通的程序对于开发者来说没有什么区别。</p>
<p>如果我们一定程度上放弃这种『侵入性』，那么我们就能实现一个两者优点兼而有之的插件框架！这里我先卖个关子～</p>
<p>OK，本文的内容就到这里了；关于『插件机制对于Activity的处理方式』也就此完结。要说明的是，在本文的『保守方案』其实只处理了代码的加载过程，它并不能加载有资源的apk！所以目前我这个实现基本没什么暖用；当然我这里只是就『代码加载』进行举例；至于资源，那牵扯到另外一个问题——<strong>插件系统的资源管理机制</strong>这个在后续文章的合适机会我会单独讲解。</p>
<p>接下来的文章，会讲述Android四大组件的另外三个<code>Service</code>，<code>BroadCastReceiver</code>, <code>ContentProvider</code>的处理方式。喜欢就点个赞吧～持续更新，请关注github项目 <a href="https://github.com/tiann/understand-plugin-framework" target="_blank" rel="noopener">understand-plugin-framework</a>和我的 <a href="http://weishu.me" target="_blank" rel="noopener">博客</a>! 这文章我前前后后准备了快两个星期，如果你看到了这里，还请支持一下 :)</p>
<p><a href="/tags/android/">#android</a> <a href="/tags/binder/">#binder</a> <a href="/tags/classloader/">#classloader</a> <a href="/tags/droidplugin/">#droidplugin</a> <a href="/tags/plugin-framework/">#plugin framework</a></p>
<p><a href="/2016/04/12/understand-plugin-framework-receiver/">Android插件化原理解析——广播的管理</a></p>
<p><a href="/2016/03/21/understand-plugin-framework-activity-management/">Android 插件化原理解析——Activity生命周期管理</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://reoger.tk/2018/08/31/android/Android%20%E6%8F%92%E4%BB%B6%E5%8C%96%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90%E2%80%94%E2%80%94%E6%8F%92%E4%BB%B6%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="reoger">
      <meta itemprop="description" content="reoger">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="reoger的记录">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/08/31/android/Android%20%E6%8F%92%E4%BB%B6%E5%8C%96%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90%E2%80%94%E2%80%94%E6%8F%92%E4%BB%B6%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/" class="post-title-link" itemprop="url">Android 插件化原理解析——插件加载机制</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-08-31 11:13:55" itemprop="dateCreated datePublished" datetime="2018-08-31T11:13:55+08:00">2018-08-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-07-18 14:45:00" itemprop="dateModified" datetime="2020-07-18T14:45:00+08:00">2020-07-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%BD%AC%E8%BD%BD/" itemprop="url" rel="index"><span itemprop="name">转载</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Android-插件化原理解析——插件加载机制"><a href="#Android-插件化原理解析——插件加载机制" class="headerlink" title="Android 插件化原理解析——插件加载机制"></a>Android 插件化原理解析——插件加载机制</h1><p>本文转载自<a href="http://weishu.me/2016/04/05/understand-plugin-framework-classloader/" target="_blank" rel="noopener">http://weishu.me/2016/04/05/understand-plugin-framework-classloader/</a>。</p>
<p>上文 <a href="http://weishu.me/2016/03/21/understand-plugin-framework-activity-management/" target="_blank" rel="noopener">Activity生命周期管理</a> 中我们地完成了『启动没有在AndroidManifest.xml中显式声明的Activity』的任务；通过Hook <code>AMS</code>和拦截ActivityThread中<code>H</code>类对于组件调度我们成功地绕过了AndroidMAnifest.xml的限制。</p>
<p>但是我们启动的『没有在AndroidManifet.xml中显式声明』的Activity和宿主程序存在于同一个Apk中；通常情况下，插件均以独立的文件存在甚至通过网络获取，这时候插件中的Activity能否成功启动呢？</p>
<p>要启动Activity组件肯定先要创建对应的Activity类的对象，从上文 <a href="http://weishu.me/2016/03/21/understand-plugin-framework-activity-management/" target="_blank" rel="noopener">Activity生命周期管理</a> 知道，创建Activity类对象的过程如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">java.lang.ClassLoader cl &#x3D; r.packageInfo.getClassLoader();  </span><br><span class="line">activity &#x3D; mInstrumentation.newActivity(  </span><br><span class="line"> cl, component.getClassName(), r.intent);  </span><br><span class="line">StrictMode.incrementExpectedActivityCount(activity.getClass());  </span><br><span class="line">r.intent.setExtrasClassLoader(cl);</span><br></pre></td></tr></table></figure>
<p>也就是说，系统通过<code>ClassLoader</code>加载了需要的Activity类并通过反射调用构造函数创建出了Activity对象。如果Activity组件存在于独立于宿主程序的文件之中，系统的ClassLoader怎么知道去哪里加载呢？因此，如果不做额外的处理，插件中的Activity对象甚至都没有办法创建出来，谈何启动？</p>
<p>因此，要使存在于独立文件或者网络中的插件被成功启动，首先就需要解决这个<strong>插件类加载</strong>的问题。<br>下文将围绕此问题展开，完成『启动没有在AndroidManifest.xml中显示声明，并且存在于外部插件中的Activity』的任务。</p>
<p>阅读本文之前，可以先clone一份 <a href="https://github.com/tiann/understand-plugin-framework" target="_blank" rel="noopener">understand-plugin-framework</a>，参考此项目的<code>classloader-hook</code> 模块。另外，插件框架原理解析系列文章见<a href="http://weishu.me/2016/01/28/understand-plugin-framework-overview/" target="_blank" rel="noopener">索引</a>。</p>
<h2 id="ClassLoader机制"><a href="#ClassLoader机制" class="headerlink" title="ClassLoader机制"></a>ClassLoader机制</h2><p>或许有的童鞋还不太了解Java的ClassLoader机制，我这里简要介绍一下。</p>
<blockquote>
<p>Java虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校检、转换解析和初始化的，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。<br>与那些在编译时进行链连接工作的语言不同，在Java语言里面，类型的加载、连接和初始化都是在程序运行期间完成的，这种策略虽然会令类加载时稍微增加一些性能开销，但是会为Java应用程序提供高度的灵活性，Java里天生可以同代拓展的语言特性就是依赖运行期动态加载和动态链接这个特点实现的。例如，如果编写一个面相接口的应用程序，可以等到运行时在制定实际的实现类；用户可以通过Java与定义的和自定义的类加载器，让一个本地的应用程序可以在运行时从网络或其他地方加载一个二进制流作为代码的一部分，这种组装应用程序的方式目前已经广泛应用于Java程序之中。从最基础的Applet，JSP到复杂的OSGi技术，都使用了Java语言运行期类加载的特性。</p>
</blockquote>
<p>Java的类加载是一个相对复杂的过程；它包括加载、验证、准备、解析和初始化五个阶段；对于开发者来说，可控性最强的是<strong>加载阶段</strong>；加载阶段主要完成三件事：</p>
<ol>
<li>根据一个类的全限定名来获取定义此类的二进制字节流</li>
<li>将这个字节流所代表的静态存储结构转化为JVM方法区中的运行时数据结构</li>
<li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。</li>
</ol>
<p>『通过一个类的全限定名获取描述此类的二进制字节流』这个过程被抽象出来，就是Java的类加载器模块，也即JDK中ClassLoader API。</p>
<p>Android Framework提供了DexClassLoader这个类，简化了『通过一个类的全限定名获取描述次类的二进制字节流』这个过程；我们只需要告诉DexClassLoader一个dex文件或者apk文件的路径就能完成类的加载。因此本文的内容用一句话就可以概括：</p>
<p><strong>将插件的dex或者apk文件告诉『合适的』DexClassLoader，借助它完成插件类的加载</strong></p>
<p>关于CLassLoader机制更多的内容，请参阅『深入理解Java虚拟机』这本书。</p>
<h2 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h2><p>Android系统使用了ClassLoader机制来进行Activity等组件的加载；apk被安装之后，APK文件的代码以及资源会被系统存放在固定的目录（比如/data/app/package_name/base-1.apk )系统在进行类加载的时候，会自动去这一个或者几个特定的路径来寻找这个类；但是系统并不知道存在于插件中的Activity组件的信息(插件可以是任意位置，甚至是网络，系统无法提前预知)，因此正常情况下系统无法加载我们插件中的类；因此也没有办法创建Activity的对象，更不用谈启动组件了。</p>
<p>解决这个问题有两个思路，要么全盘接管这个类加载的过程；要么告知系统我们使用的插件存在于哪里，让系统帮忙加载；这两种方式或多或少都需要<strong>干预</strong>这个类加载的过程。老规矩，知己知彼，百战不殆。我们首先分析一下，系统是如果完成这个类加载过程的。</p>
<p>我们再次搬出Activity的创建过程的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">java.lang.ClassLoader cl &#x3D; r.packageInfo.getClassLoader();  </span><br><span class="line">activity &#x3D; mInstrumentation.newActivity(cl, component.getClassName(), r.intent);  </span><br><span class="line">StrictMode.incrementExpectedActivityCount(activity.getClass());  </span><br><span class="line">r.intent.setExtrasClassLoader(cl);</span><br></pre></td></tr></table></figure>
<p>这里可以很明显地看到，系统通过待启动的Activity的类名<code>className</code>，然后使用ClassLoader对象<code>cl</code>把这个类加载进虚拟机，最后使用反射创建了这个Activity类的实例对象。要想干预这个ClassLoader（告知它我们的路径或者替换他），我们首先得看看这玩意到底是个什么来头。（从哪里创建的）</p>
<p><code>cl</code>这个ClasssLoader对象通过<code>r.packageInfo</code>对象的getClassLoader()方法得到，r.packageInfo是一个LoadedApk类的对象；那么，LoadedApk到底是个什么东西？？</p>
<p>我们查阅LoadedApk类的文档，只有一句话，不过说的很明白：</p>
<blockquote>
<p>Local state maintained about a currently loaded .apk.</p>
</blockquote>
<p><strong>LoadedApk对象是APK文件在内存中的表示。</strong> Apk文件的相关信息，诸如Apk文件的代码和资源，甚至代码里面的Activity，Service等组件的信息我们都可以通过此对象获取。</p>
<p>OK, 我们知道这个LoadedApk是何方神圣了；接下来我们要搞清楚的是：这个 <code>r.packageInfo</code> 到底是从哪里获取的？</p>
<p>我们顺着 performLaunchActivity上溯，辗转handleLaunchActivity回到了 <code>H</code> 类的LAUNCH_ACTIVITY消息，找到了<code>r.packageInfo</code>的来源：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">final ActivityClientRecord r &#x3D; (ActivityClientRecord) msg.obj;  </span><br><span class="line">r.packageInfo &#x3D; getPackageInfoNoCheck(  </span><br><span class="line"> r.activityInfo.applicationInfo, r.compatInfo);  </span><br><span class="line">handleLaunchActivity(r, null);</span><br></pre></td></tr></table></figure>
<p>getPackageInfoNoCheck方法很简单，直接调用了getPackageInfo方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public final LoadedApk getPackageInfoNoCheck(ApplicationInfo ai,  </span><br><span class="line"> CompatibilityInfo compatInfo) &#123;  </span><br><span class="line"> return getPackageInfo(ai, compatInfo, null, false, true, false);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个getPackageInfo方法里面我们发现了端倪：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">private LoadedApk getPackageInfo(ApplicationInfo aInfo, CompatibilityInfo compatInfo,  </span><br><span class="line"> ClassLoader baseLoader, boolean securityViolation, boolean includeCode,  </span><br><span class="line"> boolean registerPackage) &#123;  </span><br><span class="line"> &#x2F;&#x2F; 获取userid信息  </span><br><span class="line"> final boolean differentUser &#x3D; (UserHandle.myUserId() !&#x3D; UserHandle.getUserId(aInfo.uid));  </span><br><span class="line"> synchronized (mResourcesManager) &#123;  </span><br><span class="line"> &#x2F;&#x2F; 尝试获取缓存信息  </span><br><span class="line"> WeakReference&lt;LoadedApk&gt; ref;  </span><br><span class="line"> if (differentUser) &#123;  </span><br><span class="line"> &#x2F;&#x2F; Caching not supported across users  </span><br><span class="line"> ref &#x3D; null;  </span><br><span class="line"> &#125; else if (includeCode) &#123;  </span><br><span class="line"> ref &#x3D; mPackages.get(aInfo.packageName);  </span><br><span class="line"> &#125; else &#123;  </span><br><span class="line"> ref &#x3D; mResourcePackages.get(aInfo.packageName);  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line"> LoadedApk packageInfo &#x3D; ref !&#x3D; null ? ref.get() : null;  </span><br><span class="line"> if (packageInfo &#x3D;&#x3D; null || (packageInfo.mResources !&#x3D; null  </span><br><span class="line"> &amp;&amp; !packageInfo.mResources.getAssets().isUpToDate())) &#123;  </span><br><span class="line"> &#x2F;&#x2F; 缓存没有命中，直接new  </span><br><span class="line"> packageInfo &#x3D;  </span><br><span class="line"> new LoadedApk(this, aInfo, compatInfo, baseLoader,  </span><br><span class="line"> securityViolation, includeCode &amp;&amp;  </span><br><span class="line"> (aInfo.flags&amp;ApplicationInfo.FLAG\_HAS\_CODE) !&#x3D; 0, registerPackage);  </span><br><span class="line">  </span><br><span class="line"> &#x2F;&#x2F; 省略。。更新缓存  </span><br><span class="line"> return packageInfo;  </span><br><span class="line"> &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法很重要，我们必须弄清楚每一步；</p>
<p>首先，它判断了调用方和或许App信息的一方是不是同一个userId；如果是同一个user，那么可以共享缓存数据（要么缓存的代码数据，要么缓存的资源数据）</p>
<p>接下来尝试获取缓存数据；如果没有命中缓存数据，才通过LoadedApk的构造函数创建了LoadedApk对象；创建成功之后，如果是同一个uid还放入了缓存。</p>
<p>提到缓存数据，看过<a href="http://weishu.me/2016/02/16/understand-plugin-framework-binder-hook/" target="_blank" rel="noopener">Hook机制之Binder Hook</a>的童鞋可能就知道了，我们之前成功借助ServiceManager的本地代理使用缓存的机制Hook了各种Binder；因此这里完全可以如法炮制——我们拿到这一份缓存数据，修改里面的ClassLoader；自己控制类加载的过程，这样加载插件中的Activity类的问题就解决了。这就引出了我们加载插件类的第一种方案：</p>
<h2 id="激进方案：Hook掉ClassLoader，自己操刀"><a href="#激进方案：Hook掉ClassLoader，自己操刀" class="headerlink" title="激进方案：Hook掉ClassLoader，自己操刀"></a>激进方案：Hook掉ClassLoader，自己操刀</h2><p>从上述分析中我们得知，在获取LoadedApk的过程中使用了一份缓存数据；这个缓存数据是一个<code>Map</code>，从包名到LoadedApk的一个映射。正常情况下，我们的插件肯定不会存在于这个对象里面；但是<strong>如果我们手动把我们插件的信息添加到里面呢？</strong>系统在查找缓存的过程中，会直接命中缓存！进而使用我们添加进去的LoadedApk的ClassLoader来加载这个特定的Activity类！这样我们就能接管我们自己插件类的加载过程了！</p>
<p>这个缓存对象<code>mPackages</code>存在于ActivityThread类中；老方法，我们首先获取这个对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 先获取到当前的ActivityThread对象  </span><br><span class="line">Class&lt;?&gt; activityThreadClass &#x3D; Class.forName(&quot;android.app.ActivityThread&quot;);  </span><br><span class="line">Method currentActivityThreadMethod &#x3D; activityThreadClass.getDeclaredMethod(&quot;currentActivityThread&quot;);  </span><br><span class="line">currentActivityThreadMethod.setAccessible(true);  </span><br><span class="line">Object currentActivityThread &#x3D; currentActivityThreadMethod.invoke(null);  </span><br><span class="line">  </span><br><span class="line">&#x2F;&#x2F; 获取到 mPackages 这个静态成员变量, 这里缓存了dex包的信息  </span><br><span class="line">Field mPackagesField &#x3D; activityThreadClass.getDeclaredField(&quot;mPackages&quot;);  </span><br><span class="line">mPackagesField.setAccessible(true);  </span><br><span class="line">Map mPackages &#x3D; (Map) mPackagesField.get(currentActivityThread);</span><br></pre></td></tr></table></figure>
<p>拿到这个Map之后接下来怎么办呢？<strong>我们需要填充这个map，把插件的信息塞进这个map里面</strong>，以便系统在查找的时候能命中缓存。但是这个填充这个Map我们出了需要包名之外，还需要一个LoadedApk对象；如何创建一个LoadedApk对象呢？</p>
<p>我们当然可以直接反射调用它的构造函数直接创建出需要的对象，但是万一哪里有疏漏，构造参数填错了怎么办？又或者Android的不同版本使用了不同的参数，导致我们创建出来的对象与系统创建出的对象不一致，无法work怎么办？</p>
<p>因此我们需要使用与系统完全相同的方式创建LoadedApk对象；从上文分析得知，系统创建LoadedApk对象是通过<code>getPackageInfo</code>来完成的，因此我们可以调用这个函数来创建LoadedApk对象；但是这个函数是<code>private</code>的，我们无法使用。</p>
<p>有的童鞋可能会有疑问了，<code>private</code>不是也能反射到吗？我们确实能够调用这个函数，但是<code>private</code>表明这个函数是内部实现，或许那一天Google高兴，把这个函数改个名字我们就直接GG了；但是public函数不同，public被导出的函数你无法保证是否有别人调用它，因此大部分情况下不会修改；我们最好调用public函数来保证尽可能少的遇到兼容性问题。（当然，如果实在木有路可以考虑调用私有方法，自己处理兼容性问题，这个我们以后也会遇到）</p>
<p>间接调用<code>getPackageInfo</code>这个私有函数的public函数有同名的getPackageInfo系列和getPackageInfoNoCheck；简单查看源代码发现，getPackageInfo除了获取包的信息，还检查了包的一些组件；为了绕过这些验证，我们选择使用<code>getPackageInfoNoCheck</code>获取LoadedApk信息。</p>
<h3 id="构建插件LoadedApk对象"><a href="#构建插件LoadedApk对象" class="headerlink" title="构建插件LoadedApk对象"></a>构建插件LoadedApk对象</h3><p>我们这一步的目的很明确，通过getPackageInfoNoCheck函数创建出我们需要的LoadedApk对象，以供接下来使用。</p>
<p>这个函数的签名如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public final LoadedApk getPackageInfoNoCheck(ApplicationInfo ai,  </span><br><span class="line"> CompatibilityInfo compatInfo) &#123;</span><br></pre></td></tr></table></figure>
<p>因此，为了调用这个函数，我们需要构造两个参数。其一是ApplicationInfo，其二是CompatibilityInfo；第二个参数顾名思义，代表这个App的兼容性信息，比如targetSDK版本等等，这里我们只需要提取出app的信息，因此直接使用默认的兼容性即可；在CompatibilityInfo类里面有一个公有字段DEFAULT_COMPATIBILITY_INFO代表默认兼容性信息；因此，我们的首要目标是获取这个ApplicationInfo信息。</p>
<h3 id="构建插件ApplicationInfo信息"><a href="#构建插件ApplicationInfo信息" class="headerlink" title="构建插件ApplicationInfo信息"></a>构建插件ApplicationInfo信息</h3><p>我们首先看看ApplicationInfo代表什么，这个类的文档说的很清楚：</p>
<blockquote>
<p>Information you can retrieve about a particular application. This corresponds to information collected from the AndroidManifest.xml’s <application> tag.</p>
</blockquote>
<p>也就是说，这个类就是AndroidManifest.xml里面的 这个标签下面的信息；这个AndroidManifest.xml无疑是一个标准的xml文件，因此我们完全可以自己使用parse来解析这个信息。</p>
<p>那么，系统是如何获取这个信息的呢？其实Framework就有一个这样的parser，也即PackageParser；理论上，我们也可以借用系统的parser来解析AndroidMAnifest.xml从而得到ApplicationInfo的信息。但遗憾的是，<strong>这个类的兼容性很差</strong>；Google几乎在每一个Android版本都对这个类动刀子，如果坚持使用系统的解析方式，必须写一系列兼容行代码！！DroidPlugin就选择了这种方式，相关类如下：</p>
<p><a href="http://7xp3xc.com1.z0.glb.clouddn.com/201601/1459829051777.png" target="_blank" rel="noopener" title="DroidPlugin的PackageParser"><img src="http://7xp3xc.com1.z0.glb.clouddn.com/201601/1459829051777.png" alt="DroidPlugin的PackageParser"></a></p>
<p><a href="http://7xp3xc.com1.z0.glb.clouddn.com/201601/1459829051777.png" target="_blank" rel="noopener" title="DroidPlugin的PackageParser">DroidPlugin的PackageParser</a></p>
<p>看到这里我就问你怕不怕！！！这也是我们之前提到的<strong>私有或者隐藏的API可以使用，但必须处理好兼容性问题</strong>；如果Android 7.0发布，这里估计得添加一个新的类PackageParseApi24。</p>
<p>我这里使用API 23作为演示，<strong>版本不同的可能无法运行</strong>请自行查阅 DroidPlugin 不同版本如何处理。</p>
<p>OK回到正题，我们决定使用PackageParser类来提取ApplicationInfo信息。下图是API 23上，PackageParser的部分类结构图：</p>
<p><a href="http://7xp3xc.com1.z0.glb.clouddn.com/201601/1459829674687.png" target="_blank" rel="noopener"><img src="http://7xp3xc.com1.z0.glb.clouddn.com/201601/1459829674687.png" alt=""></a></p>
<p>看起来有我们需要的方法 generateApplication；确实如此，依靠这个方法我们可以成功地拿到ApplicationInfo。<br>由于PackageParser是@hide的，因此我们需要通过反射进行调用。我们根据这个generateApplicationInfo方法的签名：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public static ApplicationInfo generateApplicationInfo(Package p, int flags,  </span><br><span class="line"> PackageUserState state)</span><br></pre></td></tr></table></figure>
<p>可以写出调用generateApplicationInfo的反射代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; packageParserClass &#x3D; Class.forName(&quot;android.content.pm.PackageParser&quot;);  </span><br><span class="line">&#x2F;&#x2F; 首先拿到我们得终极目标: generateApplicationInfo方法  </span><br><span class="line">&#x2F;&#x2F; API 23 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  </span><br><span class="line">&#x2F;&#x2F; public static ApplicationInfo generateApplicationInfo(Package p, int flags,  </span><br><span class="line">&#x2F;&#x2F;    PackageUserState state) &#123;  </span><br><span class="line">&#x2F;&#x2F; 其他Android版本不保证也是如此.  </span><br><span class="line">Class&lt;?&gt; packageParser$PackageClass &#x3D; Class.forName(&quot;android.content.pm.PackageParser$Package&quot;);  </span><br><span class="line">Class&lt;?&gt; packageUserStateClass &#x3D; Class.forName(&quot;android.content.pm.PackageUserState&quot;);  </span><br><span class="line">Method generateApplicationInfoMethod &#x3D; packageParserClass.getDeclaredMethod(&quot;generateApplicationInfo&quot;,  </span><br><span class="line"> packageParser$PackageClass,  </span><br><span class="line"> int.class,  </span><br><span class="line"> packageUserStateClass);</span><br></pre></td></tr></table></figure>
<p>要成功调用这个方法，还需要三个参数；因此接下来我们需要一步一步构建调用此函数的参数信息。</p>
<h4 id="构建PackageParser-Package"><a href="#构建PackageParser-Package" class="headerlink" title="构建PackageParser.Package"></a>构建PackageParser.Package</h4><p>generateApplicationInfo方法需要的第一个参数是PackageParser.Package；从名字上看这个类代表某个apk包的信息，我们看看文档怎么解释：</p>
<blockquote>
<p>Representation of a full package parsed from APK files on disk. A package consists of a single base APK, and zero or more split APKs.</p>
</blockquote>
<p>果然，这个类代表从PackageParser中解析得到的某个apk包的信息，是磁盘上apk文件在内存中的数据结构表示；因此，要获取这个类，肯定需要解析整个apk文件。PackageParser中解析apk的核心方法是parsePackage，这个方法返回的就是一个Package类型的实例，因此我们调用这个方法即可；使用反射代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 首先, 我们得创建出一个Package对象出来供这个方法调用  </span><br><span class="line">&#x2F;&#x2F; 而这个需要得对象可以通过 android.content.pm.PackageParser#parsePackage 这个方法返回得 Package对象得字段获取得到  </span><br><span class="line">&#x2F;&#x2F; 创建出一个PackageParser对象供使用  </span><br><span class="line">Object packageParser &#x3D; packageParserClass.newInstance();  </span><br><span class="line">&#x2F;&#x2F; 调用 PackageParser.parsePackage 解析apk的信息  </span><br><span class="line">Method parsePackageMethod &#x3D; packageParserClass.getDeclaredMethod(&quot;parsePackage&quot;, File.class, int.class);  </span><br><span class="line">  </span><br><span class="line">&#x2F;&#x2F; 实际上是一个 android.content.pm.PackageParser.Package 对象  </span><br><span class="line">Object packageObj &#x3D; parsePackageMethod.invoke(packageParser, apkFile, 0);</span><br></pre></td></tr></table></figure>
<p>这样，我们就得到了generateApplicationInfo的第一个参数；第二个参数是解析包使用的flag，我们直接选择解析全部信息，也就是0；</p>
<h4 id="构建PackageUserState"><a href="#构建PackageUserState" class="headerlink" title="构建PackageUserState"></a>构建PackageUserState</h4><p>第三个参数是PackageUserState，代表不同用户中包的信息。由于Android是一个多任务多用户系统，因此不同的用户同一个包可能有不同的状态；这里我们只需要获取包的信息，因此直接使用默认的即可；</p>
<p>至此，generateApplicaionInfo的参数我们已经全部构造完成，直接调用此方法即可得到我们需要的applicationInfo对象；在返回之前我们需要做一点小小的修改：使用系统系统的这个方法解析得到的ApplicationInfo对象中并没有apk文件本身的信息，所以我们把解析的apk文件的路径设置一下（ClassLoader依赖dex文件以及apk的路径）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 第三个参数 mDefaultPackageUserState 我们直接使用默认构造函数构造一个出来即可  </span><br><span class="line">Object defaultPackageUserState &#x3D; packageUserStateClass.newInstance();  </span><br><span class="line">  </span><br><span class="line">&#x2F;&#x2F; 万事具备!!!!!!!!!!!!!!  </span><br><span class="line">ApplicationInfo applicationInfo &#x3D; (ApplicationInfo) generateApplicationInfoMethod.invoke(packageParser,  </span><br><span class="line"> packageObj, 0, defaultPackageUserState);  </span><br><span class="line">String apkPath &#x3D; apkFile.getPath();  </span><br><span class="line">applicationInfo.sourceDir &#x3D; apkPath;  </span><br><span class="line">applicationInfo.publicSourceDir &#x3D; apkPath;</span><br></pre></td></tr></table></figure>

<h3 id="替换ClassLoader"><a href="#替换ClassLoader" class="headerlink" title="替换ClassLoader"></a>替换ClassLoader</h3><h4 id="获取LoadedApk信息"><a href="#获取LoadedApk信息" class="headerlink" title="获取LoadedApk信息"></a>获取LoadedApk信息</h4><p>方才为了获取ApplicationInfo我们费了好大一番精力；回顾一下我们的初衷：</p>
<p>我们最终的目的是调用getPackageInfoNoCheck得到LoadedApk的信息，并替换其中的mClassLoader然后把把添加到ActivityThread的mPackages缓存中；从而达到我们使用自己的ClassLoader加载插件中的类的目的。</p>
<p>现在我们已经拿到了getPackageInfoNoCheck这个方法中至关重要的第一个参数applicationInfo；上文提到第二个参数CompatibilityInfo代表设备兼容性信息，直接使用默认的值即可；因此，两个参数都已经构造出来，我们可以调用getPackageInfoNoCheck获取LoadedApk：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; android.content.res.CompatibilityInfo  </span><br><span class="line">Class&lt;?&gt; compatibilityInfoClass &#x3D; Class.forName(&quot;android.content.res.CompatibilityInfo&quot;);  </span><br><span class="line">Method getPackageInfoNoCheckMethod &#x3D; activityThreadClass.getDeclaredMethod(&quot;getPackageInfoNoCheck&quot;, ApplicationInfo.class, compatibilityInfoClass);  </span><br><span class="line">  </span><br><span class="line">Field defaultCompatibilityInfoField &#x3D; compatibilityInfoClass.getDeclaredField(&quot;DEFAULT\_COMPATIBILITY\_INFO&quot;);  </span><br><span class="line">defaultCompatibilityInfoField.setAccessible(true);  </span><br><span class="line">  </span><br><span class="line">Object defaultCompatibilityInfo &#x3D; defaultCompatibilityInfoField.get(null);  </span><br><span class="line">ApplicationInfo applicationInfo &#x3D; generateApplicationInfo(apkFile);  </span><br><span class="line">  </span><br><span class="line">Object loadedApk &#x3D; getPackageInfoNoCheckMethod.invoke(currentActivityThread, applicationInfo, defaultCompatibilityInfo);</span><br></pre></td></tr></table></figure>
<p>我们成功地构造出了LoadedAPK, 接下来我们需要替换其中的ClassLoader，然后把它添加进ActivityThread的mPackages中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String odexPath &#x3D; Utils.getPluginOptDexDir(applicationInfo.packageName).getPath();  </span><br><span class="line">String libDir &#x3D; Utils.getPluginLibDir(applicationInfo.packageName).getPath();  </span><br><span class="line">ClassLoader classLoader &#x3D; new CustomClassLoader(apkFile.getPath(), odexPath, libDir, ClassLoader.getSystemClassLoader());  </span><br><span class="line">Field mClassLoaderField &#x3D; loadedApk.getClass().getDeclaredField(&quot;mClassLoader&quot;);  </span><br><span class="line">mClassLoaderField.setAccessible(true);  </span><br><span class="line">mClassLoaderField.set(loadedApk, classLoader);  </span><br><span class="line">&#x2F;&#x2F; 由于是弱引用, 因此我们必须在某个地方存一份, 不然容易被GC; 那么就前功尽弃了.  </span><br><span class="line">sLoadedApk.put(applicationInfo.packageName, loadedApk);  </span><br><span class="line">  </span><br><span class="line">WeakReference weakReference &#x3D; new WeakReference(loadedApk);  </span><br><span class="line">mPackages.put(applicationInfo.packageName, weakReference);</span><br></pre></td></tr></table></figure>
<p>我们的这个CustomClassLoader非常简单，直接继承了DexClassLoader，什么都没有做；当然这里可以直接使用DexClassLoader，这里重新创建一个类是为了更有区分度；以后也可以通过修改这个类实现对于类加载的控制：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class CustomClassLoader extends DexClassLoader &#123;  </span><br><span class="line">  </span><br><span class="line"> public CustomClassLoader(String dexPath, String optimizedDirectory, String libraryPath, ClassLoader parent) &#123;  </span><br><span class="line"> super(dexPath, optimizedDirectory, libraryPath, parent);  </span><br><span class="line"> &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到这里，我们已经成功地把把插件的信息放入ActivityThread中，这样我们插件中的类能够成功地被加载；因此插件中的Activity实例能被成功第创建；由于整个流程较为复杂，我们简单梳理一下：</p>
<ol>
<li>在ActivityThread接收到IApplication的 scheduleLaunchActivity远程调用之后，将消息转发给<code>H</code></li>
<li><code>H</code>类在handleMessage的时候，调用了getPackageInfoNoCheck方法来获取待启动的组件信息。在这个方法中会优先查找<code>mPackages</code>中的缓存信息，而我们已经手动把插件信息添加进去；因此能够成功命中缓存，获取到独立存在的插件信息。</li>
<li><code>H</code>类然后调用handleLaunchActivity最终转发到performLaunchActivity方法；这个方法使用从getPackageInfoNoCheck中拿到LoadedApk中的mClassLoader来加载Activity类，进而使用反射创建Activity实例；接着创建Application，Context等完成Activity组件的启动。</li>
</ol>
<p>看起来好像已经天衣无缝万事大吉了；但是运行一下会出现一个异常，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">04-05 02:49:53.742  11759-11759&#x2F;com.weishu.upf.hook_classloader E&#x2F;AndroidRuntime﹕ FATAL EXCEPTION: main  </span><br><span class="line"> Process: com.weishu.upf.hook_classloader, PID: 11759  </span><br><span class="line"> java.lang.RuntimeException: Unable to start activity ComponentInfo&#123;com.weishu.upf.ams\_pms\_hook.app&#x2F;com.weishu.upf.ams\_pms\_hook.app.MainActivity&#125;: java.lang.RuntimeException: Unable to instantiate application android.app.Application: java.lang.IllegalStateException: Unable to get package info for com.weishu.upf.ams\_pms\_hook.app; is package not installed?</span><br></pre></td></tr></table></figure>

<p>错误提示说是无法实例化 <code>Application</code>，而Application的创建也是在performLaunchActivity中进行的，这里有些蹊跷，我们仔细查看一下。</p>
<h4 id="绕过系统检查"><a href="#绕过系统检查" class="headerlink" title="绕过系统检查"></a>绕过系统检查</h4><p>通过ActivityThread的performLaunchActivity方法可以得知，Application通过LoadedApk的makeApplication方法创建，我们查看这个方法，在源码中发现了上文异常抛出的位置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">try &#123;  </span><br><span class="line"> java.lang.ClassLoader cl &#x3D; getClassLoader();  </span><br><span class="line"> if (!mPackageName.equals(&quot;android&quot;)) &#123;  </span><br><span class="line"> initializeJavaContextClassLoader();  </span><br><span class="line"> &#125;  </span><br><span class="line"> ContextImpl appContext &#x3D; ContextImpl.createAppContext(mActivityThread, this);  </span><br><span class="line"> app &#x3D; mActivityThread.mInstrumentation.newApplication(  </span><br><span class="line"> cl, appClass, appContext);  </span><br><span class="line"> appContext.setOuterContext(app);  </span><br><span class="line">&#125; catch (Exception e) &#123;  </span><br><span class="line"> if (!mActivityThread.mInstrumentation.onException(app, e)) &#123;  </span><br><span class="line"> throw new RuntimeException(  </span><br><span class="line"> &quot;Unable to instantiate application &quot; \+ appClass  </span><br><span class="line"> \+ &quot;: &quot; \+ e.toString(), e);  </span><br><span class="line"> &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>木有办法，我们只有一行一行地查看到底是哪里抛出这个异常的了；所幸代码不多。（所以说，缩小异常范围是一件多么重要的事情！！！）</p>
<p>第一句 getClassLoader() 没什么可疑的，虽然方法很长，但是它木有抛出任何异常（当然，它调用的代码可能抛出异常，万一找不到只能进一步深搜了；所以我觉得这里应该使用受检异常）。</p>
<p>然后我们看第二句，如果包名不是<code>android</code>开头，那么调用了一个叫做initializeJavaContextClassLoader的方法；我们查阅这个方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">private void initializeJavaContextClassLoader() &#123;  </span><br><span class="line"> IPackageManager pm &#x3D; ActivityThread.getPackageManager();  </span><br><span class="line"> android.content.pm.PackageInfo pi;  </span><br><span class="line"> try &#123;  </span><br><span class="line"> pi &#x3D; pm.getPackageInfo(mPackageName, 0, UserHandle.myUserId());  </span><br><span class="line"> &#125; catch (RemoteException e) &#123;  </span><br><span class="line"> throw new IllegalStateException(&quot;Unable to get package info for &quot;  </span><br><span class="line"> \+ mPackageName + &quot;; is system dying?&quot;, e);  </span><br><span class="line"> &#125;  </span><br><span class="line"> if (pi &#x3D;&#x3D; null) &#123;  </span><br><span class="line"> throw new IllegalStateException(&quot;Unable to get package info for &quot;  </span><br><span class="line"> \+ mPackageName + &quot;; is package not installed?&quot;);  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line"> boolean sharedUserIdSet &#x3D; (pi.sharedUserId !&#x3D; null);  </span><br><span class="line"> boolean processNameNotDefault &#x3D;  </span><br><span class="line"> (pi.applicationInfo !&#x3D; null &amp;&amp;  </span><br><span class="line"> !mPackageName.equals(pi.applicationInfo.processName));  </span><br><span class="line"> boolean sharable &#x3D; (sharedUserIdSet || processNameNotDefault);  </span><br><span class="line"> ClassLoader contextClassLoader &#x3D;  </span><br><span class="line"> (sharable)  </span><br><span class="line"> ? new WarningContextClassLoader()  </span><br><span class="line"> : mClassLoader;  </span><br><span class="line"> Thread.currentThread().setContextClassLoader(contextClassLoader);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里，我们找出了这个异常的来源：原来这里调用了<code>getPackageInfo</code>方法获取包的信息；而我们的插件<strong>并没有安装在系统上</strong>，因此系统肯定认为插件没有安装，这个方法肯定返回null。所以，我们还要欺骗一下PMS，让系统觉得<strong>插件已经安装在系统上了</strong>；至于如何欺骗 PMS，<a href="http://weishu.me/2016/03/07/understand-plugin-framework-ams-pms-hook/" target="_blank" rel="noopener">Hook机制之AMS&amp;PMS</a> 有详细解释，这里直接给出代码，不赘述了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">private static void hookPackageManager() throws Exception &#123;  </span><br><span class="line">  </span><br><span class="line"> &#x2F;&#x2F; 这一步是因为 initializeJavaContextClassLoader 这个方法内部无意中检查了这个包是否在系统安装  </span><br><span class="line"> &#x2F;&#x2F; 如果没有安装, 直接抛出异常, 这里需要临时Hook掉 PMS, 绕过这个检查.  </span><br><span class="line">  </span><br><span class="line"> Class&lt;?&gt; activityThreadClass &#x3D; Class.forName(&quot;android.app.ActivityThread&quot;);  </span><br><span class="line"> Method currentActivityThreadMethod &#x3D; activityThreadClass.getDeclaredMethod(&quot;currentActivityThread&quot;);  </span><br><span class="line"> currentActivityThreadMethod.setAccessible(true);  </span><br><span class="line"> Object currentActivityThread &#x3D; currentActivityThreadMethod.invoke(null);  </span><br><span class="line">  </span><br><span class="line"> &#x2F;&#x2F; 获取ActivityThread里面原始的 sPackageManager  </span><br><span class="line"> Field sPackageManagerField &#x3D; activityThreadClass.getDeclaredField(&quot;sPackageManager&quot;);  </span><br><span class="line"> sPackageManagerField.setAccessible(true);  </span><br><span class="line"> Object sPackageManager &#x3D; sPackageManagerField.get(currentActivityThread);  </span><br><span class="line">  </span><br><span class="line"> &#x2F;&#x2F; 准备好代理对象, 用来替换原始的对象  </span><br><span class="line"> Class&lt;?&gt; iPackageManagerInterface &#x3D; Class.forName(&quot;android.content.pm.IPackageManager&quot;);  </span><br><span class="line"> Object proxy &#x3D; Proxy.newProxyInstance(iPackageManagerInterface.getClassLoader(),  </span><br><span class="line"> new Class&lt;?&gt;\[\] &#123; iPackageManagerInterface &#125;,  </span><br><span class="line"> new IPackageManagerHookHandler(sPackageManager));  </span><br><span class="line">  </span><br><span class="line"> &#x2F;&#x2F; 1\. 替换掉ActivityThread里面的 sPackageManager 字段  </span><br><span class="line"> sPackageManagerField.set(currentActivityThread, proxy);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>OK到这里，我们已经能够成功地加载<strong>简单的</strong>独立的存在于外部文件系统中的apk了。至此 关于 DroidPlugin 对于Activity生命周期的管理已经完全讲解完毕了；这是一种极其复杂的Activity管理方案，我们仅仅写一个用来理解的demo就Hook了相当多的东西，在Framework层来回牵扯；这其中的来龙去脉要完全把握清楚还请读者亲自翻阅源码。另外，我在此 对DroidPlugin 作者献上我的膝盖～这其中的玄妙让人叹为观止！</p>
<p>上文给出的方案中，我们全盘接管了插件中类的加载过程，这是一种相对暴力的解决方案；能不能更温柔一点呢？通俗来说，我们可以选择改革，而不是革命——告诉系统ClassLoader一些必要信息，让它帮忙完成插件类的加载。</p>
<h2 id="保守方案：委托系统，让系统帮忙加载"><a href="#保守方案：委托系统，让系统帮忙加载" class="headerlink" title="保守方案：委托系统，让系统帮忙加载"></a>保守方案：委托系统，让系统帮忙加载</h2><p>我们再次搬出ActivityThread中加载Activity类的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">java.lang.ClassLoader cl &#x3D; r.packageInfo.getClassLoader();  </span><br><span class="line">activity &#x3D; mInstrumentation.newActivity(  </span><br><span class="line"> cl, component.getClassName(), r.intent);  </span><br><span class="line">StrictMode.incrementExpectedActivityCount(activity.getClass());  </span><br><span class="line">r.intent.setExtrasClassLoader(cl);</span><br></pre></td></tr></table></figure>
<p>我们知道 这个r.packageInfo中的<code>r</code>是通过getPackageInfoNoCheck获取到的；在『激进方案』中我们把插件apk手动添加进缓存，采用自己加载办法解决；如果我们不干预这个过程，导致无法命中mPackages中的缓存，会发生什么？</p>
<p>查阅 getPackageInfo方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">private LoadedApk getPackageInfo(ApplicationInfo aInfo, CompatibilityInfo compatInfo,  </span><br><span class="line"> ClassLoader baseLoader, boolean securityViolation, boolean includeCode,  </span><br><span class="line"> boolean registerPackage) &#123;  </span><br><span class="line"> final boolean differentUser &#x3D; (UserHandle.myUserId() !&#x3D; UserHandle.getUserId(aInfo.uid));  </span><br><span class="line"> synchronized (mResourcesManager) &#123;  </span><br><span class="line"> WeakReference&lt;LoadedApk&gt; ref;  </span><br><span class="line"> if (differentUser) &#123;  </span><br><span class="line"> &#x2F;&#x2F; Caching not supported across users  </span><br><span class="line"> ref &#x3D; null;  </span><br><span class="line"> &#125; else if (includeCode) &#123;  </span><br><span class="line"> ref &#x3D; mPackages.get(aInfo.packageName);  </span><br><span class="line"> &#125; else &#123;  </span><br><span class="line"> ref &#x3D; mResourcePackages.get(aInfo.packageName);  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line"> LoadedApk packageInfo &#x3D; ref !&#x3D; null ? ref.get() : null;  </span><br><span class="line"> if (packageInfo &#x3D;&#x3D; null || (packageInfo.mResources !&#x3D; null  </span><br><span class="line"> &amp;&amp; !packageInfo.mResources.getAssets().isUpToDate())) &#123;  </span><br><span class="line"> packageInfo &#x3D;  </span><br><span class="line"> new LoadedApk(this, aInfo, compatInfo, baseLoader,  </span><br><span class="line"> securityViolation, includeCode &amp;&amp;  </span><br><span class="line"> (aInfo.flags&amp;ApplicationInfo.FLAG\_HAS\_CODE) !&#x3D; 0, registerPackage);  </span><br><span class="line">  </span><br><span class="line"> &#x2F;&#x2F; 略  </span><br><span class="line"> &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，没有命中缓存的情况下，系统直接new了一个LoadedApk；注意这个构造函数的第二个参数<code>aInfo</code>，这是一个ApplicationInfo类型的对象。在『激进方案』中我们为了获取独立插件的ApplicationInfo花了不少心思；那么如果不做任何处理这里传入的这个<code>aInfo</code>参数是什么？</p>
<p>追本溯源不难发现，这个aInfo是从我们的替身StubActivity中获取的！而StubActivity存在于宿主程序中，所以，这个<code>aInfo</code>对象代表的实际上就是宿主程序的Application信息！</p>
<p>我们知道，接下来会使用new出来的这个LoadedApk的getClassLoader()方法获取到ClassLoader来对插件的类进行加载；而获取到的这个ClassLoader是宿主程序使用的ClassLoader，因此现在还无法加载插件的类；那么，<strong>我们能不能让宿主的ClasLoader获得加载插件类的能力呢？</strong>；如果我们告诉宿主使用的ClassLoader插件使用的类在哪里，就能帮助他完成加载！</p>
<h3 id="宿主的ClassLoader在哪里，是唯一的吗？"><a href="#宿主的ClassLoader在哪里，是唯一的吗？" class="headerlink" title="宿主的ClassLoader在哪里，是唯一的吗？"></a>宿主的ClassLoader在哪里，是唯一的吗？</h3><p>上面说到，我们可以通过告诉宿主程序的ClassLoader插件使用的类，让宿主的ClasLoader完成对于插件类的加载；那么问题来了，我们如何获取到宿主的ClassLoader？宿主程序使用的ClasLoader默认情况下是全局唯一的吗？</p>
<p>答案是肯定的。</p>
<p>因为在FrameWork中宿主程序也是使用LoadedApk表示的，如同Activity启动是加载Activity类一样，宿主中的类也都是通过LoadedApk的getClassLoader()方法得到的ClassLoader加载的；由类加载机制的『双亲委派』特性，只要有一个应用程序类由某一个ClassLoader加载，那么它引用到的别的类除非父加载器能加载，否则都是由这同一个加载器加载的（不遵循双亲委派模型的除外）。</p>
<p>表示宿主的LoadedApk在Application类中有一个成员变量<code>mLoadedApk</code>，而这个变量是从ContextImpl中获取的；ContextImpl重写了getClassLoader方法，因此<strong>我们在Context环境中直接getClassLoader()获取到的就是宿主程序唯一的ClassLoader</strong>。</p>
<h3 id="LoadedApk的ClassLoader到底是什么？"><a href="#LoadedApk的ClassLoader到底是什么？" class="headerlink" title="LoadedApk的ClassLoader到底是什么？"></a>LoadedApk的ClassLoader到底是什么？</h3><p>现在我们确保了『使用宿主ClassLoader帮助加载插件类』可行性；那么我们应该如何完成这个过程呢？</p>
<p>知己知彼，百战不殆。</p>
<p>不论是宿主程序还是插件程序都是通过LoadedApk的getClassLoader()方法返回的ClassLoader进行类加载的，返回的这个ClassLoader到底是个什么东西？？这个方法源码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public ClassLoader getClassLoader() &#123;  </span><br><span class="line"> synchronized (this) &#123;  </span><br><span class="line"> if (mClassLoader !&#x3D; null) &#123;  </span><br><span class="line"> return mClassLoader;  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line"> if (mIncludeCode &amp;&amp; !mPackageName.equals(&quot;android&quot;)) &#123;  </span><br><span class="line"> &#x2F;&#x2F; 略...  </span><br><span class="line"> mClassLoader &#x3D; ApplicationLoaders.getDefault().getClassLoader(zip, lib,  </span><br><span class="line"> mBaseClassLoader);  </span><br><span class="line">  </span><br><span class="line"> StrictMode.setThreadPolicy(oldPolicy);  </span><br><span class="line"> &#125; else &#123;  </span><br><span class="line"> if (mBaseClassLoader &#x3D;&#x3D; null) &#123;  </span><br><span class="line"> mClassLoader &#x3D; ClassLoader.getSystemClassLoader();  </span><br><span class="line"> &#125; else &#123;  </span><br><span class="line"> mClassLoader &#x3D; mBaseClassLoader;  </span><br><span class="line"> &#125;  </span><br><span class="line"> &#125;  </span><br><span class="line"> return mClassLoader;  </span><br><span class="line"> &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，非<code>android</code>开头的包和<code>android</code>开头的包分别使用了两种不同的ClassLoader，我们只关心第一种；因此继续跟踪ApplicationLoaders类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public ClassLoader getClassLoader(String zip, String libPath, ClassLoader parent)  </span><br><span class="line">&#123;  </span><br><span class="line">  </span><br><span class="line"> ClassLoader baseParent &#x3D; ClassLoader.getSystemClassLoader().getParent();  </span><br><span class="line">  </span><br><span class="line"> synchronized (mLoaders) &#123;  </span><br><span class="line"> if (parent &#x3D;&#x3D; null) &#123;  </span><br><span class="line"> parent &#x3D; baseParent;  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line"> if (parent &#x3D;&#x3D; baseParent) &#123;  </span><br><span class="line"> ClassLoader loader &#x3D; mLoaders.get(zip);  </span><br><span class="line"> if (loader !&#x3D; null) &#123;  </span><br><span class="line"> return loader;  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line"> Trace.traceBegin(Trace.TRACE\_TAG\_ACTIVITY_MANAGER, zip);  </span><br><span class="line"> PathClassLoader pathClassloader &#x3D;  </span><br><span class="line"> new PathClassLoader(zip, libPath, parent);  </span><br><span class="line"> Trace.traceEnd(Trace.TRACE\_TAG\_ACTIVITY_MANAGER);  </span><br><span class="line">  </span><br><span class="line"> mLoaders.put(zip, pathClassloader);  </span><br><span class="line"> return pathClassloader;  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line"> Trace.traceBegin(Trace.TRACE\_TAG\_ACTIVITY_MANAGER, zip);  </span><br><span class="line"> PathClassLoader pathClassloader &#x3D; new PathClassLoader(zip, parent);  </span><br><span class="line"> Trace.traceEnd(Trace.TRACE\_TAG\_ACTIVITY_MANAGER);  </span><br><span class="line"> return pathClassloader;  </span><br><span class="line"> &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，应用程序使用的ClassLoader都是PathClassLoader类的实例。那么，这个PathClassLoader是什么呢？从Android SDK给出的源码只能看出这么多：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class PathClassLoader extends BaseDexClassLoader &#123;  </span><br><span class="line"> public PathClassLoader(String dexPath, ClassLoader parent) &#123;  </span><br><span class="line"> super((String)null, (File)null, (String)null, (ClassLoader)null);  </span><br><span class="line"> throw new RuntimeException(&quot;Stub!&quot;);  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line"> public PathClassLoader(String dexPath, String libraryPath, ClassLoader parent) &#123;  </span><br><span class="line"> super((String)null, (File)null, (String)null, (ClassLoader)null);  </span><br><span class="line"> throw new RuntimeException(&quot;Stub!&quot;);  </span><br><span class="line"> &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>SDK没有导出这个类的源码，我们去<a href="http://androidxref.com/6.0.1_r10/xref/libcore/dalvik/src/main/java/dalvik/system/PathClassLoader.java" target="_blank" rel="noopener">androidxref</a>上面看；发现其实这个类真的就这么多内容；我们继续查看它的父类<a href="http://androidxref.com/6.0.1_r10/xref/libcore/dalvik/src/main/java/dalvik/system/BaseDexClassLoader.java" target="_blank" rel="noopener">BaseDexClassLoader</a>；ClassLoader嘛，我们查看findClass或者defineClass方法，BaseDexClassLoader的findClass方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123;  </span><br><span class="line"> List&lt;Throwable&gt; suppressedExceptions &#x3D; new ArrayList&lt;Throwable&gt;();  </span><br><span class="line"> Class c &#x3D; pathList.findClass(name, suppressedExceptions);  </span><br><span class="line"> if (c &#x3D;&#x3D; null) &#123;  </span><br><span class="line"> ClassNotFoundException cnfe &#x3D; new ClassNotFoundException(&quot;Didn&#39;t find class \\&quot;&quot; \+ name + &quot;\\&quot; on path: &quot; \+ pathList);  </span><br><span class="line"> for (Throwable t : suppressedExceptions) &#123;  </span><br><span class="line"> cnfe.addSuppressed(t);  </span><br><span class="line"> &#125;  </span><br><span class="line"> throw cnfe;  </span><br><span class="line"> &#125;  </span><br><span class="line"> return c;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，查找Class的任务通过<code>pathList</code>完成；这个<code>pathList</code>是一个<code>DexPathList</code>类的对象，它的<code>findClass</code>方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public Class findClass(String name, List&lt;Throwable&gt; suppressed) &#123;  </span><br><span class="line"> for (Element element : dexElements) &#123;  </span><br><span class="line"> DexFile dex &#x3D; element.dexFile;  </span><br><span class="line">  </span><br><span class="line"> if (dex !&#x3D; null) &#123;  </span><br><span class="line"> Class clazz &#x3D; dex.loadClassBinaryName(name, definingContext, suppressed);  </span><br><span class="line"> if (clazz !&#x3D; null) &#123;  </span><br><span class="line"> return clazz;  </span><br><span class="line"> &#125;  </span><br><span class="line"> &#125;  </span><br><span class="line"> &#125;  </span><br><span class="line"> if (dexElementsSuppressedExceptions !&#x3D; null) &#123;  </span><br><span class="line"> suppressed.addAll(Arrays.asList(dexElementsSuppressedExceptions));  </span><br><span class="line"> &#125;  </span><br><span class="line"> return null;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个DexPathList内部有一个叫做dexElements的数组，然后findClass的时候会遍历这个数组来查找Class；<strong>如果我们把插件的信息塞进这个数组里面，那么不就能够完成类的加载过程吗？！！</strong></p>
<h3 id="给默认ClassLoader打补丁"><a href="#给默认ClassLoader打补丁" class="headerlink" title="给默认ClassLoader打补丁"></a>给默认ClassLoader打补丁</h3><p>通过上述分析，我们知道，可以把插件的相关信息放入BaseDexClassLoader的表示dex文件的数组里面，这样宿主程序的ClassLoader在进行类加载，遍历这个数组的时候，会自动遍历到我们添加进去的插件信息，从而完成插件类的加载！</p>
<p>接下来，我们实现这个过程；我们会用到一些较为复杂的反射技术哦～不过代码非常短：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public static void patchClassLoader(ClassLoader cl, File apkFile, File optDexFile)  </span><br><span class="line"> throws IllegalAccessException, NoSuchMethodException, IOException, InvocationTargetException, InstantiationException, NoSuchFieldException &#123;  </span><br><span class="line"> &#x2F;&#x2F; 获取 BaseDexClassLoader : pathList  </span><br><span class="line"> Field pathListField &#x3D; DexClassLoader.class.getSuperclass().getDeclaredField(&quot;pathList&quot;);  </span><br><span class="line"> pathListField.setAccessible(true);  </span><br><span class="line"> Object pathListObj &#x3D; pathListField.get(cl);  </span><br><span class="line">  </span><br><span class="line"> &#x2F;&#x2F; 获取 PathList: Element\[\] dexElements  </span><br><span class="line"> Field dexElementArray &#x3D; pathListObj.getClass().getDeclaredField(&quot;dexElements&quot;);  </span><br><span class="line"> dexElementArray.setAccessible(true);  </span><br><span class="line"> Object\[\] dexElements &#x3D; (Object\[\]) dexElementArray.get(pathListObj);  </span><br><span class="line">  </span><br><span class="line"> &#x2F;&#x2F; Element 类型  </span><br><span class="line"> Class&lt;?&gt; elementClass &#x3D; dexElements.getClass().getComponentType();  </span><br><span class="line">  </span><br><span class="line"> &#x2F;&#x2F; 创建一个数组, 用来替换原始的数组  </span><br><span class="line"> Object\[\] newElements &#x3D; (Object\[\]) Array.newInstance(elementClass, dexElements.length + 1);  </span><br><span class="line">  </span><br><span class="line"> &#x2F;&#x2F; 构造插件Element(File file, boolean isDirectory, File zip, DexFile dexFile) 这个构造函数  </span><br><span class="line"> Constructor&lt;?&gt; constructor &#x3D; elementClass.getConstructor(File.class, boolean.class, File.class, DexFile.class);  </span><br><span class="line"> Object o &#x3D; constructor.newInstance(apkFile, false, apkFile, DexFile.loadDex(apkFile.getCanonicalPath(), optDexFile.getAbsolutePath(), 0));  </span><br><span class="line">  </span><br><span class="line"> Object\[\] toAddElementArray &#x3D; new Object\[\] &#123; o &#125;;  </span><br><span class="line"> &#x2F;&#x2F; 把原始的elements复制进去  </span><br><span class="line"> System.arraycopy(dexElements, 0, newElements, 0, dexElements.length);  </span><br><span class="line"> &#x2F;&#x2F; 插件的那个element复制进去  </span><br><span class="line"> System.arraycopy(toAddElementArray, 0, newElements, dexElements.length, toAddElementArray.length);  </span><br><span class="line">  </span><br><span class="line"> &#x2F;&#x2F; 替换  </span><br><span class="line"> dexElementArray.set(pathListObj, newElements);  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>短短的二十几行代码，我们就完成了『委托宿主ClassLoader加载插件类』的任务；因此第二种方案也宣告完成！我们简要总结一下这种方式的原理：</p>
<ol>
<li>默认情况下performLacunchActivity会使用替身StubActivity的ApplicationInfo也就是宿主程序的CLassLoader加载所有的类；我们的思路是告诉宿主ClassLoader我们在哪，让其帮助完成类加载的过程。</li>
<li>宿主程序的ClassLoader最终继承自BaseDexClassLoader，BaseDexClassLoader通过DexPathList进行类的查找过程；而这个查找通过遍历一个dexElements的数组完成；<strong>我们通过把插件dex添加进这个数组</strong>就让宿主ClasLoader获取了加载插件类的能力。</li>
</ol>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文中我们采用两种方案成功完成了『启动没有在AndroidManifest.xml中显示声明，并且存在于外部插件中的Activity』的任务。</p>
<p>『激进方案』中我们自定义了插件的ClassLoader，并且绕开了Framework的检测；利用ActivityThread对于LoadedApk的缓存机制，我们把携带这个自定义的ClassLoader的插件信息添加进<code>mPackages</code>中，进而完成了类的加载过程。</p>
<p>『保守方案』中我们深入探究了系统使用ClassLoader findClass的过程，发现应用程序使用的非系统类都是通过同一个PathClassLoader加载的；而这个类的最终父类BaseDexClassLoader通过DexPathList完成类的查找过程；我们hack了这个查找过程，从而完成了插件类的加载。</p>
<p>这两种方案孰优孰劣呢？</p>
<p>很显然，『激进方案』比较麻烦，从代码量和分析过程就可以看出来，这种机制异常复杂；而且在解析apk的时候我们使用的PackageParser的兼容性非常差，我们不得不手动处理每一个版本的apk解析api；另外，它Hook的地方也有点多：不仅需要Hook AMS和<code>H</code>，还需要Hook ActivityThread的<code>mPackages</code>和PackageManager！</p>
<p>『保守方案』则简单得多（虽然原理也不简单），不仅代码很少，而且Hook的地方也不多；有一点正本清源的意思，从最最上层Hook住了整个类的加载过程。</p>
<p>但是，我们不能简单地说『保守方案』比『激进方案』好。从根本上说，这两种方案的差异在哪呢？</p>
<p>『激进方案』是<strong>多ClassLoader构架</strong>，每一个插件都有一个自己的ClassLoader，因此类的隔离性非常好——如果不同的插件使用了同一个库的不同版本，它们相安无事！『保守方案』是<strong>单ClassLoader方案</strong>，插件和宿主程序的类全部都通过宿主的ClasLoader加载，虽然代码简单，但是鲁棒性很差；一旦插件之间甚至插件与宿主之间使用的类库有冲突，那么直接GG。</p>
<p>多ClassLoader还有一个优点：可以真正完成代码的热加载！如果插件需要升级，直接重新创建一个自定的ClassLoader加载新的插件，然后替换掉原来的版本即可（Java中，不同ClassLoader加载的同一个类被认为是不同的类）；单ClassLoader的话实现非常麻烦，有可能需要重启进程。</p>
<p>在J2EE领域中广泛使用ClasLoader的地方均采用多ClassLoader架构，比如Tomcat服务器，Java模块化事实标准的OSGi技术；所以，我们有足够的理由认为<strong>选择多ClassLoader架构在大多数情况下是明智之举</strong>。</p>
<p>目前开源的插件方案中，DroidPlugin采用的『激进方案』，Small采用的『保守方案』那么，有没有两种优点兼顾的方案呢？？</p>
<p>答案自然是有的。</p>
<p>DroidPlugin和Small的共同点是<strong>两者都是非侵入式的插件框架</strong>；什么是『非侵入式』呢？打个比方，你启动一个插件Activity，直接使用<code>startActivity</code>即可，就跟开发普通的apk一样，开发插件和普通的程序对于开发者来说没有什么区别。</p>
<p>如果我们一定程度上放弃这种『侵入性』，那么我们就能实现一个两者优点兼而有之的插件框架！这里我先卖个关子～</p>
<p>OK，本文的内容就到这里了；关于『插件机制对于Activity的处理方式』也就此完结。要说明的是，在本文的『保守方案』其实只处理了代码的加载过程，它并不能加载有资源的apk！所以目前我这个实现基本没什么暖用；当然我这里只是就『代码加载』进行举例；至于资源，那牵扯到另外一个问题——<strong>插件系统的资源管理机制</strong>这个在后续文章的合适机会我会单独讲解。</p>
<p>接下来的文章，会讲述Android四大组件的另外三个<code>Service</code>，<code>BroadCastReceiver</code>, <code>ContentProvider</code>的处理方式。喜欢就点个赞吧～持续更新，请关注github项目 <a href="https://github.com/tiann/understand-plugin-framework" target="_blank" rel="noopener">understand-plugin-framework</a>和我的 <a href="http://weishu.me" target="_blank" rel="noopener">博客</a>! 这文章我前前后后准备了快两个星期，如果你看到了这里，还请支持一下 :)</p>
<p><a href="/tags/android/">#android</a> <a href="/tags/binder/">#binder</a> <a href="/tags/classloader/">#classloader</a> <a href="/tags/droidplugin/">#droidplugin</a> <a href="/tags/plugin-framework/">#plugin framework</a></p>
<p><a href="/2016/04/12/understand-plugin-framework-receiver/">Android插件化原理解析——广播的管理</a></p>
<p><a href="/2016/03/21/understand-plugin-framework-activity-management/">Android 插件化原理解析——Activity生命周期管理</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">reoger</p>
  <div class="site-description" itemprop="description">reoger</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">63</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">51</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/reoger" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;reoger" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:reoger112@gmail.com" title="E-Mail → mailto:reoger112@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2018 – 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">reoger</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
