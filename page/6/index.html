<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"reoger.tk","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="reoger">
<meta property="og:type" content="website">
<meta property="og:title" content="reoger的记录">
<meta property="og:url" content="http://reoger.tk/page/6/index.html">
<meta property="og:site_name" content="reoger的记录">
<meta property="og:description" content="reoger">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="reoger">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://reoger.tk/page/6/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>reoger的记录</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">reoger的记录</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">--以后的你会感激现在那么努力的自己</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>日程表</a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>公益 404</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://reoger.tk/2017/10/24/backEnd/hdfs%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="reoger">
      <meta itemprop="description" content="reoger">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="reoger的记录">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/10/24/backEnd/hdfs%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/" class="post-title-link" itemprop="url">hdfs基本操作</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-10-24 09:42:01" itemprop="dateCreated datePublished" datetime="2017-10-24T09:42:01+08:00">2017-10-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-07-18 13:40:51" itemprop="dateModified" datetime="2020-07-18T13:40:51+08:00">2020-07-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/backEnd/" itemprop="url" rel="index"><span itemprop="name">backEnd</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>HDFS（Hadoop Distributed File System）是Hadoop分布式计算中的数据存储系统，是基于流数据模式访问和处理超大文件的需求而开发的。</p>
</blockquote>
<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>下面介绍几个hdfs文件系统中几个常见的概念：</p>
<ol>
<li>Block<br>HDFS中的存储单元是每个数据块block，HDFS默认的最基本的存储单位是64M的数据块。</li>
<li>NameNode<br>元数据节点，该节点用来管理文件系统中的命名空间。</li>
<li>DataNode<br>数据节点，是HDFS真正存储数据的地方。</li>
<li>Secondary NameNode<br>从元数据节点，从元数据节点并不是NameNode出现问题时候的备用节点，它的主要功能是周期性的将NameNode中的namespace image和edit log合并，以防log文件过大。</li>
<li>edit log<br>修改日志，用于记录hdfs中文件的相关操作日志。</li>
</ol>
<h1 id="命令操作"><a href="#命令操作" class="headerlink" title="命令操作"></a>命令操作</h1><p>我们可以通过hadoop命令来实现文件的基本操作，包括添创建、删除目录，上传下载文件操作。</p>
<h2 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h2><p> 我们可以通过下面的命令来创建一个input目录。<br> <code>hadoop fs -mkdir hdfs://localhost:9000/input</code><br> 这里的<code>hdfs://localhost:9000</code>表示的是本地的hdfs系统，如果是本地的hdsf系统，我们其实可以省略，我们上面的命令可以简写成：<br> <code>hadoop fs -mkdir /input</code><br>当然，如果是远程的hadfs系统，我们就需要标注hdfs地址了，例如<code>hdfs://http://172.22.66.245:9099</code>，想知道hdfs开放的是那个端口，直接直接访问<code>http://localhost:50070/dfshealth.html#tab-overview</code>查看开放端口。<br>综上，我们在远程hdfs系统上创建的一个名为input目录的命令如下：<br><code>hadoop fs -mkdir hdfs://172.22.66.245:9090/input</code></p>
<h2 id="上传文件"><a href="#上传文件" class="headerlink" title="上传文件"></a>上传文件</h2><p>上传文件的也很简单，基本的格式为<code>hadoop fs -put localFile hdfsFileDir</code><br>其中的<code>localFile</code>代表要上传的文件，<code>hdfsFileDir</code>代表要上传的到hdfs文件系统的目录。<br>例如，我要将D盘根目录下的keseh.txt上传到hdsf文件系统的<code>input</code>目录下，完整的命令如下：<br><code>hadoop fs -put D:\keshe.txt hdfs://localhost:9000/input</code><br>当然，因为是本地的hdfs系统，故hdfs可以省略，即可以简写成：<br><code>hadoop fs -put D:\keshe.txt /input</code><br>当然远程hdfs系统，这个hdfs就不能省略了，示例命令如下：<br><code>hadoop fs -put D:\keshe.txt hdfs://172.22.66.245:9090/input</code></p>
<h2 id="下载文件"><a href="#下载文件" class="headerlink" title="下载文件"></a>下载文件</h2><p>下载文件的基本格式为<code>hadoop fs -get hdfsFile localFileDir</code>，其中的<code>hdfsFile</code>表示的是hdfs系统中的文件，<code>localFileDir</code>表示要下载的到本地的目录。<br>这里就直接给出示例命令了.<br>从本地的hadfs系统获取，<code>hadoop fs -get hdfs://localhost:9000/input/keshe.txt F:\</code></p>
<p>远程的hdfs系统获取：<code>hadoop fs -get hdfs://172.22.66.245:9090/input/keshe.txt F:\</code></p>
<h2 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h2><p>删除文件的格式为<code>hadoop fs -rm hdfsFile</code>或者是<code>hadoop fs -rm -r hdfsFile</code>。<br>每次可以删除多个文件或者目录。例如，删除远程hdfs文件的命令为：<br><code>hadoop fs -rm  hdfs://172.22.66.245:9090/input/keshe.txt</code></p>
<h2 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h2><p>以上的操作都比较简单，在简单记录一下hadoop中的基本命令。</p>
<table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">格式</th>
<th>作用</th>
<th>实例</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ls</td>
<td align="center">hadoop fs -ls /&lt; hdfs dir&gt;</td>
<td>列出hadfs文件系统中某个目录下的文件</td>
<td>hadoop fs -ls hdfs://localhost:9000/input</td>
</tr>
<tr>
<td align="center">put</td>
<td align="center">hadoop fs -put &lt; local file &gt; &lt; hdfs dir &gt;</td>
<td>上传文件或者目录到hdfs系统中指定目录中</td>
<td>hadoop fs -put D:\keshe.txt hdfs://localhost:9000/input</td>
</tr>
<tr>
<td align="center">get</td>
<td align="center">hadoop fs -get &lt; hdfs file &gt; &lt; local file or dir&gt;</td>
<td>下载hdfs文件系统中的文件或者目录</td>
<td>hadoop fs -get hdfsFile localFileDir</td>
</tr>
<tr>
<td align="center">moveFromLocal</td>
<td align="center">hadoop fs -moveFromLocal  &lt; local src &gt; … &lt; hdfs dst &gt;</td>
<td>类似于将本地文件剪切到hdfs文件系统中</td>
<td>hadoop fs -moveFromLocal D:\keshe.txt   hdfs://localhost:9000/input</td>
</tr>
<tr>
<td align="center">copyFromLocal</td>
<td align="center">hadoop fs -copyFromLocal  &lt; local src &gt; … &lt; hdfs dst &gt;</td>
<td>类似于将文件从本地复制到hdfs文件系统中</td>
<td>hadoop fs -copyFromLocal D:\keshe.txt   hdfs://localhost:9000/input</td>
</tr>
<tr>
<td align="center">mkdir</td>
<td align="center">hadoop fs -mkdir &lt; hdfs path&gt;</td>
<td>在hdfs文件系统中创建目录</td>
<td>hadoop fs -mkdir hdfs://localhost:9000/input</td>
</tr>
<tr>
<td align="center">rm</td>
<td align="center">hadoop fs -rm &lt; hdfs file &gt; …</td>
<td>删除hdfs文件目录中的文件</td>
<td>hadoop fs -rm  hdfs://localhost:9000/input/keshe.txt</td>
</tr>
<tr>
<td align="center">cp</td>
<td align="center">hadoop fs -cp  &lt; hdfs file &gt;  &lt; hdfs file &gt;</td>
<td>复制hdfs文件或者福文件夹</td>
<td>hadoop fs -cp   hdfs://localhost:9000/input/keshe.txt   hdfs://localhost:9000/input/user</td>
</tr>
<tr>
<td align="center">mv</td>
<td align="center">hadoop fs -mv &lt; hdfs file &gt;  &lt; hdfs file &gt;</td>
<td>移动文件，也可以当着重命名来使用</td>
<td>hadoop fs -cp  hdfs://localhost:9000/input/keshe.txt  hdfs://localhost:9000/haha.txt</td>
</tr>
<tr>
<td align="center">count</td>
<td align="center">hadoop fs -count &lt; hdfs path &gt;</td>
<td>统计hdfs对应路径下的相关信息,显示为目录个数，文件个数，文件总计大小，输入路径</td>
<td>hadoop fs -count  hdfs://localhost:9000/input</td>
</tr>
<tr>
<td align="center">du</td>
<td align="center">hadoop fs -du &lt; hdsf path&gt;</td>
<td>显示hdfs对应路径下每个文件夹和文件的大小</td>
<td>hadoop fs -du  hdfs://localhost:9000/input</td>
</tr>
<tr>
<td align="center">text</td>
<td align="center">hadoop fs -text &lt; hdsf file&gt;</td>
<td>将文本文件或某些格式的非文本文件通过文本格式输出</td>
<td>hadoop fs -text  hdfs://localhost:9000/input/haha.txt</td>
</tr>
</tbody></table>
<p>暂时先记录这么多了，下面我们用代码实现基本的文件操作。</p>
<h1 id="用代码实现"><a href="#用代码实现" class="headerlink" title="用代码实现"></a>用代码实现</h1><p>在真是实现之前，是需要我们提前好代码开发环境的，至于如何搭建，参照前面上一篇博客，这里不再展开。</p>
<h2 id="查看所有目录下的文件"><a href="#查看所有目录下的文件" class="headerlink" title="查看所有目录下的文件"></a>查看所有目录下的文件</h2><p>我们先来看如何查看hdfs文件指定目录下所有的文件信息，即相当于ls命令的。<br>下面就是主要实现，我们住需要在main方法中调用就可以打印出hdfs文件系统中input目录下所有的文件和目录信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">private static void  ListItem()&#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        Configuration config &#x3D; new Configuration();</span><br><span class="line">        Path dfs &#x3D; new Path(&quot;hdfs:&#x2F;&#x2F;172.22.66.245:9090&#x2F;input&quot;);</span><br><span class="line">        FileSystem fileSystem &#x3D; dfs.getFileSystem(config);</span><br><span class="line">        FileStatus[] status &#x3D; fileSystem.listStatus(dfs);</span><br><span class="line">        for (int i &#x3D; 0; i &lt; status.length; i++) &#123;</span><br><span class="line">            System.out.println(status[i].getPath().toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="上传文件-1"><a href="#上传文件-1" class="headerlink" title="上传文件"></a>上传文件</h2><p>代码很简单，直接上代码了,upFile方法实现了将本地D盘根目录下的2017-09-25_093127.jpg图片上传到hdfs文件系统中的input文件夹下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private static void upFile()&#123;</span><br><span class="line">    try&#123;</span><br><span class="line">        Configuration conf &#x3D; new Configuration();</span><br><span class="line">        Path path &#x3D; new Path(&quot;hdfs:&#x2F;&#x2F;172.22.66.245:9090&#x2F;input&quot;);</span><br><span class="line">        Path localPath &#x3D; new Path(&quot;D:\\2017-09-25_093127.jpg&quot;);</span><br><span class="line">        FileSystem fs &#x3D; path.getFileSystem(conf);</span><br><span class="line">        fs.copyFromLocalFile(localPath,path);</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="下载文件-1"><a href="#下载文件-1" class="headerlink" title="下载文件"></a>下载文件</h2><p>下载文件比较坑的一点就是，我们需要先创建一个这样的文件，然后以流的形式传入到填充到这个文件中去，例如下面的示例代码就是将hdfs文件系统中的haha.txt文件的内容写到D盘根目录下的hello.txt文件中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">private static void downFile()&#123;</span><br><span class="line">        try&#123;</span><br><span class="line">            Configuration conf &#x3D; new Configuration();</span><br><span class="line">            Path path &#x3D; new Path(&quot;hdfs:&#x2F;&#x2F;172.22.66.245:9090&#x2F;input&#x2F;haha.txt&quot;);</span><br><span class="line">            FileSystem fs &#x3D; path.getFileSystem(conf);</span><br><span class="line">            FSDataInputStream open &#x3D; fs.open(path);</span><br><span class="line">            OutputStream output &#x3D; new FileOutputStream(&quot;D:&#x2F;&#x2F;hello.txt&quot;);</span><br><span class="line">            IOUtils.copyBytes(open,output,4096,true);</span><br><span class="line"></span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol>
<li><a href="https://segmentfault.com/a/1190000002672666" target="_blank" rel="noopener">hadoop HDFS常用文件操作命令</a></li>
<li><a href="http://blog.csdn.net/zh521zh/article/details/51784450" target="_blank" rel="noopener">HDFS中的基础概念</a></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://reoger.tk/2017/10/23/backEnd/intellij-IDEA-%E9%85%8D%E7%BD%AEhadoop%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="reoger">
      <meta itemprop="description" content="reoger">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="reoger的记录">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/10/23/backEnd/intellij-IDEA-%E9%85%8D%E7%BD%AEhadoop%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/" class="post-title-link" itemprop="url">intellij IDEA 配置hadoop开发环境</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-10-23 15:10:25" itemprop="dateCreated datePublished" datetime="2017-10-23T15:10:25+08:00">2017-10-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-07-18 13:40:59" itemprop="dateModified" datetime="2020-07-18T13:40:59+08:00">2020-07-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/backEnd/" itemprop="url" rel="index"><span itemprop="name">backEnd</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>在参考了众多的参考资料之后，终于搭建搭建起了了intellij-IDEA开发hadoop环境，下面就记录一下开发环境的建立过程，以免日后遗忘。</p>
</blockquote>
<h1 id="开发工具和基础环境准备"><a href="#开发工具和基础环境准备" class="headerlink" title="开发工具和基础环境准备"></a>开发工具和基础环境准备</h1><p>首先，本次采用的开发工具选用的是intellij-IDEA，在进行本次开发之前需要将intellij-IDEA下载并安装好，并配置好java的JDK。下面是我本次配置开发环境之前的基础环境，本次采用的是hadoop 2.6.0的版本。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">IntelliJ IDEA 2017.2.4</span><br><span class="line">Build #IC-172.4155.36, built on September 12, 2017</span><br><span class="line">JRE: 1.8.0_152-release-915-b11 amd64</span><br><span class="line">JVM: OpenJDK 64-Bit Server VM by JetBrains s.r.o</span><br><span class="line">Windows 10 10.0</span><br></pre></td></tr></table></figure>
<p>在下载好hadoop之后，我们便可以开始本次环境的配置了。</p>
<h1 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h1><p>这一步非常的简单，我们用IDEA创建一下普通的java项目即可。</p>
<p><img src="http://ovec6nnof.bkt.clouddn.com/%E6%96%B0%E5%BB%BA%E9%A1%B9%E7%9B%AE.jpg" alt=""><br>创建项目完成之后是这个样子的。<br><img src="http://ovec6nnof.bkt.clouddn.com/%E5%88%9B%E5%BB%BA%E5%AE%8C%E6%88%90.jpg" alt=""></p>
<h1 id="添加示例代码"><a href="#添加示例代码" class="headerlink" title="添加示例代码"></a>添加示例代码</h1><p>我们先不管三七二十一，在我们的项目中，先copy下面三个类，用来检测环境是否搭建好。<br>第一个类<code>WordCountMapper</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import org.apache.hadoop.io.IntWritable;</span><br><span class="line">import org.apache.hadoop.io.LongWritable;</span><br><span class="line">import org.apache.hadoop.io.Text;</span><br><span class="line">import org.apache.hadoop.mapreduce.Mapper;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.util.StringTokenizer;</span><br><span class="line"></span><br><span class="line">public class WordCountMapper  extends Mapper&lt;LongWritable,Text,Text,IntWritable&gt; &#123;</span><br><span class="line">    private final static IntWritable one &#x3D; new IntWritable(1);</span><br><span class="line">    private Text word &#x3D; new Text();</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void map(LongWritable key, Text value, Context context) throws IOException, InterruptedException &#123;</span><br><span class="line">        StringTokenizer itr &#x3D; new StringTokenizer(value.toString());</span><br><span class="line">        while (itr.hasMoreTokens())&#123;</span><br><span class="line">            word.set(itr.nextToken());</span><br><span class="line">            context.write(word,one);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二个类:<code>WordCountReducer</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import org.apache.hadoop.io.IntWritable;</span><br><span class="line"></span><br><span class="line">import org.apache.hadoop.io.Text;</span><br><span class="line">import org.apache.hadoop.mapreduce.Reducer;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class WordCountReducer extends Reducer&lt;Text,IntWritable,Text,IntWritable&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private IntWritable result &#x3D; new IntWritable();</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void reduce(Text key, Iterable&lt;IntWritable&gt; values, Context context) throws IOException, InterruptedException &#123;</span><br><span class="line">        int sum &#x3D; 0;</span><br><span class="line">        for(IntWritable val:values)&#123;</span><br><span class="line">            sum +&#x3D; val.get();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        result.set(sum);</span><br><span class="line">        context.write(key,result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第三个测试类：<code>test</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">import org.apache.hadoop.conf.Configuration;</span><br><span class="line">import org.apache.hadoop.fs.Path;</span><br><span class="line">import org.apache.hadoop.io.IntWritable;</span><br><span class="line">import org.apache.hadoop.io.Text;</span><br><span class="line">import org.apache.hadoop.mapreduce.Job;</span><br><span class="line">import org.apache.hadoop.mapreduce.lib.input.FileInputFormat;</span><br><span class="line">import org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;</span><br><span class="line">import org.apache.log4j.chainsaw.Main;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">public class test &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException, ClassNotFoundException, InterruptedException &#123;</span><br><span class="line">        &#x2F;&#x2F; write your code here</span><br><span class="line"></span><br><span class="line">        Configuration configuration &#x3D; new Configuration();</span><br><span class="line"></span><br><span class="line">        if(args.length!&#x3D;2)&#123;</span><br><span class="line">            System.err.println(&quot;Usage:wordcount &lt;input&gt;&lt;output&gt;&quot;);</span><br><span class="line">            System.exit(2);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Job job &#x3D; new Job(configuration,&quot;word count&quot;);</span><br><span class="line"></span><br><span class="line">        job.setJarByClass(Main.class);</span><br><span class="line">        job.setMapperClass(WordCountMapper.class);</span><br><span class="line">        job.setReducerClass(WordCountReducer.class);</span><br><span class="line">        job.setOutputKeyClass(Text.class);</span><br><span class="line">        job.setOutputValueClass(IntWritable.class);</span><br><span class="line">        FileInputFormat.addInputPath(job,new Path(args[0]));</span><br><span class="line">        FileOutputFormat.setOutputPath(job,new Path(args[1]));</span><br><span class="line"></span><br><span class="line">        System.exit(job.waitForCompletion(true)?0:1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>把代码copy完成之后，项目结构应该是这样子的：<br><img src="http://ovec6nnof.bkt.clouddn.com/%E5%A4%8D%E5%88%B6%E4%BB%A3%E7%A0%81%E5%AE%8C%E6%88%90.jpg" alt=""></p>
<p>可以看到，ide提示我们代码还有错，这是因为我们环境还没有搭建完成，所以报错，我们接下来继续下一步。</p>
<h1 id="导入hadoop相关的jar包"><a href="#导入hadoop相关的jar包" class="headerlink" title="导入hadoop相关的jar包"></a>导入hadoop相关的jar包</h1><p>我们首先需要知道我们要导入的jar包的具体位置： <code>\hadoop-2.6.0\share\hadoop</code>，即在hadoop根目录下的share文件夹中的hadoop文件夹中。<br>然后在IDEA中打开project Structure选项，快捷键<code>ctrl+alt+shift+S</code>。选择modules，如图：<br><img src="http://ovec6nnof.bkt.clouddn.com/%E9%80%89%E6%8B%A9modules.jpg" alt=""></p>
<p>选择右边的加号-&gt; jars 如图：</br><br><img src="http://ovec6nnof.bkt.clouddn.com/%E6%B7%BB%E5%8A%A0jar.jpg" alt=""></p>
<p>选择hadoop的jar，具体位置我们前面已经说过了，将hadoop文件夹中所有的文件都选中，按住shift即可多选：<br><img src="" alt=""><br>jar导入完成之后，应该是这个样子的：<br><img src="http://ovec6nnof.bkt.clouddn.com/jar%E5%AF%BC%E5%85%A5%E5%AE%8C%E6%88%90.jpg" alt=""></p>
<p>然后在Project Settings中选择Artifacts，如图：<br><img src="http://ovec6nnof.bkt.clouddn.com/%E9%80%89%E6%8B%A9Artifacts.jpg" alt=""><br>选择加号-&gt;JAR -&gt; Emptry创建一个空的jar。选择完成后如图：</p>
<p><img src="http://ovec6nnof.bkt.clouddn.com/%E5%88%9B%E5%BB%BA%E6%96%B0%E7%9A%84jar.jpg" alt=""><br>我们将其取名为<code>hadoop</code>,并选择output Layout下面的加号-&gt;Module Output，并勾选include in prokecy builde,完成后如图所示：</p>
<p><img src="http://ovec6nnof.bkt.clouddn.com/%E5%88%9B%E5%BB%BAjar%E5%AE%8C%E6%88%90.jpg" alt=""></p>
<p>完成上面的操作后，发现我们前面copy的代码已经不在报错了，说明jar包已经成功导入到我们的项目中来了。最后我们需要配置我们的运行环境。</p>
<h1 id="配置运行环境"><a href="#配置运行环境" class="headerlink" title="配置运行环境"></a>配置运行环境</h1><p>首先选择edit Configurtions,如图；<br><img src="http://ovec6nnof.bkt.clouddn.com/%E9%80%89%E6%8B%A9edit%20Configuratiobns.jpg" alt=""><br>新建application，具体做法，点击右上角的加号-&gt;选择application。新建界面如图所示：</p>
<p><img src="http://ovec6nnof.bkt.clouddn.com/applicatuon%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE.jpg" alt=""><br>我们需要填的只有三处，首先我们可以为他取个名字，在Name那么输入自定义的名义，然后再Main class那里填写：<code>org.apache.hadoop.util.RunJar</code>，选择progream arguments右边的展开按钮，填写此项的值，在这里需要填写三个参数，第一个就是我们前面创建jar的具体位置，我们可以在前面常见的artifacts中查看，示例<code>D:\intellijIDEA\hadoopTest\out\artifacts\hadoop\hadoop.jar</code>；第二个参数是我们要运行类的名字（需要加上包名）示例<code>com.hut.Test</code>;第三个是输入文件的位置,示例<code>input/</code>；第四个是输入文件的名字示例``output/；<br>参考配置如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">D:\intellijIDEA\hadoopTest\out\artifacts\hadoop\hadoop.jar</span><br><span class="line">com.hut.Test</span><br><span class="line">input&#x2F;</span><br><span class="line">output&#x2F;</span><br></pre></td></tr></table></figure>
<p><img src="http://ovec6nnof.bkt.clouddn.com/program%20agrumets%E5%8F%82%E6%95%B0%E5%80%BC.jpg" alt=""></p>
<p>这里需要根据自己项目的实际情况来进行配置，仅供参考。<br><img src="http://ovec6nnof.bkt.clouddn.com/%E9%85%8D%E7%BD%AE%E5%AE%8C%E6%88%90.jpg" alt=""></p>
<h1 id="运行检测"><a href="#运行检测" class="headerlink" title="运行检测"></a>运行检测</h1><p>根据我们前面的配置，我们需要在项目的根目录下新建一个input文件夹。我们可以在这个文件夹中添加一个txt的文件，并随意的写入一些数据。<br>然后点击运行，成功运行后，会发现我们项目根目录下新添加了一个output文件夹，在<code>part-r-0000</code>文件中，就记录了我们在input文件夹中文件单词出现的次数。如图：<br><img src="http://ovec6nnof.bkt.clouddn.com/%E6%88%90%E5%8A%9F%E8%BF%90%E8%A1%8C~.jpg" alt=""><br>值得注意的是，每次成功运行，都需要将output文件夹删除后才能继续下一次的运行。</p>
<p>到此，我们的环境已经配置好了，接下来就可以开开心的学习hadoop的api使用了。</p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul>
<li><a href="http://blog.csdn.net/u010171031/article/details/53024516" target="_blank" rel="noopener">Hadoop Intellij IDEA本地开发环境搭建</a></li>
<li><a href="http://blog.csdn.net/duhe2665991640/article/details/60468966" target="_blank" rel="noopener">intellij idea本地开发调试hadoop的方法</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://reoger.tk/2017/10/19/other/%E8%B5%84%E6%BA%90%E7%BD%91%E7%AB%99%E6%95%B4%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="reoger">
      <meta itemprop="description" content="reoger">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="reoger的记录">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/10/19/other/%E8%B5%84%E6%BA%90%E7%BD%91%E7%AB%99%E6%95%B4%E7%90%86/" class="post-title-link" itemprop="url">资源网站整理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-10-19 20:19:29" itemprop="dateCreated datePublished" datetime="2017-10-19T20:19:29+08:00">2017-10-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-12 23:12:45" itemprop="dateModified" datetime="2020-04-12T23:12:45+08:00">2020-04-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%9D%82%E7%83%A9/" itemprop="url" rel="index"><span itemprop="name">杂烩</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>不知不觉，四年的下来，还是收集整理了不少的网站，在此统一整理一下，以免以后遗忘。</p>
<h1 id="UI素材类"><a href="#UI素材类" class="headerlink" title="UI素材类"></a>UI素材类</h1><p>在这里记录的是比较常用的图片网站</p>
<h2 id="精美图片"><a href="#精美图片" class="headerlink" title="精美图片"></a>精美图片</h2><p>以下网站是我认为比较好的图片资源网站，更多的图片资源网站，可以参考<a href="https://www.zhihu.com/question/19619335" target="_blank" rel="noopener">知乎的讨论</a>。下面就介绍几个我认为比较好的图片素材网站（更多的是免费）</p>
<h3 id="Pixabay-com"><a href="#Pixabay-com" class="headerlink" title="Pixabay.com"></a><a href="https://pixabay.com/" target="_blank" rel="noopener">Pixabay.com</a></h3><p><strong>Pixabay有可在任何地方使用的免费图片和视频</strong></br><br><a href="https://pixabay.com/" target="_blank" rel="noopener">https://pixabay.com/</a></br><br>Pixabay是一个充满活力的创意社区，分享免费的图片和视频。所有的内容都是在Creative Commons CC0下发布的，这使得它们可以安全的使用，而无需为创作者署名——即使是出于商业目的。<br><img src="https://cdn.pixabay.com/photo/2017/08/26/03/16/mid-finger-2682074_960_720.jpg" alt=""><br>强力推荐，图片又多有好看！重要的是还不要钱，貌似也不用梯子。</p>
<h3 id="Pexels"><a href="#Pexels" class="headerlink" title="Pexels"></a><a href="https://www.pexels.com/" target="_blank" rel="noopener">Pexels</a></h3><p>Pexels 是一个和pixabay 类似的免费高清图片网站。<a href="https://www.pexels.com/" target="_blank" rel="noopener">https://www.pexels.com/</a><br>打开它的主页，中间一个输入框，下面会精选出搜索最热门的关键词、图片，还有免费提供的博主专栏。<br>你还可以将自己的图片上传至Pexels，分享给更多的人使用，你可以根据颜色搜索，它同时也提供了电脑客户端。<br>你可以个人和商业引用，甚至可以重新分发，它遵循CC0 协议。<br><img src="http://ovec6nnof.bkt.clouddn.com/PEXSLS%E7%95%8C%E9%9D%A2.jpg" alt="Pexels界面"></p>
<h3 id="摄图网"><a href="#摄图网" class="headerlink" title="摄图网"></a><a href="http://699pic.com/" target="_blank" rel="noopener">摄图网</a></h3><p><strong>1373737张高清图片免费下载</strong></br><a href="http://699pic.com/" target="_blank" rel="noopener">http://699pic.com/</a><br>100%正版，可商用，免费下载，精品更新；<br>摄图网上的图片还是比较多的，而且质量也比较可以，可以算的上国内比较好的图片资源网站；<br><img src="http://ovec6nnof.bkt.clouddn.com/%E6%91%84%E5%9B%BE%E7%BD%91%E7%95%8C%E9%9D%A2.jpg" alt="摄图网"></p>
<h3 id="Shutterstock"><a href="#Shutterstock" class="headerlink" title="Shutterstock"></a><a href="https://www.shutterstock.com/" target="_blank" rel="noopener">Shutterstock</a></h3><p>Shutterstock <a href="https://www.shutterstock.com/" target="_blank" rel="noopener">https://www.shutterstock.com/</a> 是一家全球技术公司，创建了一个最大、最具活力的双向市场供创意专业人士授权内容，这些内容包括图片、视频和音乐，以及推动创意过程的创新工具。<br>公司已扩展其产品组合，现在包括 Bigstock（以价值为导向的库存媒体机构）、PremiumBeat（特选免版税音乐库）、Rex Features（为全球媒体提供最好的编辑图片源）和 WebDAM（基于云的企业数字资产管理平台），同时创建了 Offset（高端图片精选）。<br><img src="http://ovec6nnof.bkt.clouddn.com/Shutterstock%E7%95%8C%E9%9D%A2.png" alt="Shutterstock"></p>
<h3 id="Everypixel"><a href="#Everypixel" class="headerlink" title="Everypixel"></a><a href="https://everypixel.com/" target="_blank" rel="noopener">Everypixel</a></h3><p>Everypixel <a href="https://everypixel.com/" target="_blank" rel="noopener">https://everypixel.com/</a>是一个 强大的搜索引擎索引 51付费和免费图片的网站，允许用户通过搜索 海量数据库的秒照片。它汇集多家网络素材源，并且利用AI 技术自动移除那些不太好看的内容。<br>它还有很多筛选功能，你可以选择图片来源的网站，图片类型，还可以筛选不同颜色。<br>最重要的是还可以筛选免费的照片。</p>
<h3 id="千图网"><a href="#千图网" class="headerlink" title="千图网"></a><a href="http://www.58pic.com/" target="_blank" rel="noopener">千图网</a></h3><p>千图网<a href="http://www.58pic.com/" target="_blank" rel="noopener">http://www.58pic.com/</a>经过4年的素材积累和数据沉淀，千图网搭建了一个以创意作品库为核心，围绕着设计人群及泛办公人群提供优质创意服务的共享平台。服务内容涵盖了平面广告、电商淘宝、装饰装修、网页UI、产品工业7大主流设计服务，以及PPT模板、Excel模板、文库模板、高清配图、视频音频5大办公人群常用服务，共计60多项细分服务。<br><img src="http://ovec6nnof.bkt.clouddn.com/%E5%8D%83%E5%9B%BE%E7%BD%91%E7%95%8C%E9%9D%A2.png" alt="千图网"></p>
<h3 id="别样网"><a href="#别样网" class="headerlink" title="别样网"></a><a href="http://www.ssyer.com/" target="_blank" rel="noopener">别样网</a></h3><p>别样网<a href="http://www.ssyer.com/" target="_blank" rel="noopener">http://www.ssyer.com/</a>是一个国内的图片分享网站，和pixabay一样都是免版权和免授权使用的。图片大部分都经过后期处理，风景、人物、小清新各种风格应有尽有。</br><br>优点：图片清晰度高，富有美感，网站加载速度快。</br><br>缺点：图片数量偏少，没有搜索功能。</br><br><img src="http://ovec6nnof.bkt.clouddn.com/%E5%88%AB%E6%A0%B7%E7%BD%91.jpg" alt="别样网"></p>
<h2 id="海量图标"><a href="#海量图标" class="headerlink" title="海量图标"></a>海量图标</h2><h3 id="iconfont"><a href="#iconfont" class="headerlink" title="iconfont"></a><a href="http://iconfont.cn/" target="_blank" rel="noopener">iconfont</a></h3><p>阿里妈妈MUX倾力打造的矢量图标管理、交流平台<a href="http://iconfont.cn/" target="_blank" rel="noopener">http://iconfont.cn/</a>。<br>设计师将图标上传到Iconfont平台，用户可以自定义下载多种格式的icon，平台也可将图标转换为字体，便于前端工程师自由调整与调用。<br><img src="http://ovec6nnof.bkt.clouddn.com/iconfont%E7%95%8C%E9%9D%A2.jpg" alt="iconfont"></p>
<h3 id="Icons8"><a href="#Icons8" class="headerlink" title="Icons8"></a><a href="https://zh.icons8.com/" target="_blank" rel="noopener">Icons8</a></h3><p>Icons8 <a href="https://zh.icons8.com/" target="_blank" rel="noopener">https://zh.icons8.com/</a> 是一个提供免费iOS、Windows、Android的平面化设计图案为主的搜索引擎，目前提供近4万个素材资源，数量非常丰富，同时网站也提供各种格式，各种尺寸和配色，让使用者也能自定义制作。<br><img src="http://ovec6nnof.bkt.clouddn.com/icons8%E7%95%8C%E9%9D%A2.jpg" alt="Icons8"></p>
<h3 id="easyIcon"><a href="#easyIcon" class="headerlink" title="easyIcon"></a><a href="http://www.easyicon.net/" target="_blank" rel="noopener">easyIcon</a></h3><p>提供超过四十六万个PNG、ICO、ICNS格式图标搜索、图标下载服务。<a href="http://www.easyicon.net/" target="_blank" rel="noopener">http://www.easyicon.net/</a><br><img src="http://ovec6nnof.bkt.clouddn.com/easyicon%E7%95%8C%E9%9D%A2.jpg" alt="easyIcon"></p>
<h3 id="material-design-icon"><a href="#material-design-icon" class="headerlink" title="material design icon"></a><a href="https://material.io/icons/" target="_blank" rel="noopener">material design icon</a></h3><p>相信android开发者于这个网站会比较熟悉，没错，他就是material icons。<a href="https://material.io/icons/" target="_blank" rel="noopener">https://material.io/icons/</a><br><img src="http://ovec6nnof.bkt.clouddn.com/materical%20io%E7%95%8C%E9%9D%A2.jpg" alt="material"></p>
<h3 id="iconmonstr"><a href="#iconmonstr" class="headerlink" title="iconmonstr"></a><a href="http://iconmonstr.com" target="_blank" rel="noopener">iconmonstr</a></h3><p>有时候我们的设计仅需要简简单单的勾勒创作即可，不需要繁杂的效果与艳丽的颜色搭配！今天给大家介绍这么一个朴实、朴素的图标素材网站 iconmonstr ，该网站的图标素材提供的格式分为PNG、SVG格式。<a href="http://iconmonstr.com" target="_blank" rel="noopener">http://iconmonstr.com</a><br><img src="https://pic.brushes8.com/uploads/2013/02/112545.jpg" alt="iconmonstr界面"></p>
<h3 id="fontawesome"><a href="#fontawesome" class="headerlink" title="fontawesome"></a><a href="http://www.fontawesome.com.cn/" target="_blank" rel="noopener">fontawesome</a></h3><p>一套绝佳的图标字体库和CSS框架,为您提供可缩放的矢量图标，您可以使用CSS所提供的所有特性对它们进行更改，包括：大小、颜色、阴影或者其它任何支持的效果。<a href="http://www.fontawesome.com.cn/" target="_blank" rel="noopener">http://www.fontawesome.com.cn/</a><br><img src="http://ovec6nnof.bkt.clouddn.com/fontawesome%E7%95%8C%E9%9D%A2.jpg" alt="fontawesome"></p>
<h3 id="ionicons"><a href="#ionicons" class="headerlink" title="ionicons"></a><a href="http://ionicons.com/" target="_blank" rel="noopener">ionicons</a></h3><p>iOnicons是一个提供免费ICON图标素材的站点，同时还提供CDN加速服务，该图标集采用 MIT 许可证，用sass来开发，前端网页设计师们可在商业应用中使用，设计出最佳的网页模版。<a href="http://ionicons.com/" target="_blank" rel="noopener">http://ionicons.com/</a></br><br><img src="http://www.egouz.com/uploadfile/2016/0219/20160219090352108.jpg" alt="ss"></p>
<h2 id="创新设计"><a href="#创新设计" class="headerlink" title="创新设计"></a>创新设计</h2><h3 id="lofter"><a href="#lofter" class="headerlink" title="lofter"></a><a href="http://www.lofter.com/" target="_blank" rel="noopener">lofter</a></h3><p>LOFTER汇聚了数百万的摄影、胶片玩家，绘画及动漫爱好者，并不断衍生出更多的兴趣圈子，无论是设计、<br>艺术、科技、时尚、旅行、读书、电影评论都有精彩的人与内容不断产出。<a href="http://www.lofter.com/" target="_blank" rel="noopener">http://www.lofter.com/</a><br><img src="http://ovec6nnof.bkt.clouddn.com/lofter%E5%81%87%E9%9D%A2.jpg" alt="lofter"></p>
<h3 id="Ui中国"><a href="#Ui中国" class="headerlink" title="Ui中国"></a><a href="http://www.ui.cn/" target="_blank" rel="noopener">Ui中国</a></h3><p>UI中国<a href="http://www.ui.cn/" target="_blank" rel="noopener">http://www.ui.cn/</a>，前身为iconfans.com。是专业的界面设计师交流、学习、展示平台。同时也是中国最大的UI设计师聚集地，会员均为一线UI设计师，覆盖主流互联网公司。我们希望借助互联网的力量打造国内最专业的UI设计平台，为UI设计师做最好的服务，提高UI设计行业价值！<br>前身iconfans.com，自2008年发展至今已有6年积累。历年来，iconfans曾经组织会员参与过一系列的国内外的设计竞赛，并取得了优异成绩。每年举办一届行业聚会。在我们的会员中赢得了口碑。不断的推出一些会员活动、曾经与小米、百度、腾讯、新浪、搜狐、锤子科技（Smartisan ）、360桌面、点点网、搜狗、华为等知名互联网公司和企业合作活动。<br>未来，UI中国，将继续以UI设计师为中心，为UI设计师做最好的服务，提高UI设计行业价值！</p>
<h3 id="前端里"><a href="#前端里" class="headerlink" title="前端里"></a><a href="http://www.yyyweb.com/" target="_blank" rel="noopener">前端里</a></h3><p>前端里<a href="http://www.yyyweb.com/" target="_blank" rel="noopener">http://www.yyyweb.com/</a>专注 Web 开发技术，分享最前沿的 Web 开发教程、资源和和素材，是面向程序开发人员和设计师的学习交流平台。<br><img src="http://ovec6nnof.bkt.clouddn.com/%E5%89%8D%E7%AB%AF%E9%87%8C%E7%95%8C%E9%9D%A2.jpg" alt="前端里"></p>
<h2 id="通用模板"><a href="#通用模板" class="headerlink" title="通用模板"></a>通用模板</h2><h3 id="优品PPT"><a href="#优品PPT" class="headerlink" title="优品PPT"></a><a href="http://www.ypppt.com/" target="_blank" rel="noopener">优品PPT</a></h3><p>一个有情怀的免费PPT模板下载网站！<a href="http://www.ypppt.com/" target="_blank" rel="noopener">http://www.ypppt.com/</a><br><img src="http://ovec6nnof.bkt.clouddn.com/%E4%BC%98%E5%93%81ppt%E7%95%8C%E9%9D%A2.jpg" alt="优品PPT"></p>
<h1 id="学习资料类"><a href="#学习资料类" class="headerlink" title="学习资料类"></a>学习资料类</h1><h2 id="博客"><a href="#博客" class="headerlink" title="博客"></a>博客</h2><h3 id="CSDN"><a href="#CSDN" class="headerlink" title="CSDN"></a><a href="http://blog.csdn.net/" target="_blank" rel="noopener">CSDN</a></h3><p>CSDN <a href="https://www.csdn.net/" target="_blank" rel="noopener">https://www.csdn.net/</a> (Chinese Software Developer Network) 创立于1999年，是中国最大的IT社区和服务平台，为中国的软件开发者和IT从业者提供知识传播、职业发展、软件开发等全生命周期服务，满足他们在职业发展中学习及共享知识和信息、建立职业发展社交圈、通过软件开发实现技术商业化等刚性需求。拥有超过3000万注册会员（其中活跃会员800万）、50万注册企业及合作伙伴。</p>
<p>旗下拥有：全球最大中文IT技术社区：csdn、权威IT专业技术期刊：《程序员》杂志、IT人力资源服务：科锐福克斯、IT技术学习平台：乐知教育、代码托管+社交编程平台：code、移动开发工具和服务聚合平台：mobilehub、IT专属求职网站：job、中文软件外包和项目交易平台：csto、程序员深度交流社区：iteye、中国最大技术管理者平台：CTO俱乐部、云计算产业人士沙龙：云计算俱乐部、面向移动开发者的技术组织：移动开发者俱乐部、面向全国大学生的技术组织：高校俱乐部。</p>
<h3 id="简书"><a href="#简书" class="headerlink" title="简书"></a><a href="http://www.jianshu.com/" target="_blank" rel="noopener">简书</a></h3><p>简书<a href="http://www.jianshu.com/" target="_blank" rel="noopener">http://www.jianshu.com/</a>  是一个创作社区，任何人均可以在其上进行创作。用户在简书上面可以方便的创作自己的作品，互相交流。简书成为国内优质原创内容输出平台。</p>
<h3 id="博客园"><a href="#博客园" class="headerlink" title="博客园"></a><a href="https://www.cnblogs.com/" target="_blank" rel="noopener">博客园</a></h3><p>一个IT技术人员想为IT技术人员们提供一个纯净的技术交流空间，博客园很长时间只有一个不能再简单的博客，有近四年，博客园仅靠一个人几年工作的积蓄在维持，互联网浪潮的此起彼伏，“博客”从耀眼的明星成为平民，这些似乎都与博客园无关，博客园一步一个脚印地走着自己的路，傻傻地对每个用户注册进行人工审批、对首页内容宁缺毋滥、对不合适的广告拒之门外，傻傻地对用户体验关怀备至，对盈利模式冷若冰霜。<br>访问链接： <a href="https://www.cnblogs.com/" target="_blank" rel="noopener">https://www.cnblogs.com/</a></p>
<h3 id="掘金"><a href="#掘金" class="headerlink" title="掘金"></a><a href="https://juejin.im/" target="_blank" rel="noopener">掘金</a></h3><p>掘金技术 <a href="https://juejin.im/" target="_blank" rel="noopener">https://juejin.im/</a> 社区是中国质量最高的技术分享社区，邀请稀土用户作为 Co-Editor 来分享优质的技术干货，从前端到后端开发，从设计到产品，让每一个掘金用户都能挖掘到有价值的干货。</p>
<h2 id="网上视频学习"><a href="#网上视频学习" class="headerlink" title="网上视频学习"></a>网上视频学习</h2><h3 id="慕课网"><a href="#慕课网" class="headerlink" title="慕课网"></a><a href="http://www.imooc.com/" target="_blank" rel="noopener">慕课网</a></h3><p>程序员的梦工厂&lt;(<a href="http://www.imooc.com/&gt;，源于国外，Massive（大规模）Open（开放）Online（在线）Course（课程）。提供大量优质的免费教程，也提供职业路径学习，收费的项目实战。" target="_blank" rel="noopener">http://www.imooc.com/&gt;，源于国外，Massive（大规模）Open（开放）Online（在线）Course（课程）。提供大量优质的免费教程，也提供职业路径学习，收费的项目实战。</a></p>
<h3 id="极客学院"><a href="#极客学院" class="headerlink" title="极客学院"></a><a href="http://ke.jikexueyuan.com/" target="_blank" rel="noopener">极客学院</a></h3><p>极客学院<a href="http://www.jikexueyuan.com/" target="_blank" rel="noopener">http://www.jikexueyuan.com/</a>  是中国android开发在线学习平台，汇集了几十名国内顶尖的有多年项目和实战经验的Android开发授课大师，精心制作了上千个高质量视频教程，涵盖了Android开发学习的基础入门、中级进阶，高级提升、项目实战开发等专业的android开发课程。<br>极客学院背后是一支疯狂喜欢编程，狂热开发移动app的超有活力团队。他们希望通过最新的，高质量的，专业实战的在线开发课程打破传统的编程学习模式，以新一代的编程学习模式帮助开发者更快更好的学习Android开发，帮助开发者通过技术实现自己的理想。<br>作为国内最大IT职业在线教育平台，极客学院一直致力于“让学习更有效”，帮助IT从业者在最短的时间内获得最多的知识，技能得到最快的提升。目前，极客学院已拥有60多万IT从业者用户。</p>
<h3 id="网易云课堂"><a href="#网易云课堂" class="headerlink" title="网易云课堂"></a><a href="http://study.163.com/" target="_blank" rel="noopener">网易云课堂</a></h3><p>网易云课堂&lt;(<a href="http://study.163.com/&gt;，是网易公司打造的在线实用技能学习平台，该平台于2012年12月底正式上线，主要为学习者提供海量、优质的课程，用户可以根据自身的学习程度，自主安排学习进度。" target="_blank" rel="noopener">http://study.163.com/&gt;，是网易公司打造的在线实用技能学习平台，该平台于2012年12月底正式上线，主要为学习者提供海量、优质的课程，用户可以根据自身的学习程度，自主安排学习进度。</a><br>网易云课堂立足于实用性的要求，网易云课堂与多家教育、培训机构建立合作，课程数量已达4100+，课时总数超50000,涵盖实用软件、IT与互联网、外语学习、生活家居、兴趣爱好、职场技能、金融管理、考试认证、中小学、亲子教育等十余大门类。</p>
<h3 id="麦子学院"><a href="#麦子学院" class="headerlink" title="麦子学院"></a><a href="http://www.maiziedu.com/" target="_blank" rel="noopener">麦子学院</a></h3><p>麦子学院<a href="http://www.maiziedu.com/" target="_blank" rel="noopener">http://www.maiziedu.com/</a>，国内第一家在美国建立商务中心的IT在线教育机构，目前已与美国知名教育公司取得合作，未来将源源不断向国内输出大量高质量教育资源<br>前身麦可网，2014年，麦可网完成千万级A轮融资，并更名为”麦子学院“，同时通过“麦子圈”IT职业实名社交圈——提供包括企业招聘对接，猎头，项目外包，经验分享，职业交友等一系列增值服务。<br>做在线职业教育示范学院，将教育和课程做到极致。除了提供高质量的课程学习之外，也提供包括就业推荐，职业交友，项目外包，创业服务等全面的增值服务，并且线上线下结合，移动设备和传统网络相结合，打造IT职业教育的一个完整生态链。<br>以高端IT技术型人才培养及服务为核心，探索及倡导技术交流创新模式。提供的不仅仅是技能培养，而是务实的职业导向。</p>
<h3 id="中国大学Mooc"><a href="#中国大学Mooc" class="headerlink" title="中国大学Mooc"></a><a href="http://www.icourse163.org/" target="_blank" rel="noopener">中国大学Mooc</a></h3><p>中国mooc <a href="http://www.icourse163.org/" target="_blank" rel="noopener">http://www.icourse163.org/</a>,汇集名校名师的优秀课程，让我们可以通过网络的方式来学习优质的免费课程！大赞，有点免费大学的感觉~</p>
<h3 id="开课吧"><a href="#开课吧" class="headerlink" title="开课吧"></a><a href="http://www.kaikeba.com/" target="_blank" rel="noopener">开课吧</a></h3><p>开课吧<a href="http://www.kaikeba.com/" target="_blank" rel="noopener">http://www.kaikeba.com/</a> 是指作为慧科教育的重要成员企业，开课吧是中文泛IT在线教育平台，传承了慧科教育专注前沿科技、创新人才培养模式的基因，并积极探索在线教育模式创新。<br>开课吧集在线课程的创意、设计、前期拍摄、后期制作、 综合运营为一体，专注于移动开发、云计算、互联网营销等八大类泛IT课程，不断面向个人、高校和企事业单位提供在线产品研发咨询服务、在线课程制作服务、MOOC 平台服务、导学服务和认证服务等综合在线教育解决方案。</p>
<h3 id="计蒜客"><a href="#计蒜客" class="headerlink" title="计蒜客"></a><a href="http://www.jisuanke.com/" target="_blank" rel="noopener">计蒜客</a></h3><p>计蒜客 <a href="http://www.jisuanke.com/" target="_blank" rel="noopener">http://www.jisuanke.com/</a> 为弥合工业界、学术界对于优秀计算机人才的缺口而诞生，致力于为全国乃至全球希望投身计算机领域的人才提供高性价比的学习机会，培养快速学习、拥抱变化、敢于发现的优秀工程师与学术精英。大部分是收费的。</p>
<h3 id="实验楼"><a href="#实验楼" class="headerlink" title="实验楼"></a><a href="https://www.shiyanlou.com/" target="_blank" rel="noopener">实验楼</a></h3><p>实验楼 <a href="https://www.shiyanlou.com/" target="_blank" rel="noopener">https://www.shiyanlou.com/</a> 是国内领先的IT技术实训平台，采用创新的“在线实验”学习模式，为学生及在职程序员提供编程、运维、测试、云计算、大数据、数据库等最新的IT技术实践课程。<br>实验楼建设初衷是帮助学习者通过动手实践收获知识，同时体会实验精神。德国教育学家斯普朗格说：“教育的最终目的不是传授已有的东西，而是要把人的创造力量诱导出来”，实验楼设计理念也是如此：从实践切入，依靠交互性、操作性更强的课程，理论学习+动手实践共同激发你的创造力。</p>
<h3 id="腾讯课堂"><a href="#腾讯课堂" class="headerlink" title="腾讯课堂"></a><a href="https://ke.qq.com/" target="_blank" rel="noopener">腾讯课堂</a></h3><p>腾讯课堂 <a href="https://ke.qq.com/" target="_blank" rel="noopener">https://ke.qq.com/</a> 是腾讯推出的专业在线教育平台，聚合了优质教育机构和教师的海量课程资源。作为开放式的平台，腾讯课堂计划帮助线下教育机构入驻，共同探索在线教育新模式，这无形中又为在线教育O2O增添了几分热度。</p>
<p>腾讯课堂凭借QQ客户端的优势，实现在线即时互动教学；并利用QQ积累多年的音视频能力，提供流畅、高音质的课程直播效果；同时支持PPT演示、屏幕分享等多样化的授课模式，还为教师提供白板、提问等能力。 腾讯创建在线教育平台—腾讯课堂，改善了中国教育资源分布和发展不均的现状，依托互联网，打破地域的限制，让每个立志学习，有梦想的人，都能接受优秀老师的指导和教学；同时希望给优秀的机构及教师一个展示的平台。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://reoger.tk/2017/10/17/backEnd/hadoop%E5%AE%89%E8%A3%85/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="reoger">
      <meta itemprop="description" content="reoger">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="reoger的记录">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/10/17/backEnd/hadoop%E5%AE%89%E8%A3%85/" class="post-title-link" itemprop="url">hadoop入门基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-10-17 19:34:05" itemprop="dateCreated datePublished" datetime="2017-10-17T19:34:05+08:00">2017-10-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-07-18 13:40:47" itemprop="dateModified" datetime="2020-07-18T13:40:47+08:00">2020-07-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/backEnd/" itemprop="url" rel="index"><span itemprop="name">backEnd</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p><a href="http://hadoop.apache.org/" target="_blank" rel="noopener">Apache Hadoop</a>是一个在商业硬件大型集群上运行应用程序的框架。Hadoop框架为应用程序提供透明的可靠性和数据运动。Hadoop实现了一个名为<a href="https://wiki.apache.org/hadoop/HadoopMapReduce" target="_blank" rel="noopener">Map / Reduce</a>的计算范例，其中应用程序分为许多小的工作片段，每个工作片段都可以在集群中的任何节点上执行或重新执行。此外，它还提供了一种在计算节点上存储数据的分布式文件系统（<a href="https://wiki.apache.org/hadoop/DFS" target="_blank" rel="noopener">HDFS</a>），可在集群中提供非常高的聚合带宽。两者的<a href="https://wiki.apache.org/hadoop/MapReduce" target="_blank" rel="noopener">MapReduce</a>和Hadoop分布式文件系统的设计使得节点故障是由框架自动处理。</p>
</blockquote>
<h1 id="hadoop功能与优势"><a href="#hadoop功能与优势" class="headerlink" title="hadoop功能与优势"></a>hadoop功能与优势</h1><p>hadoop是什么我们前面已经介绍过了，下面我们主要介绍他的几个核心部分：</p>
<ol>
<li>HDFS：分布式文件系统，存储海量的数据</li>
<li>MapReduce：并行处理框架，实现任务分解和调度。<br>我们一般用hadoop来搭建大型数据仓库、PB级数据的存储、处理、分析、统计等业务。</li>
<li>Common: 一组分布式文件系统和通用I/O的组建(序列化、java RPC和持久化数据结构)</li>
<li>Pig: 一种数据流语言和运行环境，用以检索非常大的数据集。pig运行在MapRedyce和HdFS集群上。</li>
<li>HBase： 一个分布式、按列存储数据库。Hbase使用HDFS作为底层储存，同时支持MapReduce的批量式计算和点查询（随机读取）。</li>
<li>ZooKeeper：一个分布式、可用性高的协调服务。ZooKeeper提供分布式锁之类的基本服务，用于构建分布式应用。</li>
<li>sqoop： 在数据库和HDFS之间高校传输数据的工具。</li>
</ol>
<p>hadoop的优势：</p>
<ol>
<li>高扩展</li>
<li>低成本</li>
<li>成熟的生态圈</li>
</ol>
<h1 id=""><a href="#" class="headerlink" title=""></a></h1><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://www.iwwenbo.com/hadoop-installation-on-windows-without-cygwin/" target="_blank" rel="noopener">在windows平台下安装hadoop</a></li>
<li><a href="http://blog.csdn.net/wen3011/article/details/54907731" target="_blank" rel="noopener">安装环境JAVA_HOME is incorrectly set问题解决</a></li>
<li><a href="http://www.voidcn.com/article/p-gdpjxbxw-bz.html" target="_blank" rel="noopener">windows下hadoop本地开发环境的搭建</a></li>
<li><a href="http://www.linuxidc.com/Linux/2016-08/134131p2.htm" target="_blank" rel="noopener">可以会用到的环境搭建资料</a></li>
<li><a href="http://www.imooc.com/video/7642" target="_blank" rel="noopener">imooc上的hadoop视屏学习资料</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://reoger.tk/2017/10/12/android/%E4%BD%BF%E7%94%A8retrofit%E6%9F%A5%E8%AF%A2elasticsearch/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="reoger">
      <meta itemprop="description" content="reoger">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="reoger的记录">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/10/12/android/%E4%BD%BF%E7%94%A8retrofit%E6%9F%A5%E8%AF%A2elasticsearch/" class="post-title-link" itemprop="url">android端对elasticsearch进行增、删、改、查</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-10-12 16:33:08" itemprop="dateCreated datePublished" datetime="2017-10-12T16:33:08+08:00">2017-10-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-07-18 13:45:10" itemprop="dateModified" datetime="2020-07-18T13:45:10+08:00">2020-07-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/android/" itemprop="url" rel="index"><span itemprop="name">android</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>Retrofit与okhttp共同出自于Square公司，retrofit就是对okhttp做了一层封装。把网络请求都交给给了Okhttp，我们只需要通过简单的配置就能使用retrofit来进行网络请求了，其主要作者是Android大神JakeWharton。</p>
</blockquote>
<p>我们上篇学习了如何通过poastMan来模拟http请求来学习elasticsearch的基本请求操作。接下来记录的是如何代码来对我们之前配置好的elasticsearch服务器进行增删改查的基本操作。为了简单起见，我们使用的是开源库<code>retrofit</code>来实现android断的网络通信。</p>
<h1 id="保证可访问"><a href="#保证可访问" class="headerlink" title="保证可访问"></a>保证可访问</h1><p>在正式编写代码之前，我们需要做的一件非常重要的事情就是，确保我们的手机能正确访问到elasticsearch服务器，为了简单起见，我们就实现在同一个局域网之间能正常访问即可。至于如果将elasticsearch如果通过外网访问，这里我就不做介绍了。在确保我们手机与电脑在同一个局域网之后，我们需要做的事情就很简单了，用手机浏览器访问<code>http://you ip:9200</code>,如果浏览器显示如下提示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">name: &quot;msater&quot;,</span><br><span class="line">cluster_name: &quot;reoger&quot;,</span><br><span class="line">cluster_uuid: &quot;D8qVJjX5SCSh62mz9ei3og&quot;,</span><br><span class="line">version: &#123;</span><br><span class="line">number: &quot;5.6.1&quot;,</span><br><span class="line">build_hash: &quot;667b497&quot;,</span><br><span class="line">build_date: &quot;2017-09-14T19:22:05.189Z&quot;,</span><br><span class="line">build_snapshot: false,</span><br><span class="line">lucene_version: &quot;6.6.1&quot;</span><br><span class="line">&#125;,</span><br><span class="line">tagline: &quot;You Know, for Search&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>则说明我们的手机已经可以正常访问到eslasticsearch服务器了，这个时候我们就可以进行android端的代码编写了。如果手机浏览器提示我们无法访问，可能是我们的eslasticsearch并并没有绑定我们指定的ip地址，具体做法就是到我们eslasticseach/config/elasticsearch.yml中，修改<code>network.host:</code>的值（如果没有就创建）为我们要访问的ip地址即可。如图：<br><img src="http://ovec6nnof.bkt.clouddn.com/%E9%85%8D%E7%BD%AEip%E5%9C%B0%E5%9D%80.png" alt="配置IP地址"></p>
<h1 id="访问测试"><a href="#访问测试" class="headerlink" title="访问测试"></a>访问测试</h1><p>下面的代码开始就是直接通过retrofit来进行网络请求，如果这个开源库不是很熟悉的话，可以先通过<a href="">这里</a>了解<code>retroift</code>的基本操作。因为例子比较简单，也可以通过本示例对<code>retrofit</code>做一个简单的了解。<br>通过我们手机浏览器的测试我们知道，我们只需要用代码实现访问之前测试通过的地址就可以陈宫访问，接下来我们就通过<code>Retrofit</code>来实现对Elasticsearch的访问测试。<br>代码很简单，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">OkHttpClient client&#x3D;new OkHttpClient();</span><br><span class="line">        Request request &#x3D; new Request.Builder().url(&quot;http:&#x2F;&#x2F;you Ip:9200&#x2F;&quot;).build();</span><br><span class="line">       client.newCall(request).enqueue(new okhttp3.Callback() &#123;</span><br><span class="line">           @Override</span><br><span class="line">           public void onFailure(okhttp3.Call call, IOException e) &#123;</span><br><span class="line">               Log.d(&quot;TAG&quot;,e.toString());</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           @Override</span><br><span class="line">           public void onResponse(okhttp3.Call call, okhttp3.Response response) throws IOException &#123;</span><br><span class="line">               if(response!&#x3D;null)</span><br><span class="line">                Log.d(&quot;TAG&quot;,response.body().string());</span><br><span class="line">               else</span><br><span class="line">                   Log.d(&quot;TAG&quot;,&quot;没有返回任何的数据&quot;);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br></pre></td></tr></table></figure>
<p>观察到，当我们运行上面的代码的时候，会打印出我们用浏览器访问的相同的输出。代表着我们的访问测试成功通过。上面ip地址需要修改成你真正的访问ip地址，本例主要通过okhttp来实现网络请求，<code>retrofit</code>是对<code>okhttp</code>进一步的封装，但是这里我们用okhttp反而更加清晰，简单。</p>
<h1 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h1><p>在我们前面的介绍中，我们已经知道如何通过postman这一工具来创建索引，其实就是通过<code>put</code>请求来访问<code>http://you ip/你要创建的索引名称</code>，然后通过上传json信息来确定索引的详细信息，示例的json代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&quot;settings&quot;:&#123;</span><br><span class="line">		&quot;number_of_shards&quot;:3,</span><br><span class="line">		&quot;number_of_replicas&quot;:1</span><br><span class="line">	&#125;,</span><br><span class="line">	&quot;mappings&quot;:&#123;</span><br><span class="line">		&quot;man&quot;:&#123;</span><br><span class="line">			&quot;properties&quot;:&#123;</span><br><span class="line">				&quot;name&quot;:&#123;</span><br><span class="line">					&quot;type&quot;:&quot;text&quot;</span><br><span class="line">				&#125;,</span><br><span class="line">				&quot;country&quot;:&#123;</span><br><span class="line">					&quot;type&quot;:&quot;keyword&quot;</span><br><span class="line">				&#125;,</span><br><span class="line">				&quot;age&quot;:&#123;</span><br><span class="line">					&quot;type&quot;:&quot;integer&quot;</span><br><span class="line">				&#125;,</span><br><span class="line">				&quot;data&quot;:&#123;</span><br><span class="line">					&quot;type&quot;:&quot;date&quot;,</span><br><span class="line">					&quot;format&quot;: &quot;yyyy-MM-dd HH:mm:ss||yyy-MM-dd||epoch_millis&quot;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;,</span><br><span class="line">		&quot;woman&quot;:&#123;</span><br><span class="line">			&quot;properties&quot;:&#123;</span><br><span class="line">				&quot;name&quot;:&#123;</span><br><span class="line">					&quot;type&quot;:&quot;text&quot;</span><br><span class="line">				&#125;,</span><br><span class="line">				&quot;country&quot;:&#123;</span><br><span class="line">					&quot;type&quot;:&quot;keyword&quot;</span><br><span class="line">				&#125;,</span><br><span class="line">				&quot;age&quot;:&#123;</span><br><span class="line">					&quot;type&quot;:&quot;integer&quot;</span><br><span class="line">				&#125;,</span><br><span class="line">				&quot;data&quot;:&#123;</span><br><span class="line">					&quot;type&quot;:&quot;date&quot;,</span><br><span class="line">					&quot;format&quot;:&quot;yyyy-MM-dd HH:mm:ss||yyy-MM-dd||epoch_millis&quot;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面我们来在android中创建上述的索引。整体来说，代码还是很简单，我们先看实现代码，然后进行简要的说明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">String sry &#x3D;&quot;&#123; \&quot;settings\&quot;: &#123; \&quot;number_of_shards\&quot;: 3, \&quot;number_of_replicas\&quot;: 1 &#125;, \&quot;mappings\&quot;: &#123; \&quot;man\&quot;: &#123; \&quot;properties\&quot;: &#123; \&quot;name\&quot;: &#123; \&quot;type\&quot;: \&quot;text\&quot; &#125;, \&quot;country\&quot;: &#123; \&quot;type\&quot;: \&quot;keyword\&quot; &#125;, \&quot;age\&quot;: &#123; \&quot;type\&quot;: \&quot;integer\&quot; &#125;, \&quot;data\&quot;: &#123; \&quot;type\&quot;: \&quot;date\&quot;, \&quot;format\&quot;: \&quot;yyyy-MM-dd HH:mm:ss||yyy-MM-dd||epoch_millis\&quot; &#125; &#125; &#125;, \&quot;woman\&quot;: &#123; \&quot;properties\&quot;: &#123; \&quot;name\&quot;: &#123; \&quot;type\&quot;: \&quot;text\&quot; &#125;, \&quot;country\&quot;: &#123; \&quot;type\&quot;: \&quot;keyword\&quot; &#125;, \&quot;age\&quot;: &#123; \&quot;type\&quot;: \&quot;integer\&quot; &#125;, \&quot;data\&quot;: &#123; \&quot;type\&quot;: \&quot;date\&quot;, \&quot;format\&quot;: \&quot;yyyy-MM-dd HH:mm:ss||yyy-MM-dd||epoch_millis\&quot; &#125; &#125; &#125; &#125; &#125;&quot;;</span><br><span class="line"></span><br><span class="line">      RequestBody body &#x3D; RequestBody.create(okhttp3.MediaType.parse(&quot;application&#x2F;json; charset&#x3D;utf-8&quot;),sry);</span><br><span class="line">      final Request request &#x3D; new Request.Builder()</span><br><span class="line">              .url(&quot;http:&#x2F;&#x2F;192.168.139.1:9200&#x2F;test&quot;)</span><br><span class="line">              .put(body)</span><br><span class="line">              .build();</span><br><span class="line">      OkHttpClient client&#x3D;new OkHttpClient();</span><br><span class="line">      client.newCall(request).enqueue(new okhttp3.Callback() &#123;</span><br><span class="line">          @Override</span><br><span class="line">          public void onFailure(okhttp3.Call call, IOException e) &#123;</span><br><span class="line">              Log.d(&quot;TAG&quot;, &quot;onFailure: &quot;+e);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          @Override</span><br><span class="line">          public void onResponse(okhttp3.Call call, okhttp3.Response response) throws IOException &#123;</span><br><span class="line">              if(response!&#x3D;null)</span><br><span class="line">                  Log.d(&quot;TAG&quot;,response.body().string());</span><br><span class="line">              else</span><br><span class="line">                  Log.d(&quot;TAG&quot;,&quot;没有返回任何的数据&quot;);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br></pre></td></tr></table></figure>
<p>运行上面的代码就能可以在android端创建一个索引，其实我们的代码也比较简单，就是将我们要上传的json数据当作boby一同提交给服务端就OK了。当然，这里我们的json数据是固定的，但是就对于创建索引来说，固定的json数据也能应该大部分情况了，但是添加数据就不能用固定的json数据，那么我们就不能采用这种简单粗暴的方法了，下面将会介绍如果上传动态json数据。</p>
<h1 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h1><p>前面文章中已经介绍过如果在postman中添加数据，那么我们现在通过自己编写代码来实现在android中向elsactisearch中添加数据，请求方式是一样的，因为实现起来非常简单，我们只介绍不指定文档ID插入。前面我们介绍到指定文档ID添加数据需要使用<code>put</code>请求方式，并且需要请求地址中表明ID，而不指定文档ID添加数据则需要用<code>post</code>请求方式，并且不需要再请求地址中表明ID。我们这里就实现用不指定文档ID插入。</p>
<p>通过前面的常见索引，相信大家应该知道如果将json数据上传到服务器，我们这里注重讲的书如何将上传动态json数据。<br>创建动态json数据，我们需要准备json格式对应的bean对象，这里我们采用<code>gsonFormat</code>插件来生成bean对象，例如我们要上传的json数据如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&quot;name&quot;: &quot;张三&quot;,</span><br><span class="line">	&quot;country&quot;: &quot;Englis&quot;,</span><br><span class="line">	&quot;age&quot;: 18,</span><br><span class="line">	&quot;date&quot;: &quot;1999-03-07&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，这里上传的数据要与前面我们创建索引数据格式对应起来，否则不能成功添加。我们将该json对象的bean对象命名为<code>AddData</code>，源码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public class AddData &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line">    private String country;</span><br><span class="line">    private int age;</span><br><span class="line">    private String date;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getCountry() &#123;</span><br><span class="line">        return country;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setCountry(String country) &#123;</span><br><span class="line">        this.country &#x3D; country;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAge(int age) &#123;</span><br><span class="line">        this.age &#x3D; age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getDate() &#123;</span><br><span class="line">        return date;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setDate(String date) &#123;</span><br><span class="line">        this.date &#x3D; date;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建上述的bean对象后，我们就可以通过代码来动态的修改json数据，主要的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">AddData addData &#x3D; new AddData();</span><br><span class="line">       addData.setAge(23);</span><br><span class="line">       addData.setCountry(&quot;China&quot;);</span><br><span class="line">       addData.setDate(&quot;2017-09-19&quot;);</span><br><span class="line">       addData.setName(&quot;DongMingZhu&quot;);&#x2F;&#x2F;动态设置json数据</span><br><span class="line"></span><br><span class="line">       Gson gson &#x3D; new Gson();</span><br><span class="line">       String dyJson &#x3D; gson.toJson(addData);</span><br><span class="line">       RequestBody body &#x3D; RequestBody.create(okhttp3.MediaType.parse(&quot;application&#x2F;json; charset&#x3D;utf-8&quot;),dyJson);</span><br><span class="line">       final Request request &#x3D; new Request.Builder()</span><br><span class="line">               .url(&quot;http:&#x2F;&#x2F;192.168.139.1:9200&#x2F;test&#x2F;woman&quot;)</span><br><span class="line">               .post(body)</span><br><span class="line">               .build();</span><br><span class="line">       OkHttpClient client&#x3D;new OkHttpClient();</span><br><span class="line">       client.newCall(request).enqueue(new okhttp3.Callback() &#123;</span><br><span class="line">           @Override</span><br><span class="line">           public void onFailure(okhttp3.Call call, IOException e) &#123;</span><br><span class="line">               Log.d(&quot;TAG&quot;, &quot;onFailure: &quot;+e);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           @Override</span><br><span class="line">           public void onResponse(okhttp3.Call call, okhttp3.Response response) throws IOException &#123;</span><br><span class="line">               if(response!&#x3D;null)</span><br><span class="line">                   Log.d(&quot;TAG&quot;,response.body().string());</span><br><span class="line">               else</span><br><span class="line">                   Log.d(&quot;TAG&quot;,&quot;没有返回任何的数据&quot;);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br></pre></td></tr></table></figure>
<p>运行上述的代码后，发现我们的json数据已经成功上传到服务端。简单吧<del>~</del></p>
<h1 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h1><p>删除操作就是用通过DELETE访问即可，要删除指定文档，我们通过DELETE访问到指定的文档ID即可，例如我想删除test索引中man类中的id为1的文档，我的访问链接可能就是<code>http://127.0.0.1/9100/test/man/1</code> ，如果我们想要直接删除test索引，我们可以通过delete方法访问<code>http://127.0.0.1/9100/test</code>，删除操作很简单，但是我们却要很慎重的对待他，因为我们一旦删除就无法找回。在做删除操作之前最好确保数据备份。因为实现起来很简单，仅贴出删除指定数据的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">OkHttpClient client&#x3D;new OkHttpClient();</span><br><span class="line">     Request request &#x3D; new Request.Builder().url(&quot;http:&#x2F;&#x2F;127.0.0.1&#x2F;9100&#x2F;test&#x2F;man&#x2F;1&quot;).delete().build();</span><br><span class="line">    client.newCall(request).enqueue(new okhttp3.Callback() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void onFailure(okhttp3.Call call, IOException e) &#123;</span><br><span class="line">            Log.d(&quot;TAG&quot;,e.toString());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void onResponse(okhttp3.Call call, okhttp3.Response response) throws IOException &#123;</span><br><span class="line">            if(response!&#x3D;null)</span><br><span class="line">             Log.d(&quot;TAG&quot;,response.body().string());</span><br><span class="line">            else</span><br><span class="line">                Log.d(&quot;TAG&quot;,&quot;没有返回任何的数据&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>


<h1 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h1><h1 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h1>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://reoger.tk/2017/09/27/backEnd/elasticsearch%E5%85%A5%E9%97%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="reoger">
      <meta itemprop="description" content="reoger">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="reoger的记录">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/09/27/backEnd/elasticsearch%E5%85%A5%E9%97%A8/" class="post-title-link" itemprop="url">elasticsearch入门</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-09-27 20:48:46" itemprop="dateCreated datePublished" datetime="2017-09-27T20:48:46+08:00">2017-09-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-07-18 13:40:44" itemprop="dateModified" datetime="2020-07-18T13:40:44+08:00">2020-07-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/backEnd/" itemprop="url" rel="index"><span itemprop="name">backEnd</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Elasticsearch-是什么"><a href="#Elasticsearch-是什么" class="headerlink" title="Elasticsearch 是什么"></a>Elasticsearch 是什么</h1><p>Elasticsearch是一个基于<a href="https://lucene.apache.org/core/" target="_blank" rel="noopener">Apache Lucene(TM)</a>的开源搜索引擎。无论在开源还是专有领域，Lucene可以被认为是迄今为止最先进、性能最好的、功能最全的搜索引擎库。<br>但是，Lucene只是一个库。想要使用它，你必须使用Java来作为开发语言并将其直接集成到你的应用中，更糟糕的是，Lucene非常复杂，你需要深入了解检索的相关知识来理解它是如何工作的。<br>Elasticsearch也使用Java开发并使用Lucene作为其核心来实现所有索引和搜索的功能，但是它的目的是通过简单的RESTful API来隐藏Lucene的复杂性，从而让全文搜索变得简单。<br>不过，Elasticsearch不仅仅是Lucene和全文搜索，我们还能这样去描述它：<br>分布式的实时文件存储，每个字段都被索引并可被搜索<br>分布式的实时分析搜索引擎<br>可以扩展到上百台服务器，处理PB级结构化或非结构化数据<br>而且，所有的这些功能被集成到一个服务里面，你的应用可以通过简单的RESTful API、各种语言的客户端甚至命令行与之交互。<br>上手Elasticsearch非常容易。它提供了许多合理的缺省值，并对初学者隐藏了复杂的搜索引擎理论。它开箱即用（安装即可使用），只需很少的学习既可在生产环境中使用。<br>Elasticsearch在Apache 2 license下许可使用，可以免费下载、使用和修改。<br>随着你对Elasticsearch的理解加深，你可以根据不同的问题领域定制Elasticsearch的高级特性，这一切都是可配置的，并且配置非常灵活。</p>
<h1 id="开始使用"><a href="#开始使用" class="headerlink" title="开始使用"></a>开始使用</h1><p>因为本人电脑是win10的系统，所以针对elasticsearch所有的操作与环境都是在win10环境下完成，至于其他系统环境，这里不予讨论。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>安装什么的最简单了，首先肯定要将elasticsearch下载到本地，要下载请戳<a href="https://www.elastic.co/downloads/elasticsearch" target="_blank" rel="noopener">这里</a>，下载完成后，直接解析即可开始我们的探究之旅。关于版本，这里需要做一点说明的是，elasticsearch总共有三个大版本，即1XX、2XX和5XX三个，我们这里使用的是最新的版本<code>5.6.1</code>进行学习<br>解压完成后，我们进入<code>bin</code>目录下，点击<code>elasticsearch.bat</code>即可运行。在成功运行后，我们通过浏览器访问<a href="http://localhost:9200/" target="_blank" rel="noopener">http://localhost:9200/</a>得到json格式的数据，即说明我们的elasicsearch成功安装并运行了。如果你在这里失败了，可能因素很多，有可能是你电脑里的java环境问题（没有java环境、java版本低于8等等），也有可能是你的电脑内存啥的太小了（一般不会出现在自己的电脑上，不过我将他部署在腾讯云上时跑不起来就是因为内存太小了）。失败的解决方案就不多介绍了，我们继续往下走。</p>
<h2 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h2><p>通过前面我们的测试安装，我们发现elasticsearch给我们返回的是json格式的数据，并不是很直观，这里我们通过安装一个叫做<code>elasticsearch-head-master</code>的插件，使得我们能更加直观的看到elasticsearch给我们返回的数据。<br>这个插件的github地址在<a href="https://github.com/zt1115798334/elasticsearch-head-master" target="_blank" rel="noopener">这里</a><br>，我们可以通过他的github地址来学习如何安装和使用。</p>
<ol>
<li>首先肯定是将这个插件下载下来，在github下载资料对你来说应该是很简单了，这里就不赘述了，例如我们可以这样下载：<code>git clone git://github.com/mobz/elasticsearch-head.git</code></li>
<li>进入下载并解压好的源代码的目录。</li>
<li>输入 <code>npm install</code>，安装必要的资源。</li>
<li>通过<code>npm run start</code>来启动插件</li>
<li>在浏览器中打开<a href="http://localhost:9100/" target="_blank" rel="noopener">http://localhost:9100/</a>来测试是否正常打开。<br>能正常打开之后，这里时候我们发现elasticsearch和我们head并没有联系到一起，这里因为这两个都运行在独立的进程中，他们之间的访问存在跨域问题，这里时候我们需要进行一个简单的配置才能将这个插件真正运行起来。首先我们需要在<code>elasticsearch</code>目录下，找到<code>config</code>目录，然后再<code>config</code>中找到<code>elasticsearch.yml</code>文件，在这里文件的最后，添加下面的两行代码：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http.cors.enabled: true</span><br><span class="line">http.cors.allow-origin: &quot;*&quot;</span><br></pre></td></tr></table></figure>
保存，退出后，将elasticsearch和head-master都重启后，重新访问<a href="http://localhost:9100/" target="_blank" rel="noopener">http://localhost:9100/</a>就会发现，此时我们的集群已经链接。这里时候我们就可以继续探索了。</li>
</ol>
<h2 id="分布式安装"><a href="#分布式安装" class="headerlink" title="分布式安装"></a>分布式安装</h2><p>上面的我们的安装属于单利安装，elasticsearch也支持分布式安装。下面介绍一下分布式安装。首先，我们制定一个msater，即为集群的指挥官。还是在之前的节点配置文件下，修改<code>elasticsearch.yml</code>文件中的内容，主要就是在末尾添加如下的配置文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cluster.name: reoger    # 指定集群的名字</span><br><span class="line">node.name: msater       # 对master取名</span><br><span class="line">node.master: true       #指定他为master</span><br><span class="line">network.host: 127.0.0.1 # 绑定ip</span><br></pre></td></tr></table></figure>
<p>修改上面的配置重启后，我们再次访问<a href="http://localhost:9100/" target="_blank" rel="noopener">http://localhost:9100/</a>就可以发现集群的名字已经修改为我们配置的名字。<br>然后，我们再来添加其他的集群。步骤也很简单，我们将之前下载好的<code>elasticsearch</code>复制一份，然后修改其中的<code>elasticsearch.yml</code>文件，添加如下的配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cluster.name: reoger                            # 指定集群名气，需要和master指定的一致</span><br><span class="line">node.name: slave1                               # 指定服务节点的名字</span><br><span class="line"></span><br><span class="line">network.host: 127.0.0.1                         # 指定本地ip</span><br><span class="line">http.port: 8200                                 # 指定端口号</span><br><span class="line"></span><br><span class="line">discovery.zen.ping.unicast.hosts: [&quot;127.0.0.1&quot;] # 发现msater的</span><br></pre></td></tr></table></figure>
<p>然后通过<code>./bin/elasticsearch</code>启动后，通过浏览<a href="http://localhost:9100/" target="_blank" rel="noopener">http://localhost:9100/</a>，就会发现我们已经添加了两个集群了。如图：<br><img src="http://ovec6nnof.bkt.clouddn.com/2017-09-28_133458.jpg" alt="分布式安装效果图"></p>
<h2 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h2><p>在创建索引之前，很有必要对elasticsearch中的基本概念进行一个简单的了解。<br>一句话理解就是：Elasticsearch集群可以包含多个<strong>索引</strong>(indices)（数据库），每一个索引可以包含多个<strong>类型</strong>(types)（表），每一个类型包含多个<strong>文档</strong>(documents)（行），然后每个文档包含多个<strong>字段</strong>(Fields)（列）。</p>
<p>下面我们就来创建索引：<br><strong>结构化创建</strong><br>方法一、通过head-master创建<br>为了使创建索引比较直观，我们可以直接通过head-master插件来完成，具体我们可以访问<a href="http://localhost:9100/" target="_blank" rel="noopener">http://localhost:9100/</a>,查看我们集群的状况，然后选择索引 -&gt; 新建索引，如图所示：</p>
<p>稍等片刻之后就会提示我们索引创建成功，然后在集群概览中就可以看到我们之前添加的索引。<br>然后选择复合查询，在查询创建我们的索引。json示例代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;novel&quot;: &#123;</span><br><span class="line">    &quot;properties&quot;: &#123;</span><br><span class="line">      &quot;title&quot;: &#123;</span><br><span class="line">        &quot;type&quot;: &quot;text&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如图：<br><img src="http://ovec6nnof.bkt.clouddn.com/%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95.jpg" alt="利用head-master常见索引"> </p>
<p>验证我们是否添加成功，可以在``概览 -&gt; 信息 -&gt; 索引信息 。<br>如图：<br><img src="http://ovec6nnof.bkt.clouddn.com/%E6%95%88%E6%9E%9C%E5%B1%95%E7%A4%BA.jpg" alt="效果展示"><br>我们可以明显的看出来，我们已经在mapppings中添加了novel这么一个索引。</p>
<p>当然，通过head-master编写不是很直观，我们可以通过更加方便的工具postMan来实现上述功能。<br>示例操作：<br>我们需要通过<code>put</code>请求<code>127.0.0.1:9200/people</code>其中的people是我们要创建的索引，然后通过我们上传的json文件对创建的索引进行说明。<br>例如上传的的json代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&quot;settings&quot;:&#123;</span><br><span class="line">		&quot;number_of_shards&quot;:3,</span><br><span class="line">		&quot;number_of_replicas&quot;:1</span><br><span class="line">	&#125;,</span><br><span class="line">	&quot;mappings&quot;:&#123;</span><br><span class="line">		&quot;man&quot;:&#123;</span><br><span class="line">			&quot;properties&quot;:&#123;</span><br><span class="line">				&quot;name&quot;:&#123;</span><br><span class="line">					&quot;type&quot;:&quot;text&quot;</span><br><span class="line">				&#125;,</span><br><span class="line">				&quot;country&quot;:&#123;</span><br><span class="line">					&quot;type&quot;:&quot;keyword&quot;</span><br><span class="line">				&#125;,</span><br><span class="line">				&quot;age&quot;:&#123;</span><br><span class="line">					&quot;type&quot;:&quot;integer&quot;</span><br><span class="line">				&#125;,</span><br><span class="line">				&quot;data&quot;:&#123;</span><br><span class="line">					&quot;type&quot;:&quot;date&quot;,</span><br><span class="line">					&quot;format&quot;: &quot;yyyy-MM-dd HH:mm:ss||yyy-MM-dd||epoch_millis&quot;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;,</span><br><span class="line">		&quot;woman&quot;:&#123;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>表示的是常见的people<br>验证方法和之前的一样。</p>
<p><strong>非结构化创建</strong></p>
<h2 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h2><h3 id="指定文档ID插入"><a href="#指定文档ID插入" class="headerlink" title="指定文档ID插入"></a>指定文档ID插入</h3><p>我们这里仅用postman做示例：<br><img src="http://ovec6nnof.bkt.clouddn.com/%E6%8C%87%E5%AE%9A%E6%96%87%E6%A1%A3ID%E6%8F%92%E5%85%A5.jpg" alt="指定文档ID插入"></p>
<h3 id="不指定文档ID插入"><a href="#不指定文档ID插入" class="headerlink" title="不指定文档ID插入"></a>不指定文档ID插入</h3><p><img src="http://ovec6nnof.bkt.clouddn.com/%E4%B8%8D%E6%8C%87%E5%AE%9AID%E6%8F%92%E5%85%A5.jpg" alt="不指定文档插入"><br>可以看到，指定文档ID插入我们需要使用put请求方式，并且需要指定文档ID。而不指定文档ID插入则使用post请求方式，并且不需要知道哪个文档ID。</p>
<p>验证是否添加成功，在数据浏览中就可以看到我们插入的数据：<br><img src="http://ovec6nnof.bkt.clouddn.com/%E9%AA%8C%E8%AF%81%E6%8F%92%E5%85%A5%E6%98%AF%E5%90%A6%E6%88%90%E5%8A%9F.jpg" alt="验证文档是否添加成功"></p>
<h2 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h2><p>修改数据很简单，</p>
<h3 id="直接修改文档"><a href="#直接修改文档" class="headerlink" title="直接修改文档"></a>直接修改文档</h3><p><img src="http://ovec6nnof.bkt.clouddn.com/%E4%BF%AE%E6%94%B9%E6%96%87%E6%A1%A3.jpg" alt="直接修改文档"></p>
<h3 id="脚本修改文档"><a href="#脚本修改文档" class="headerlink" title="脚本修改文档"></a>脚本修改文档</h3><p>保持要访问的地址和方式不变，将上传的json格式修改为下面的内容，即修改为script的关键字。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&quot;script&quot;:&#123;</span><br><span class="line">		&quot;lang&quot;:&quot;painless&quot;,</span><br><span class="line">		&quot;inline&quot;:&quot;ctx._source.age+&#x3D;10&quot;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者我们也可以这么写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&quot;script&quot;:&#123;</span><br><span class="line">		&quot;lang&quot;:&quot;painless&quot;,</span><br><span class="line">		&quot;inline&quot;:&quot;ctx._source.age&#x3D;params.age&quot;,</span><br><span class="line">		&quot;params&quot;:&#123;</span><br><span class="line">			&quot;age&quot;:100</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><h3 id="删除文档"><a href="#删除文档" class="headerlink" title="删除文档"></a>删除文档</h3><p>删除文档很简单，只需要简单的通过DELETE方式访问制定ID文档即可删除。<br>例如我们想删除man索引中文档ID为1的文档，我们通过DELETE方式访问即可。<br><code>127.0.0.1:9200/people/man/1</code></p>
<h3 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h3><p>删除索引非常危险，因为删除索引后，索引里面所有的内容都将被删除！！！如果我们确定我们需要删除的话，可以通过head-master来实现。<br>具体可以选择相应的索引 -&gt; 动作 -&gt; 删除索引 -&gt; 输入删除 -&gt; 成功删除。</p>
<p>或者我们直接通过delete进行访问，例如想要删除people这个索引，我们只需要通过delete方式访问<code>127.0.0.1:9200/people/</code>即可删除。</p>
<h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><h3 id="简单查询"><a href="#简单查询" class="headerlink" title="简单查询"></a>简单查询</h3><p>直接通过文档进行查询，请求方式：GET<br>例如我想查询在people索引中，类型为man，文档ID为1的文档信息的话，直接访问：<br><code>127.0.0.1:9200/people/man/1</code>即可。</p>
<h3 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h3><p>大多数情况下，简单查询不能满足我们的需求，这个时候我们就可以通过条件查询来满足我们复杂的需求。<br>如果我们需要查询people索引下所有的文档，可以通过<strong>post方法</strong>访问<code>127.0.0.1:9200/people/_search</code>，并将body的内容设置为如下的内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&quot;query&quot;:&#123;</span><br><span class="line">		&quot;match_all&quot;:&#123;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，大多数情况我们是需要按条件查询，下面是按条件查询的示例json请求格式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&quot;query&quot;:&#123;                         &#x2F;&#x2F;注意 这里是query关键字</span><br><span class="line">		&quot;match&quot;:&#123;                     &#x2F;&#x2F;要查询的的条件</span><br><span class="line">			&quot;country&quot;:&quot;Test&quot;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	&quot;sort&quot;:[                            &#x2F;&#x2F;查询结果后的排序</span><br><span class="line">		&#123;&quot;date&quot;: &#123;&quot;order&quot;:&quot;desc&quot;&#125;&#125;      &#x2F;&#x2F; 倒叙排序</span><br><span class="line">		]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="聚合查询"><a href="#聚合查询" class="headerlink" title="聚合查询"></a>聚合查询</h3><p>聚合查询，简单来说就是将要查询的数据组合到一起，进而汇总来自多行的信息。<br>例如，我想查询people中，年龄相同的聚合信息，查询的方式仍然是post，访问的地址仍然是<code>127.0.0.1:9200/people/_search</code>，不同的发送的json数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&quot;aggs&quot;:&#123;					&#x2F;&#x2F;关键字</span><br><span class="line">		&quot;group_by_word_age&quot;:&#123;  	&#x2F;&#x2F;自定义聚合的名字</span><br><span class="line">			&quot;terms&quot;:&#123;			&#x2F;&#x2F;关键字</span><br><span class="line">				&quot;field&quot;: &quot;age&quot;	&#x2F;&#x2F;聚合的字段名称</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;,</span><br><span class="line">		&quot;group_by_data&quot;:&#123;		&#x2F;&#x2F;自定义聚合的名字</span><br><span class="line">			&quot;terms&quot;:&#123;			&#x2F;&#x2F;关键字</span><br><span class="line">				&quot;field&quot;: &quot;date&quot; &#x2F;&#x2F;聚合字段的名称</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我这里返回的信息为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">....,</span><br><span class="line">    &quot;aggregations&quot;: &#123;</span><br><span class="line">        &quot;group_by_data&quot;: &#123;</span><br><span class="line">            &quot;doc_count_error_upper_bound&quot;: 0,</span><br><span class="line">            &quot;sum_other_doc_count&quot;: 0,</span><br><span class="line">            &quot;buckets&quot;: [</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;key&quot;: 923443200000,</span><br><span class="line">                    &quot;key_as_string&quot;: &quot;1999-04-07T00:00:00.000Z&quot;,</span><br><span class="line">                    &quot;doc_count&quot;: 2</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;key&quot;: -1916697600000,</span><br><span class="line">                    &quot;key_as_string&quot;: &quot;1909-04-07T00:00:00.000Z&quot;,</span><br><span class="line">                    &quot;doc_count&quot;: 1</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;group_by_word_age&quot;: &#123;</span><br><span class="line">            &quot;doc_count_error_upper_bound&quot;: 0,</span><br><span class="line">            &quot;sum_other_doc_count&quot;: 0,</span><br><span class="line">            &quot;buckets&quot;: [</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;key&quot;: 28,</span><br><span class="line">                    &quot;doc_count&quot;: 3</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，我们不但可以通过<code>terms</code>查询字段的聚合信息，还可以通过<code>status</code>、<code>min</code>、<code>max</code>等关键字查询字段的状态信息。</p>
<p>最后，补充一点就是，如果想通过ip地址访问的话，需要修改<code>elasticsearch.yml</code>文件中的<code>network.host:</code>为我们指定的Ip字段。<br>暂时先写这么吧<del>~</del></p>
<hr>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://es.xiaoleilu.com/" target="_blank" rel="noopener">Elasticsearch权威指南（中文版）</a></li>
<li><a href="https://www.elastic.co/cn/" target="_blank" rel="noopener">elasticsearch官方网站</a></li>
<li><a href="http://www.imooc.com/video/15762" target="_blank" rel="noopener">慕课网上的教学视频</a></li>
<li><a href="http://www.sojson.com/tag_elasticsearch_3.html" target="_blank" rel="noopener">soJson博客</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://reoger.tk/2017/09/06/java/java%E7%9F%A5%E8%AF%86%E7%82%B9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="reoger">
      <meta itemprop="description" content="reoger">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="reoger的记录">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/09/06/java/java%E7%9F%A5%E8%AF%86%E7%82%B9/" class="post-title-link" itemprop="url">java知识点</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-09-06 22:19:31" itemprop="dateCreated datePublished" datetime="2017-09-06T22:19:31+08:00">2017-09-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-07-18 13:38:32" itemprop="dateModified" datetime="2020-07-18T13:38:32+08:00">2020-07-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="面相对象的特征？"><a href="#面相对象的特征？" class="headerlink" title="面相对象的特征？"></a>面相对象的特征？</h1><p>抽象、继承、封装、多态。<br>抽象：将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行为抽象两方面。<br>继承：从已有类得到继承信息创建新类的过程，<br>封装：把数据和操作数据的方法绑定起来，对数据的访问只能通过已定义的接口。<br>多态：允许不同子类型的对象对同一消息做出不同响应，多态分为编译时多态和运行时多态。</p>
<h1 id="String属于基本的数据结构吗？"><a href="#String属于基本的数据结构吗？" class="headerlink" title="String属于基本的数据结构吗？"></a>String属于基本的数据结构吗？</h1><p>不是。Java中的基本数据类型只有8个：byte、short、int、long、float、char、boolean；<br>除了基本类型和枚举类型，剩下的都是引用类型。</p>
<h1 id="float-f-3-4-是否正确？"><a href="#float-f-3-4-是否正确？" class="headerlink" title="float f = 3.4;是否正确？"></a>float f = 3.4;是否正确？</h1><p>错误，3.4是双精度数，将双精度赋值给单精度属于向下转型，会造成精度损失。因此需要强制转换。</p>
<h1 id="String和StringBuilder、StringBuffer的区别？"><a href="#String和StringBuilder、StringBuffer的区别？" class="headerlink" title="String和StringBuilder、StringBuffer的区别？"></a>String和StringBuilder、StringBuffer的区别？</h1><p>Java平台提供了两种类型的字符串：String和StringBuffer/StringBuilder，它们可以储存和操作字符串。其中String是只读字符串，也就意味着String引用的字符串内容是不能被改变的。而StringBuffer/StringBuilder类表示的字符串对象可以直接进行修改。StringBuilder是Java 5中引入的，它和StringBuffer的方法完全相同，区别在于它是在单线程环境下使用的，因为它的所有方面都没有被synchronized修饰，因此它的效率也比StringBuffer要高。</p>
<h1 id="int和Integer有什么区别？"><a href="#int和Integer有什么区别？" class="headerlink" title="int和Integer有什么区别？"></a>int和Integer有什么区别？</h1><p>Integer是int的包装类，int是基本类型，integer是对象。使用intent值得注意的一点是，如果integer整型字面量的值在-128到127之间，那么不会new新的Integer对象，而是直接引用常量池中的Integer对象。例如题目：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">    &#x2F;&#x2F; TODO Auto-generated method stub</span><br><span class="line">    Integer f1 &#x3D; 100, f2 &#x3D; 100, f3 &#x3D; 150, f4 &#x3D; 150;</span><br><span class="line">    int f &#x3D; 100;</span><br><span class="line">    System.out.println(f1 &#x3D;&#x3D; f2);</span><br><span class="line">    System.out.println(f3 &#x3D;&#x3D; f4);</span><br><span class="line">    System.out.println(f &#x3D;&#x3D; f1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出的结果应该为 true，false，true；原因上面已经说过了。</p>
<h1 id="内存中的栈（stack）、堆（heap）和静态区（static-area），方法区的作用。"><a href="#内存中的栈（stack）、堆（heap）和静态区（static-area），方法区的作用。" class="headerlink" title="内存中的栈（stack）、堆（heap）和静态区（static area），方法区的作用。"></a>内存中的栈（stack）、堆（heap）和静态区（static area），方法区的作用。</h1><p>栈用于存放基本的数据类型、对象的引用和函数调用的现场保护等；<br>堆用于存放new关键字和构造器创建的对象；<br>静态区用于存放程序中的字面量，如直接书写100，”hello”和常量。<br>如语句： String str = new String(“hello”);<br>上面的语句中变量str放在栈上，用new创建出来的字符串对象放在堆上，而”hello”这个字面量放在静态区。<br>方法区：存放class二进制文件，包含类信息，静态变量，常量池，类的版本号等基本信息。方法区是各个线程共享的内存区域，用于存储class的二进制文件。</p>
<h1 id="7-构造器（construction）是否可以被重写（overrider）？"><a href="#7-构造器（construction）是否可以被重写（overrider）？" class="headerlink" title="7.    构造器（construction）是否可以被重写（overrider）？"></a>7.    构造器（construction）是否可以被重写（overrider）？</h1><p>构造器不能被继承，因此不能被重写，但可以被重载。</p>
<h1 id="8-两个对象值相同-x-equals-y-true-那么他们的hashCode相同吗？"><a href="#8-两个对象值相同-x-equals-y-true-那么他们的hashCode相同吗？" class="headerlink" title="8.    两个对象值相同( x.equals(y) == true ),那么他们的hashCode相同吗？"></a>8.    两个对象值相同( x.equals(y) == true ),那么他们的hashCode相同吗？</h1><p>相同。在java中，hashCode值相同，他们并不一定相同（equals方法返回true），但是两个对象相同，他们的hasdCode一定相同。</p>
<h1 id="9-重载（Overload）和重写（Override）的区别。"><a href="#9-重载（Overload）和重写（Override）的区别。" class="headerlink" title="9.    重载（Overload）和重写（Override）的区别。"></a>9.    重载（Overload）和重写（Override）的区别。</h1><p>方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态。重载发生在一个类中，同名的方法如果有不同的参数，则为重载；重写发生在子类和父类之间，重写要求子类被重写方法的与父类被重写的方法有相同的返回类型，方法名和参数；重载对返回类型则没有特殊的要求。</p>
<h1 id="10-JVM加载class文件的原理机制？"><a href="#10-JVM加载class文件的原理机制？" class="headerlink" title="10.   JVM加载class文件的原理机制？"></a>10.   JVM加载class文件的原理机制？</h1><p>JVM中类的装载是由类加载器（ClassLoader）和它的子类来实现的，Java中的类加载器是一个重要的Java运行时系统组件，它负责在运行时查找和装入类文件中的类。<br>由于Java的跨平台性，经过编译的Java源程序并不是一个可执行程序，而是一个或多个类文件。当Java程序需要使用某个类时，JVM会确保这个类已经被加载、连接（验证、准备和解析）和初始化。类的加载是指把类的.class文件中的数据读入到内存中，通常是创建一个字节数组读入.class文件，然后产生与所加载类对应的Class对象。加载完成后，Class对象还不完整，所以此时的类还不可用。当类被加载后就进入连接阶段，这一阶段包括验证、准备（为静态变量分配内存并设置默认的初始值）和解析（将符号引用替换为直接引用）三个步骤。最后JVM对类进行初始化，包括：1)如果类存在直接的父类并且这个类还没有被初始化，那么就先初始化父类；2)如果类中存在初始化语句，就依次执行这些初始化语句。<br>类的加载是由类加载器完成的，类加载器包括：根加载器（BootStrap）、扩展加载器（Extension）、系统加载器（System）和用户自定义类加载器（java.lang.ClassLoader的子类）。从Java 2（JDK 1.2）开始，类加载过程采取了父亲委托机制（PDM）。PDM更好的保证了Java平台的安全性，在该机制中，JVM自带的Bootstrap是根加载器，其他的加载器都有且仅有一个父类加载器。类的加载首先请求父类加载器加载，父类加载器无能为力时才由其子类加载器自行加载。JVM不会向Java程序提供对Bootstrap的引用。下面是关于几个类加载器的说明：</p>
<ul>
<li>Bootstrap：一般用本地代码实现，负责加载JVM基础核心类库（rt.jar）；</li>
<li>Extension：从java.ext.dirs系统属性所指定的目录中加载类库，它的父加载器是Bootstrap；</li>
<li>System：又叫应用类加载器，其父类是Extension。它是应用最广泛的类加载器。它从环境变量classpath或者系统属性java.class.path所指定的目录中记载类，是用户自定义加载器的默认父加载器。</li>
</ul>
<h1 id="11-char-型变量中能不能存贮一个中文汉字。"><a href="#11-char-型变量中能不能存贮一个中文汉字。" class="headerlink" title="11.   char 型变量中能不能存贮一个中文汉字。"></a>11.   char 型变量中能不能存贮一个中文汉字。</h1><p>char类型可以存储一个中文汉字，因为Java中使用的编码是Unicode（不选择任何特定的编码，直接使用字符在字符集中的编号，这是统一的唯一方法），一个char类型占2个字节（16比特），所以放一个中文是没问题的。</p>
<h1 id="12-抽象类（abstract）和接口（interface）有什么异同？"><a href="#12-抽象类（abstract）和接口（interface）有什么异同？" class="headerlink" title="12.   抽象类（abstract）和接口（interface）有什么异同？"></a>12.   抽象类（abstract）和接口（interface）有什么异同？</h1><p>抽象类和接口类都不能够实例化，但可以定义抽象类和接口类型的引用。一个类如果继承了某个抽象类或者实现了某个接口都需要对其中的抽象方法全部进行实现，否则该类仍然需要被声明为抽象类。<br>接口比抽象类更加抽象，因为抽象类中可以定义构造器，可以有抽象方法和具体方法，而接口中不能定义构造器而且其中的方法全部是抽象方法。<br>抽象类中的成员可以定义成员变量、而接口中定义的成员变量实际上都是常量。有抽象方法的类必须被声明为抽象类，而抽象类未必有抽象方法。<br>抽象类中的成员可以是private、protected、public的，而接口中的成员全部都是public。</p>
<h1 id="13-静态嵌套类-Static-Nested-Class-和内部类（Inner-Class）的不同？"><a href="#13-静态嵌套类-Static-Nested-Class-和内部类（Inner-Class）的不同？" class="headerlink" title="13.   静态嵌套类(Static Nested Class)和内部类（Inner Class）的不同？"></a>13.   静态嵌套类(Static Nested Class)和内部类（Inner Class）的不同？</h1><p>Static Nested Class是被声明为静态（static）的内部类，它可以不依赖于外部类实例被实例化。而通常的内部类需要在外部类实例化后才能实例化。要在静态方法中创建内部类对象，可以这样做：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new Outer().new Inner();</span><br></pre></td></tr></table></figure>

<h1 id="14-静态变量和实例变量的区别。"><a href="#14-静态变量和实例变量的区别。" class="headerlink" title="14.   静态变量和实例变量的区别。"></a>14.   静态变量和实例变量的区别。</h1><p>静态变量是被static修饰符修饰的变量，也称为类变量，它属于类，不属于类的任何一个对象，一个类不管创建多少个对象，静态变量在内存中有且仅有一个拷贝；实例变量必须依存于某一实例，需要先创建对象然后通过对象才能访问到它。静态变量可以实现让多个对象共享内存。</p>
<h1 id="15-接口是否可继承接口？抽象类是否可实现接口？抽象类是否可继承具体类？"><a href="#15-接口是否可继承接口？抽象类是否可实现接口？抽象类是否可继承具体类？" class="headerlink" title="15.   接口是否可继承接口？抽象类是否可实现接口？抽象类是否可继承具体类？"></a>15.   接口是否可继承接口？抽象类是否可实现接口？抽象类是否可继承具体类？</h1><p>接口可以继承接口，而且支持多重继承。抽象类可以实现(implements)接口，抽象类可继承具体类也可以继承抽象类。</p>
<h1 id="16-Throw和throws有什么区别？"><a href="#16-Throw和throws有什么区别？" class="headerlink" title="16.   Throw和throws有什么区别？"></a>16.   Throw和throws有什么区别？</h1><p>throws是方法可能抛出异常的声明。用在方法方法函数头，表示抛出异常。throws表示出现异常的一种可能性，并不一定会发生这些异常；<br>throw是语句抛出一个异常。用在方法里，表示抛出了一个实实在在的异常，他必须要被处理。</p>
<h1 id="17-final、finally、finalize的区别。"><a href="#17-final、finally、finalize的区别。" class="headerlink" title="17.   final、finally、finalize的区别。"></a>17.   final、finally、finalize的区别。</h1><ul>
<li>final：修饰符（关键字）有三种用法：如果一个类被声明为final，意味着它不能再派生出新的子类，即不能被继承，因此它和abstract是反义词。将变量声明为final，可以保证它们在使用中不被改变，被声明为final的变量必须在声明时给定初值，而在以后的引用中只能读取不可修改。被声明为final的方法也同样只能使用，不能在子类中被重写。</li>
<li>finally：通常放在try…catch…的后面构造总是执行代码块，这就意味着程序无论正常执行还是发生异常，这里的代码只要JVM不关闭都能执行，可以将释放外部资源的代码写在finally块中。</li>
<li>finalize：Object类中定义的方法，Java中允许使用finalize()方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收集器在销毁对象时调用的，通过重写finalize()方法可以整理系统资源或者执行其他清理工作。</li>
</ul>
<h1 id="18-Collection和Collections的区别？"><a href="#18-Collection和Collections的区别？" class="headerlink" title="18.   Collection和Collections的区别？"></a>18.   Collection和Collections的区别？</h1><p>Collection是一个接口，它是Set、List等容器的父接口；Collections是个一个工具类，提供了一系列的静态方法来辅助容器操作，这些方法包括对容器的搜索、排序、线程安全化等等。</p>
<h1 id="19-List、Set、Map是否继承自Collection接口？"><a href="#19-List、Set、Map是否继承自Collection接口？" class="headerlink" title="19.   List、Set、Map是否继承自Collection接口？"></a>19.   List、Set、Map是否继承自Collection接口？</h1><p>List、Set 是，Map 不是。Map是键值对映射容器，与List和Set有明显的区别，而Set存储的零散的元素且不允许有重复元素（数学中的集合也是如此），List是线性结构的容器，适用于按数值索引访问元素的情形。</p>
<h1 id="20-Sleep-方法和wait-方法有什么异同？"><a href="#20-Sleep-方法和wait-方法有什么异同？" class="headerlink" title="20.   Sleep()方法和wait()方法有什么异同？"></a>20.   Sleep()方法和wait()方法有什么异同？</h1><p>相同：都可以让线程处理冻结状态。<br>不同点：sleep()是Thread类中定义的方法，wait()是Object类中定义的方法；<br>            Sleep()必须指定时间，而wait()可以指定也可不指定；<br>            Sleep()不会释放锁，而wait()释放锁；<br>            Sleep()需要捕获异常，而wait()只能在(synchronized)环境中使用。<br>Sleep()睡眠后不出让系统资源，wait让出系统资源其他线程可以占用CPU</p>
<h1 id="21-抽象的（abstract）方法是否可以同时是静态的（static），是否可同时是本地方法（native），是否可同时被synchronized修饰？"><a href="#21-抽象的（abstract）方法是否可以同时是静态的（static），是否可同时是本地方法（native），是否可同时被synchronized修饰？" class="headerlink" title="21.   抽象的（abstract）方法是否可以同时是静态的（static），是否可同时是本地方法（native），是否可同时被synchronized修饰？"></a>21.   抽象的（abstract）方法是否可以同时是静态的（static），是否可同时是本地方法（native），是否可同时被synchronized修饰？</h1><p>都不能。抽象方法需要子类重写，而静态的方法是无法重写的，因此二者是矛盾的。本地方法是由本地代码（如c/c++）实现的方法，而抽象方法是没有实现的，也是矛盾的。Synchronied和方法的实现细节有关，抽象方法不涉及实现细节，因此也是相互矛盾的。</p>
<h1 id="22-Error和Exception有什么区别？"><a href="#22-Error和Exception有什么区别？" class="headerlink" title="22.   Error和Exception有什么区别？"></a>22.   Error和Exception有什么区别？</h1><p>Error表示系统级的错误和程序不必处理的异常，是恢复不是不可能但很困难的情况下的一种严重问题；比如内存溢出，不可能指望程序能处理这样的情况；<br>Exception表示需要捕捉或者需要程序进行处理的异常，是一种设计或实现问题。也就是说，他表示如果程序运行正常，从不会发生的情况。</p>
<h1 id="23-多线程编程有几种实现方式？"><a href="#23-多线程编程有几种实现方式？" class="headerlink" title="23.   多线程编程有几种实现方式？"></a>23.   多线程编程有几种实现方式？</h1><p>Java 5以前实现多线程有两种实现方法：一种是继承Thread类；另一种是实现Runable接口。两种方式都要重写run()方法来定义线程的行为，推荐使用后者，因为java中的继承是单继承，显然接口更加灵活。</p>
<h1 id="24-Thread类中的start-和run-方法有什么区别？"><a href="#24-Thread类中的start-和run-方法有什么区别？" class="headerlink" title="24.   Thread类中的start()和run()方法有什么区别？"></a>24.   Thread类中的start()和run()方法有什么区别？</h1><p>Start()方法被用来启动新创建的线程，而且start()内部调用了run()方法，这和直接调用run()方法的效果不一样。当你调用run()方法的时候，只会是在原来的线程中调用，没有在新的线程中调用，没有新的线程启动，start()方法才会启动新的线程。</p>
<h1 id="25-Java中的volatile-变量是什么？"><a href="#25-Java中的volatile-变量是什么？" class="headerlink" title="25.   Java中的volatile 变量是什么？"></a>25.   Java中的volatile 变量是什么？</h1><p>volatile是一个特殊的修饰符，只有成员变量才能使用它。在Java并发程序缺少同步类的情况下，多线程对成员变量的操作对其它线程是透明的。volatile变量可以保证下一个读取操作会在前一个写操作之后发生。</p>
<h1 id="26-什么是ThreadLocal变量？"><a href="#26-什么是ThreadLocal变量？" class="headerlink" title="26.   什么是ThreadLocal变量？"></a>26.   什么是ThreadLocal变量？</h1><p>ThreadLocal是Java里一种特殊的变量。每个线程都有一个ThreadLocal就是每个线程都拥有了自己独立的一个变量，竞争条件被彻底消除了。它是为创建代价高昂的对象获取线程安全的好方法，比如你可以用ThreadLocal让SimpleDateFormat变成线程安全的，因为那个类创建代价高昂且每次调用都需要创建不同的实例所以不值得在局部范围使用它，如果为每个线程提供一个自己独有的变量拷贝，将大大提高效率。首先，通过复用减少了代价高昂的对象的创建个数。其次，你在没有使用高代价的同步或者不变性的情况下获得了线程安全。线程局部变量的另一个不错的例子是ThreadLocalRandom类，它在多线程环境中减少了创建代价高昂的Random对象的个数。 当然，可以参考《android艺术探索》P375 了解ThreadLocal原理。</p>
<h1 id="27-有三个线程，怎么确保他们顺序执行？"><a href="#27-有三个线程，怎么确保他们顺序执行？" class="headerlink" title="27.   有三个线程，怎么确保他们顺序执行？"></a>27.   有三个线程，怎么确保他们顺序执行？</h1><p> 在多线程中有多种方法让线程按特定顺序执行，你可以用线程类的join()方法在一个线程中启动另一个线程，另外一个线程完成线程继续执行；<br>你也可以用java中的锁机制（ReentrantLock、或者newCondition），在一个线程执行的时候，让他占有锁，线程执行完毕才释放锁；<br>也可以利用三个信号量来让三个线程按顺序执行，刚开始的时候设置只有第一个线程可以获取信号量，第一个线程运行完毕后释放第二个信号量，以此启动第二个线程。<br>甚至你可以将这三个线程放入线程池，利用线程池来让他们按顺序执行。<br>如果上面的讲述不是很清楚，可以参考<a href="http://www.cnblogs.com/icejoywoo/archive/2012/10/15/2724674.html" target="_blank" rel="noopener">代码</a>。</p>
<h1 id="28-Java中如何停止一个线程？"><a href="#28-Java中如何停止一个线程？" class="headerlink" title="28.   Java中如何停止一个线程？"></a>28.   Java中如何停止一个线程？</h1><p>JDK 1.0本来有一些像stop(), suspend() 和 resume()的控制方法但是由于潜在的死锁威胁因此在后续的JDK版本中他们被弃用了，之后Java API的设计者就没有提供一个兼容且线程安全的方法来停止一个线程。当run() 或者 call() 方法执行完的时候线程会自动结束。如果要手动结束一个线程，你可以用volatile 布尔变量来退出run()方法的循环或者是取消任务来中断线程；也可以使用inerrupt方法终止线程，但interrupt并不一定会终止线程，该方法只是设置了一个中断状态。当然，停止线程也可以通过return语句来实现，不过个人推荐使用异常来停止线程，因为抛出的异常可以传递线程停止的信息而通过return语句就不能传递。</p>
<h1 id="29-Switch能否用string做参数？"><a href="#29-Switch能否用string做参数？" class="headerlink" title="29.   Switch能否用string做参数？"></a>29.   Switch能否用string做参数？</h1><p>不能。在java 7以前，switch只能支持byte、short、char、int或者对应的封装类以及enum类型。在java 7中，switch支持string了，但是不支持long。</p>
<h1 id="30-Java中四种引用的区别？"><a href="#30-Java中四种引用的区别？" class="headerlink" title="30.   Java中四种引用的区别？"></a>30.   Java中四种引用的区别？</h1><p>强引用：如果一个对象具有强引用，它就不会被垃圾回收器回收。即使当前内存空间不足，JVM也不会回收它，而是抛出 OutOfMemoryError 错误，使程序异常终止。如果想中断强引用和某个对象之间的关联，可以显式地将引用赋值为null，这样一来的话，JVM在合适的时间就会回收该对象<br>软引用：在使用软引用时，如果内存的空间足够，软引用就能继续被使用，而不会被垃圾回收器回收，只有在内存不足时，软引用才会被垃圾回收器回收。<br>弱引用：具有弱引用的对象拥有的生命周期更短暂。因为当 JVM 进行垃圾回收，一旦发现弱引用对象，无论当前内存空间是否充足，都会将弱引用回收。不过由于垃圾回收器是一个优先级较低的线程，所以并不一定能迅速发现弱引用对象<br>虚引用：顾名思义，就是形同虚设，如果一个对象仅持有虚引用，那么它相当于没有引用，在任何时候都可能被垃圾回收器回收。</p>
<h1 id="31-hashMap和hashTable的区别？"><a href="#31-hashMap和hashTable的区别？" class="headerlink" title="31.   hashMap和hashTable的区别？"></a>31.   hashMap和hashTable的区别？</h1><p>hashMap是非synchronied的（即线程安全的），而hashTable是线程安全的（使用synchronied修饰，代价就是效率变低）。<br>hashMap 可以接受null（即可以将键值或者值设置为null），但是hashTable不行。<br>hashMap中hash数组默认大小是11，增加的方式是old*2+1，hashMap中hash数组的默认大小是16，而且一定是2的指数。<br>hasMap是Map接口的一个实现，而Hashtable是基于陈旧的Dictionary类，完成了Map接口；</p>
<h1 id="32-ArrayList和LinkedList的区别。"><a href="#32-ArrayList和LinkedList的区别。" class="headerlink" title="32.   ArrayList和LinkedList的区别。"></a>32.   ArrayList和LinkedList的区别。</h1><p>ArrayList的实现为动态数组，初识大小为10，大小不够会自动调用grow扩容：length = length+(length&gt;&gt;1);<br>LinkedList的实现为双向链表，没有默认的大小。</p>
<h1 id="33-amp-和-amp-amp-的区别"><a href="#33-amp-和-amp-amp-的区别" class="headerlink" title="33.   &amp;和&amp;&amp;的区别"></a>33.   &amp;和&amp;&amp;的区别</h1><ul>
<li>&amp;表示位运算与，不会短路；</li>
<li>&amp;&amp;表示逻辑运算与，在第一个条件为false的情况下会短路。</li>
</ul>
<h1 id="34-在java中如何跳出当前多重循环？"><a href="#34-在java中如何跳出当前多重循环？" class="headerlink" title="34.   在java中如何跳出当前多重循环？"></a>34.   在java中如何跳出当前多重循环？</h1><p>我们可以在外层循环添加一个标号（以”:”结束），当我们需要结束循环时，我们可以直接break +外层循环的标号;<br>  当然，我们可以在外层循环中添加一个bool值的变量，当门需要退出时，改变bool的值让外层循环停止即可。</p>
<h1 id="35-Synchronized锁对象与锁方法、代码块区别。"><a href="#35-Synchronized锁对象与锁方法、代码块区别。" class="headerlink" title="35.   Synchronized锁对象与锁方法、代码块区别。"></a>35.   Synchronized锁对象与锁方法、代码块区别。</h1><p>当synchronized锁的是对象，两个线程分别访问同一个类的同一个实例的相同方法时，他们会按照会同步执行两个类中所有被调用的方法；而当synchronized锁的是方法时，他们只会同步执行这个被锁住的方法，而当synchronized是一个代码块的时候，就意味着只有这个方法块才会同步执行。</p>
<h1 id="36-字节流和字符流的区别？"><a href="#36-字节流和字符流的区别？" class="headerlink" title="36.   字节流和字符流的区别？"></a>36.   字节流和字符流的区别？</h1><p>字节流用于读取或写出二进制数据，比如图片、影像等数据，几乎所有的数据都可以通过字节流来处理；字节流的基本单元为字节；字节流默认不使用缓存区；<br>字符流用于读取或写出字符数据，比如传输字符串；字符流的基本单元为Unicode码元；字符流默认使用缓存区；</p>
<h1 id="37-TreeMap，LinkedHashMap，HashMap的区别是什么？"><a href="#37-TreeMap，LinkedHashMap，HashMap的区别是什么？" class="headerlink" title="37.   TreeMap，LinkedHashMap，HashMap的区别是什么？"></a>37.   TreeMap，LinkedHashMap，HashMap的区别是什么？</h1><p>hashMap底层实现是散列表，因此它内存存储的元素的无序的；<br>TreeMap的底层实现是红黑树，所以它内部的元素是有序的。排序的依据是自然序或者是创建TreeMap时所提供的比较器（Comparator）对象；<br>LinkedHashMap能够记住插入元素的顺序。</p>
<h1 id="38-说说设计模式"><a href="#38-说说设计模式" class="headerlink" title="38.   说说设计模式"></a>38.   说说设计模式</h1><p>详细资料可以参考<a href="http://design-patterns.readthedocs.io/zh_CN/latest/" target="_blank" rel="noopener">这里</a>。<br>简单工厂模式：它属于类创建型模式。在简单工厂模式中，可以根据参数的不同返回不同类型的实例。简单工厂模式专门定义一个类来负责创建其他类的实例。<br><a href="https://github.com/mingjunli/JavaDesignPatterns" target="_blank" rel="noopener">https://github.com/mingjunli/JavaDesignPatterns</a></p>
<h1 id="39-int-char-long在java中各占多少字节？"><a href="#39-int-char-long在java中各占多少字节？" class="headerlink" title="39.   int-char-long在java中各占多少字节？"></a>39.   int-char-long在java中各占多少字节？</h1><table>
<thead>
<tr>
<th>Byte</th>
<th>Short</th>
<th>Int</th>
<th>Long</th>
<th>Float</th>
<th>Double</th>
<th>Char</th>
</tr>
</thead>
<tbody><tr>
<td>位数</td>
<td>8</td>
<td>16</td>
<td>32</td>
<td>64</td>
<td>32</td>
<td>64</td>
</tr>
<tr>
<td>字节数</td>
<td>1</td>
<td>2</td>
<td>4</td>
<td>8</td>
<td>4</td>
<td>8</td>
</tr>
</tbody></table>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://reoger.tk/2017/09/02/sourceCode/okhttp%E8%A7%A3%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="reoger">
      <meta itemprop="description" content="reoger">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="reoger的记录">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/09/02/sourceCode/okhttp%E8%A7%A3%E6%9E%90/" class="post-title-link" itemprop="url">okhttp解析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-09-02 20:19:55" itemprop="dateCreated datePublished" datetime="2017-09-02T20:19:55+08:00">2017-09-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-07-18 13:47:55" itemprop="dateModified" datetime="2020-07-18T13:47:55+08:00">2020-07-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/sourceCode/" itemprop="url" rel="index"><span itemprop="name">sourceCode</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>OkHttp是一个处理网络请求的开源项目,是Android端最火热的轻量级框架,由移动支付Square公司贡献用于替代HttpUrlConnection和Apache HttpClient。随着OkHttp的不断成熟，越来越多的Android开发者使用OkHttp作为网络框架。</p>
</blockquote>
<h1 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h1><p>在真正进行源码分析之前，简单的回顾一个okhttp的简单使用。首先将okhttp继承到自己的项目中,在<code>build.gradle</code>添加如下的依赖：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compile &#39;com.squareup.okhttp3:okhttp:3.7.0&#39;</span><br></pre></td></tr></table></figure>
<p>下面是一个okhttp简单进行get请求的一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;1.拿到okhttpClient对象</span><br><span class="line">OkHttpClient okHttpClient &#x3D; new OkHttpClient();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;2. 构造request对象</span><br><span class="line">Request.Builder builder &#x3D; new Request.Builder();</span><br><span class="line">Request request &#x3D; builder.get().url(&quot;http:&#x2F;&#x2F;www.baidu.com&quot;).build();</span><br><span class="line"> &#x2F;&#x2F;3. 构建Call对象</span><br><span class="line">okhttp3.Call call &#x3D; okHttpClient.newCall(request);</span><br><span class="line">&#x2F;&#x2F;4.执行</span><br><span class="line">&#x2F;&#x2F;同步执行 call.execute();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;异步执行</span><br><span class="line">call.enqueue(new Callback() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onFailure(okhttp3.Call call, IOException e) &#123;</span><br><span class="line">       &#x2F;&#x2F;失败的回调</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void onResponse(okhttp3.Call call, Response response) throws IOException &#123;</span><br><span class="line">        &#x2F;&#x2F;成功的回调</span><br><span class="line">        final String repo &#x3D; response.body().string();</span><br><span class="line">        Log.d(&quot;TAG&quot;,repo+&quot; &quot;);</span><br><span class="line">        runOnUiThread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                mText.setText(repo);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面的代码用okhttp实现了一个简单的网络请求，主要由四步组成。关于okhttp更多的用法请参考<a href="http://blog.csdn.net/reoger/article/details/70953609" target="_blank" rel="noopener">博客</a>。对上面的okhttp中常用的类做一个简单的介绍：</p>
<ol>
<li><strong>OkHttpClient</strong> 可以理解用户面板，发送的网络请求都是通过他来实现的，每个<code>OkhttpClient</code>都在内部都维护了属于自己的任务队列，连接池，Cache，拦截器等，所以在使用<code>OkHttp</code>作为网络框架时应该全局共享一个<code>OkHttpClient</code>实例。</li>
<li><strong>Request</strong> 可以理解为用户发送的请求。</li>
<li><strong>Response</strong> 是响应是对请求的回复，包含状态码、HTTP头和主体部分。</li>
<li><strong>Call</strong> 描述一个实际的访问请求，用户的每一个网络请求都是一个Call实例。</li>
</ol>
<hr>
<p>下面将对上面的四步一步一步来进行分析，并探究其源码的实现。</p>
<h1 id="创建okhttpClient对象"><a href="#创建okhttpClient对象" class="headerlink" title="创建okhttpClient对象"></a>创建okhttpClient对象</h1><p>关于<code>okhttpClient</code>对象，在上面已经进行了一个简单的解释，那么他为甚是这个样子的，下面通过源码来验证。下面是<code>OkHttpClient</code>类中的部分代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public OkHttpClient() &#123;</span><br><span class="line">  this(new Builder());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> public Builder() &#123;</span><br><span class="line">    dispatcher &#x3D; new Dispatcher();&#x2F;&#x2F;分发器</span><br><span class="line">    protocols &#x3D; DEFAULT_PROTOCOLS;&#x2F;&#x2F;协议</span><br><span class="line">    connectionSpecs &#x3D; DEFAULT_CONNECTION_SPECS;&#x2F;&#x2F;传输层版本和连接协议</span><br><span class="line">    eventListenerFactory &#x3D; EventListener.factory(EventListener.NONE);&#x2F;&#x2F;事件工厂</span><br><span class="line">    proxySelector &#x3D; ProxySelector.getDefault();&#x2F;&#x2F;代理选择</span><br><span class="line">    cookieJar &#x3D; CookieJar.NO_COOKIES;&#x2F;&#x2F;cookie</span><br><span class="line">    socketFactory &#x3D; SocketFactory.getDefault();&#x2F;&#x2F;socket工厂</span><br><span class="line">    hostnameVerifier &#x3D; OkHostnameVerifier.INSTANCE;&#x2F;&#x2F;主机名字确认</span><br><span class="line">    certificatePinner &#x3D; CertificatePinner.DEFAULT;&#x2F;&#x2F;证书链</span><br><span class="line">    proxyAuthenticator &#x3D; Authenticator.NONE;&#x2F;&#x2F;代理身份验证</span><br><span class="line">    authenticator &#x3D; Authenticator.NONE;&#x2F;&#x2F;本地身份验证</span><br><span class="line">    connectionPool &#x3D; new ConnectionPool();&#x2F;&#x2F;连接池，复用连接</span><br><span class="line">    dns &#x3D; Dns.SYSTEM;&#x2F;&#x2F;域名</span><br><span class="line">    followSslRedirects &#x3D; true;&#x2F;&#x2F;安全套接层重定向</span><br><span class="line">    followRedirects &#x3D; true;&#x2F;&#x2F;本地重定向</span><br><span class="line">    retryOnConnectionFailure &#x3D; true;&#x2F;&#x2F;重试连接失败</span><br><span class="line">    connectTimeout &#x3D; 10_000;&#x2F;&#x2F;连接超时时间</span><br><span class="line">    readTimeout &#x3D; 10_000;&#x2F;&#x2F;读超时</span><br><span class="line">    writeTimeout &#x3D; 10_000;&#x2F;&#x2F;写超时</span><br><span class="line">    pingInterval &#x3D; 0;&#x2F;&#x2F;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>
<p>可以看出来，直接创建的<code>OkHttpClient</code>对象并且默认构造<code>builder</code>对象进行初始化。当然，直接创建<code>OkhttpClient</code>是非常简单的，但是其中的配置就只能用默认的配置了。如果需要子的自定义配置，可以通过下面的方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">OkHttpClient  okHttpClient&#x3D; new c.Builder()</span><br><span class="line">                    .cookieJar(new CookieJar() &#123;</span><br><span class="line">                        private final HashMap&lt;HttpUrl, List&lt;Cookie&gt;&gt; cookieStore &#x3D; new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">                        @Override</span><br><span class="line">                        public void saveFromResponse(HttpUrl url, List&lt;Cookie&gt; cookies) &#123;</span><br><span class="line">                            cookieStore.put(url, cookies);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        @Override</span><br><span class="line">                        public List&lt;Cookie&gt; loadForRequest(HttpUrl url) &#123;</span><br><span class="line">                            List&lt;Cookie&gt; cookies &#x3D; cookieStore.get(url);</span><br><span class="line">                            return cookies !&#x3D; null ? cookies : new ArrayList&lt;Cookie&gt;();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;)</span><br><span class="line">                    .build();</span><br><span class="line">                    &#x2F;&#x2F;为请求添加CookieJar。</span><br></pre></td></tr></table></figure>
<p>至于实现，也非常简单，就是一个Builder模式。具体实现就不做过多的介绍了。</p>
<h1 id="构造request对象"><a href="#构造request对象" class="headerlink" title="构造request对象"></a>构造request对象</h1><p>构建<code>request</code>对象的代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Request request &#x3D; new Request.Builder().get().url(&quot;url&quot;).build();</span><br></pre></td></tr></table></figure>
<p>Request的构建过程也非常简单，在<code>request</code>中的实现如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public Builder() &#123;</span><br><span class="line">   this.method &#x3D; &quot;GET&quot;;</span><br><span class="line">   this.headers &#x3D; new Headers.Builder();</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> public Builder get() &#123;</span><br><span class="line">   return method(&quot;GET&quot;, null);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> public Builder url(String url) &#123;</span><br><span class="line">   if (url &#x3D;&#x3D; null) throw new NullPointerException(&quot;url &#x3D;&#x3D; null&quot;);</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; Silently replace web socket URLs with HTTP URLs.</span><br><span class="line">   if (url.regionMatches(true, 0, &quot;ws:&quot;, 0, 3)) &#123;</span><br><span class="line">     url &#x3D; &quot;http:&quot; + url.substring(3);</span><br><span class="line">   &#125; else if (url.regionMatches(true, 0, &quot;wss:&quot;, 0, 4)) &#123;</span><br><span class="line">     url &#x3D; &quot;https:&quot; + url.substring(4);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   HttpUrl parsed &#x3D; HttpUrl.parse(url);</span><br><span class="line">   if (parsed &#x3D;&#x3D; null) throw new IllegalArgumentException(&quot;unexpected url: &quot; + url);</span><br><span class="line">   return url(parsed);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">   public Request build() &#123;</span><br><span class="line">   if (url &#x3D;&#x3D; null) throw new IllegalStateException(&quot;url &#x3D;&#x3D; null&quot;);</span><br><span class="line">   return new Request(this);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>可以看出来，<code>request</code>的构建过程其实也是非常简单的，也是利用建造者模式构建出<code>request</code>对象。在<code>request</code>配置URl、get、等一些列的参数。整体来说，比较简单。</p>
<h1 id="构建Call对象并执行"><a href="#构建Call对象并执行" class="headerlink" title="构建Call对象并执行"></a>构建Call对象并执行</h1><p>前两步都是非常简单的，不管是从源码的实现上，还是从我们代码的调用上来看都是非常简单的。但是前面的只是开胃菜，真正的大餐才正要开始。<br>我们将实例代码的三、四步放到一起来进行分析：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">okhttp3.Call call &#x3D; okHttpClient.newCall(request);</span><br><span class="line"> Response execute &#x3D; call.execute();</span><br></pre></td></tr></table></figure>
<p>从调用代码上来看，其实现也是非常简单的。下面将从源码的角度一步一步进行分析。<br>首先是构建<code>Call</code>对象，在<code>OkHttpClient</code>类中的实现如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Override public Call newCall(Request request) &#123;</span><br><span class="line">  return new RealCall(this, request, false &#x2F;* for web socket *&#x2F;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出来，在<code>okhttpClient</code>中只是简单的调用了<code>RealCall</code>方法，我们继续来看在<code>RealCall</code>类中<code>RealCall</code>方法的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">RealCall(OkHttpClient client, Request originalRequest, boolean forWebSocket) &#123;</span><br><span class="line">  final EventListener.Factory eventListenerFactory &#x3D; client.eventListenerFactory();</span><br><span class="line"></span><br><span class="line">  this.client &#x3D; client;</span><br><span class="line">  this.originalRequest &#x3D; originalRequest;</span><br><span class="line">  this.forWebSocket &#x3D; forWebSocket;</span><br><span class="line">  this.retryAndFollowUpInterceptor &#x3D; new RetryAndFollowUpInterceptor(client, forWebSocket);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; TODO(jwilson): this is unsafe publication and not threadsafe.</span><br><span class="line">  this.eventListener &#x3D; eventListenerFactory.create(this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>RealCall</code>方法也只是对其中的参数进行一些设置。当然，对其中的参数有还是需要有一定的了解。</p>
<ul>
<li><code>client</code>对象就是我们前面创建的<code>okhttpClient</code>对象</li>
<li><code>originalRequest</code>对象就是已经构建完毕的<code>Request</code>对象</li>
<li><code>forWebSocket</code>值是为了区分是不是进行<code>web socket</code>通信，是为true，否为false；</li>
<li><code>eventListener</code>是为后面执行完之后的回调设置的监听。<br>构建一个<code>call</code>对象之后，就通过这个call对象来进行网络请求了。具体执行（同步执行）在<code>RealCall</code>类中的实现代码如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;同步执行网路请求</span><br><span class="line">@Override public Response execute() throws IOException &#123;</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">      if (executed) throw new IllegalStateException(&quot;Already Executed&quot;);</span><br><span class="line">      executed &#x3D; true;</span><br><span class="line">    &#125;</span><br><span class="line">    captureCallStackTrace();</span><br><span class="line">    try &#123;</span><br><span class="line">      client.dispatcher().executed(this);</span><br><span class="line">      Response result &#x3D; getResponseWithInterceptorChain();</span><br><span class="line">      if (result &#x3D;&#x3D; null) throw new IOException(&quot;Canceled&quot;);</span><br><span class="line">      return result;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      client.dispatcher().finished(this);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F;跟踪调用栈的信息,这里追踪的是response.body().close()方法的调用信息</span><br><span class="line">private void captureCallStackTrace() &#123;</span><br><span class="line">    Object callStackTrace &#x3D; Platform.get().getStackTraceForCloseable(&quot;response.body().close()&quot;);</span><br><span class="line">    retryAndFollowUpInterceptor.setCallStackTrace(callStackTrace);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F;添加一堆的拦截器。</span><br><span class="line">  Response getResponseWithInterceptorChain() throws IOException &#123;</span><br><span class="line">    &#x2F;&#x2F; Build a full stack of interceptors.</span><br><span class="line">    List&lt;Interceptor&gt; interceptors &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    interceptors.addAll(client.interceptors());</span><br><span class="line">    interceptors.add(retryAndFollowUpInterceptor);</span><br><span class="line">    interceptors.add(new BridgeInterceptor(client.cookieJar()));</span><br><span class="line">    interceptors.add(new CacheInterceptor(client.internalCache()));</span><br><span class="line">    interceptors.add(new ConnectInterceptor(client));</span><br><span class="line">    if (!forWebSocket) &#123;</span><br><span class="line">      interceptors.addAll(client.networkInterceptors());</span><br><span class="line">    &#125;</span><br><span class="line">    interceptors.add(new CallServerInterceptor(forWebSocket));</span><br><span class="line"></span><br><span class="line">    Interceptor.Chain chain &#x3D; new RealInterceptorChain(</span><br><span class="line">        interceptors, null, null, null, 0, originalRequest);</span><br><span class="line">    return chain.proceed(originalRequest);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
简单分析上面代码的实现：首先利用<code>synchronized</code>加锁，是为了确保一个<code>call</code>对象只能执行一次。<code>captureCallStackTrace</code>方法用于追踪调用栈的信息。通过<code>client.dispatcher().executed(this)</code>将当前的call加入到<code>runningSyncCalls</code>这样一个正在运行的队列中。关于这点，后面将会重点讲到，这里先只是提出这么一个概念。我们继续解析上面的代码，在将当前的call添加到运行队列中后，通过<code>getResponseWithInterceptorChain</code>为当前的call添加一堆的拦截器，并将网络请求的结果返回回来，至于<code>getResponseWithInterceptorChain</code>里面的具体实现，我们放在后面来讲。最后，通过<code>client.dispatcher().finished(this);</code>来结束当前访问和释放相关资源。<br>下面来了解异步执行的相关逻辑。代码的实现部分同样是在<code>RealCall</code>类中，相关的代码如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Override public void enqueue(Callback responseCallback) &#123;</span><br><span class="line">  synchronized (this) &#123;</span><br><span class="line">    if (executed) throw new IllegalStateException(&quot;Already Executed&quot;);</span><br><span class="line">    executed &#x3D; true;</span><br><span class="line">  &#125;</span><br><span class="line">  captureCallStackTrace();</span><br><span class="line">  client.dispatcher().enqueue(new AsyncCall(responseCallback));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
通过前面的同步访问的分析，我们对异步访问的分析，现在看异步请求就很简单了。前面的步骤都是一样的，就不一一介绍了。我们直接看最后一句，其中的参数<code>AsyncCall</code>表示的其实就是我们要添加的任务请求。在<code>RealCall</code>类中有如下的实现代码：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">final class AsyncCall extends NamedRunnable &#123;</span><br><span class="line">    private final Callback responseCallback;</span><br><span class="line"></span><br><span class="line">    AsyncCall(Callback responseCallback) &#123;</span><br><span class="line">      super(&quot;OkHttp %s&quot;, redactedUrl());</span><br><span class="line">      this.responseCallback &#x3D; responseCallback;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String host() &#123;</span><br><span class="line">      return originalRequest.url().host();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Request request() &#123;</span><br><span class="line">      return originalRequest;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    RealCall get() &#123;</span><br><span class="line">      return RealCall.this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override protected void execute() &#123;</span><br><span class="line">      boolean signalledCallback &#x3D; false;</span><br><span class="line">      try &#123;</span><br><span class="line">        Response response &#x3D; getResponseWithInterceptorChain();</span><br><span class="line">        if (retryAndFollowUpInterceptor.isCanceled()) &#123;</span><br><span class="line">          signalledCallback &#x3D; true;</span><br><span class="line">          responseCallback.onFailure(RealCall.this, new IOException(&quot;Canceled&quot;));</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          signalledCallback &#x3D; true;</span><br><span class="line">          responseCallback.onResponse(RealCall.this, response);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; catch (IOException e) &#123;</span><br><span class="line">        if (signalledCallback) &#123;</span><br><span class="line">          &#x2F;&#x2F; Do not signal the callback twice!</span><br><span class="line">          Platform.get().log(INFO, &quot;Callback failure for &quot; + toLoggableString(), e);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          responseCallback.onFailure(RealCall.this, e);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; finally &#123;</span><br><span class="line">        client.dispatcher().finished(this);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
而上面<code>AsyncCall</code>继承的<code>NamedRunnable</code>本身也实现了<code>Runnable</code>的接口。所以本质来说，<code>AsyncCall</code>其实就是一个<code>Runnbale</code>，即一个任务。在这里值访问请求任务。我们发现在<code>execute</code>方法中，真正实现访问请求的也是<code>getResponseWithInterceptorChain</code>，如果访问成功就回调<code>onResponse</code>方法，并将response传递过去；否则就回调<code>onFailure</code>方法，并将错误信息和CallBack对象传递过去。当然，最终也是通过<code>finished</code>方法结束访问。分析完了<code>AsyncCall</code>，接来继续分析前面的<code>enqueue</code>方法。发现其在<code>Dispatcher</code>类中的实现逻辑如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;** Ready async calls in the order they&#39;ll be run. *&#x2F;</span><br><span class="line">&#x2F;&#x2F;这个队列代表准备好的异步请求</span><br><span class="line">  private final Deque&lt;AsyncCall&gt; readyAsyncCalls &#x3D; new ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  &#x2F;** Running asynchronous calls. Includes canceled calls that haven&#39;t finished yet. *&#x2F;</span><br><span class="line">  &#x2F;&#x2F;这个队列代表正在运行的异步请求</span><br><span class="line">  private final Deque&lt;AsyncCall&gt; runningAsyncCalls &#x3D; new ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  &#x2F;** Running synchronous calls. Includes canceled calls that haven&#39;t finished yet. *&#x2F;</span><br><span class="line">  &#x2F;&#x2F;这个队列代表正在运行的同步请求。</span><br><span class="line">  private final Deque&lt;RealCall&gt; runningSyncCalls &#x3D; new ArrayDeque&lt;&gt;();</span><br><span class="line">  </span><br><span class="line">  private int maxRequests &#x3D; 64;</span><br><span class="line">  private int maxRequestsPerHost &#x3D; 5;</span><br><span class="line">  </span><br><span class="line">  synchronized void enqueue(AsyncCall call) &#123;</span><br><span class="line">    if (runningAsyncCalls.size() &lt; maxRequests &amp;&amp; runningCallsForHost(call) &lt; maxRequestsPerHost) &#123;</span><br><span class="line">      runningAsyncCalls.add(call);</span><br><span class="line">      executorService().execute(call);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      readyAsyncCalls.add(call);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>即在当前运行异步请求队列数量小于64且访问同一个主机数量的队列小于5个时，将当前的请求直接加入正在运行的请求队列中，并通过<code>executorService().execute(call)</code>执行，否则的话就将请求添加到准备的请求队列中。至于<code>executorService().execute(call)</code>的方法的实现<code>Dispatcher</code>中创建<code>executorService</code>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public synchronized ExecutorService executorService() &#123;</span><br><span class="line">    if (executorService &#x3D;&#x3D; null) &#123;</span><br><span class="line">      executorService &#x3D; new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60, TimeUnit.SECONDS,</span><br><span class="line">          new SynchronousQueue&lt;Runnable&gt;(), Util.threadFactory(&quot;OkHttp Dispatcher&quot;, false));</span><br><span class="line">    &#125;</span><br><span class="line">    return executorService;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>通过代码可以很清楚的了解，<code>executorService</code>就是创建一个线程池，核心线程数为0，最大线程数为<code>MAX_VALUE</code>，线程空闲时最大的存活时间为60s，容器为先进先出的队列。然后执行<code>execute</code>方法，在线程池中运行该请求。那么运行完毕后，是怎么将请求从运行异步队列中移除？其实，在前面的分析过程中，我们对<code>execute</code>同步请求和<code>enqueue</code>异步请求的都最终会调用的一个方法<code>client.dispatcher().finished(this);</code>并没有仔细的去分析，下面我们分析该方法是如何将运行完成的请求从运行异步队列中移除的。下面是关键性的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;** Used by &#123;@code AsyncCall#run&#125; to signal completion. *&#x2F;</span><br><span class="line">void finished(AsyncCall call) &#123;</span><br><span class="line">  finished(runningAsyncCalls, call, true);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;** Used by &#123;@code Call#execute&#125; to signal completion. *&#x2F;</span><br><span class="line">void finished(RealCall call) &#123;</span><br><span class="line">  finished(runningSyncCalls, call, false);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private &lt;T&gt; void finished(Deque&lt;T&gt; calls, T call, boolean promoteCalls) &#123;</span><br><span class="line">  int runningCallsCount;</span><br><span class="line">  Runnable idleCallback;</span><br><span class="line">  synchronized (this) &#123;</span><br><span class="line">    if (!calls.remove(call)) throw new AssertionError(&quot;Call wasn&#39;t in-flight!&quot;);</span><br><span class="line">    if (promoteCalls) promoteCalls();</span><br><span class="line">    runningCallsCount &#x3D; runningCallsCount();</span><br><span class="line">    idleCallback &#x3D; this.idleCallback;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>通过上面的代码，很容易就发现其实现<code>finished</code>中实现主要就是将已经运行完成的请求从正在运行的异步队列中移除。可以看到，当调用<code>finished(RealCall call)</code>方法时，会调用<code>promoteCalls</code>方法。我们继续来看其实现:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">private void promoteCalls() &#123;</span><br><span class="line">    if (runningAsyncCalls.size() &gt;&#x3D; maxRequests) return; &#x2F;&#x2F; Already running max capacity.</span><br><span class="line">    if (readyAsyncCalls.isEmpty()) return; &#x2F;&#x2F; No ready calls to promote.</span><br><span class="line"></span><br><span class="line">    for (Iterator&lt;AsyncCall&gt; i &#x3D; readyAsyncCalls.iterator(); i.hasNext(); ) &#123;</span><br><span class="line">      AsyncCall call &#x3D; i.next();</span><br><span class="line"></span><br><span class="line">      if (runningCallsForHost(call) &lt; maxRequestsPerHost) &#123;</span><br><span class="line">        i.remove();</span><br><span class="line">        runningAsyncCalls.add(call);</span><br><span class="line">        executorService().execute(call);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (runningAsyncCalls.size() &gt;&#x3D; maxRequests) return; &#x2F;&#x2F; Reached max capacity.</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>很清晰的可以看出来，<code>promoteCalls</code>方法就是在<code>runningAsyncCalls</code>队列数量小于64时，将<code>readyAsyncCalls</code>队列中的请求放入到<code>runningAsyncCalls</code>队列中。然后分别执行。否则就直接返回，什么也不做。相信这里的算是很简单的代码吧，就不多介绍了。到这里，在总结一下上面的三个队列的作用和转化吧。</p>
<ul>
<li><code>runningAsyncCalls</code>就用存储正在运行的异步请求，当正在请求的数量大于64时，将后面添加的请求放入到<code>readyAsyncCalls</code>队列中，在合适的时机（即当<code>runningAsyncCalls</code>数量小于64时），将<code>readyAsyncCalls</code>放入到<code>runningAsyncCalls</code>队列中。通过这种方式来保障当前正在运行的异步请求数量不会过大，相当于一个排队机制。</li>
<li><code>runningSyncCalls</code>这个队列用于存储正在运行的同步请求，对于同步请求，并没有什么排队机制，因为他是阻塞式的，所以用一个队列来存储即可。</li>
</ul>
<h1 id="拦截器-amp-网络请求的实现"><a href="#拦截器-amp-网络请求的实现" class="headerlink" title="拦截器&amp;网络请求的实现"></a>拦截器&amp;网络请求的实现</h1><p>通过上面的分析，我们并没有真正发现网络请求的实现，在前面的分析过程中，我们只丢下了一个重要的方法并没有深入来讲，即<code>getResponseWithInterceptorChain</code>这个方法。对前面分析的内容比较熟悉的话，应该知道无论是异步请求还是同步请求，都是通过<code>getResponseWithInterceptorChain</code>这个方法获取返回值，然后将在继续下面的内容的。那么肯定，网络请求的具体实现就在<code>getResponseWithInterceptorChain</code>这个方法中了。他在<code>RealCall</code>中的实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Response getResponseWithInterceptorChain() throws IOException &#123;</span><br><span class="line">    &#x2F;&#x2F; Build a full stack of interceptors.</span><br><span class="line">    List&lt;Interceptor&gt; interceptors &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    interceptors.addAll(client.interceptors());</span><br><span class="line">    interceptors.add(retryAndFollowUpInterceptor);</span><br><span class="line">    interceptors.add(new BridgeInterceptor(client.cookieJar()));</span><br><span class="line">    interceptors.add(new CacheInterceptor(client.internalCache()));</span><br><span class="line">    interceptors.add(new ConnectInterceptor(client));</span><br><span class="line">    if (!forWebSocket) &#123;</span><br><span class="line">      interceptors.addAll(client.networkInterceptors());</span><br><span class="line">    &#125;</span><br><span class="line">    interceptors.add(new CallServerInterceptor(forWebSocket));</span><br><span class="line"></span><br><span class="line">    Interceptor.Chain chain &#x3D; new RealInterceptorChain(</span><br><span class="line">        interceptors, null, null, null, 0, originalRequest);</span><br><span class="line">    return chain.proceed(originalRequest);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>通过代码，我们可以看到，首先添加了一系列的拦截器。然后创建一个拦截器链<code>RealInterceptorChain</code>，并执行了拦截器链的<code>proceed</code>方法。<br>我们首先对其中的拦截器进行解析，然后在来解析具体的网路请求。首先，先解释一下<code>interceptors</code>(拦截器)是什么吧。简单来说：<br><strong>拦截器是一种强大的机制，可以监视，重写和重试调用。</strong><br>如果相对拦截器更加深入的了解，可以参考<a href="https://github.com/square/okhttp/wiki/Interceptors" target="_blank" rel="noopener">githu上的wiki</a>,如果阅读有困难的话，可以参考<a href="http://www.jianshu.com/p/2710ed1e6b48" target="_blank" rel="noopener">中文版</a>。<br>一个网络请求实际上就是一个个拦截器执行其<code>intercept</code>方法的过程。而这其中除了用户自定义的拦截器以外还有几个核心的拦截器完成网络访问的核心逻辑，按照先后顺序以此是：</p>
<ol>
<li><strong>RetryAndFollowUpInterceptor</strong> 负责失败重试以及重定向</li>
<li><strong>BridgeInterceptor</strong> 负责把用户构造的请求转换为发送到服务器的请求、把服务器返回的响应转换为用户友好的响应</li>
<li><strong>CacheInterceptor</strong> 负责读取缓存直接返回、更新缓存</li>
<li><strong>ConnectInterceptor</strong> 负责和服务器建立连接</li>
<li><strong>networkInterceptors</strong> 配置<code>okHttpClent</code>时设置的，当然，此拦截器不适用于<code>web Socket</code></li>
<li><strong>CallServerInterceptor</strong> 责向服务器发送请求数据、从服务器读取响应数据<br>当然，如果有用户自己设计的拦截器，会在上面拦截其执行之前执行。<br>在添加拦截器之后，会构建一个拦截器链<code>RealInterceptorChain</code>，并通过<code>proceed</code>方法开启链式调用。<br>下面我们先来看一下<code>RealInterceptorChain</code>拦截器链的具体实现：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">**</span><br><span class="line"> * A concrete interceptor chain that carries the entire interceptor chain: all application</span><br><span class="line"> * interceptors, the OkHttp core, all network interceptors, and finally the network caller.</span><br><span class="line"> *&#x2F;</span><br><span class="line">public final class RealInterceptorChain implements Interceptor.Chain &#123;</span><br><span class="line">  private final List&lt;Interceptor&gt; interceptors;</span><br><span class="line">  private final StreamAllocation streamAllocation;</span><br><span class="line">  private final HttpCodec httpCodec;</span><br><span class="line">  private final RealConnection connection;</span><br><span class="line">  private final int index;</span><br><span class="line">  private final Request request;</span><br><span class="line">  private int calls;</span><br><span class="line"></span><br><span class="line">  public RealInterceptorChain(List&lt;Interceptor&gt; interceptors, StreamAllocation streamAllocation,</span><br><span class="line">      HttpCodec httpCodec, RealConnection connection, int index, Request request) &#123;</span><br><span class="line">    this.interceptors &#x3D; interceptors;</span><br><span class="line">    this.connection &#x3D; connection;</span><br><span class="line">    this.streamAllocation &#x3D; streamAllocation;</span><br><span class="line">    this.httpCodec &#x3D; httpCodec;</span><br><span class="line">    this.index &#x3D; index;</span><br><span class="line">    this.request &#x3D; request;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override public Connection connection() &#123;</span><br><span class="line">    return connection;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public StreamAllocation streamAllocation() &#123;</span><br><span class="line">    return streamAllocation;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public HttpCodec httpStream() &#123;</span><br><span class="line">    return httpCodec;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override public Request request() &#123;</span><br><span class="line">    return request;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override public Response proceed(Request request) throws IOException &#123;</span><br><span class="line">    return proceed(request, streamAllocation, httpCodec, connection);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public Response proceed(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec,</span><br><span class="line">      RealConnection connection) throws IOException &#123;</span><br><span class="line">    if (index &gt;&#x3D; interceptors.size()) throw new AssertionError();</span><br><span class="line"></span><br><span class="line">    calls++;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; If we already have a stream, confirm that the incoming request will use it.</span><br><span class="line">    if (this.httpCodec !&#x3D; null &amp;&amp; !this.connection.supportsUrl(request.url())) &#123;</span><br><span class="line">      throw new IllegalStateException(&quot;network interceptor &quot; + interceptors.get(index - 1)</span><br><span class="line">          + &quot; must retain the same host and port&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; If we already have a stream, confirm that this is the only call to chain.proceed().</span><br><span class="line">    if (this.httpCodec !&#x3D; null &amp;&amp; calls &gt; 1) &#123;</span><br><span class="line">      throw new IllegalStateException(&quot;network interceptor &quot; + interceptors.get(index - 1)</span><br><span class="line">          + &quot; must call proceed() exactly once&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Call the next interceptor in the chain.</span><br><span class="line">    RealInterceptorChain next &#x3D; new RealInterceptorChain(</span><br><span class="line">        interceptors, streamAllocation, httpCodec, connection, index + 1, request);</span><br><span class="line">    Interceptor interceptor &#x3D; interceptors.get(index);</span><br><span class="line">    Response response &#x3D; interceptor.intercept(next);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Confirm that the next interceptor made its required call to chain.proceed().</span><br><span class="line">    if (httpCodec !&#x3D; null &amp;&amp; index + 1 &lt; interceptors.size() &amp;&amp; next.calls !&#x3D; 1) &#123;</span><br><span class="line">      throw new IllegalStateException(&quot;network interceptor &quot; + interceptor</span><br><span class="line">          + &quot; must call proceed() exactly once&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Confirm that the intercepted response isn&#39;t null.</span><br><span class="line">    if (response &#x3D;&#x3D; null) &#123;</span><br><span class="line">      throw new NullPointerException(&quot;interceptor &quot; + interceptor + &quot; returned null&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return response;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
上面代码比较多，重要的内容并不多，我们只需要看着重看第63行到66行就可以。从整体上来说，<code>RealInterceptorChain</code>中的<code>proceed</code>方法主要做了两件事情：</li>
</ol>
<ul>
<li>实例化下一个拦截器对应的<code>RealIterceptorChain</code>对象，这个对象会传递给当前的拦截器</li>
<li>调用当前拦截器的<code>intercept</code>方法，将下一个拦截器的<code>orChain</code>对象传递下去。</li>
</ul>
<p>接下来我们就来分析以下传入到拦截器链中的拦截器的具体内容.我们首先来分析第一个拦截器：</p>
<h2 id="RetryAndFollowUpInterceptor拦截器"><a href="#RetryAndFollowUpInterceptor拦截器" class="headerlink" title="RetryAndFollowUpInterceptor拦截器"></a>RetryAndFollowUpInterceptor拦截器</h2><p>作用：</p>
<ul>
<li>在网络请求失败后重试</li>
<li>当服务器返回当前请求需要进行重定向时直接发起新的请求，并在条件允许的情况下复用当前连接<br>其在<code>RetryAndFollowUpInterceptor</code>类中的构造函数和重要方法<code>Response</code>的实现如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">private static final int MAX_FOLLOW_UPS &#x3D; 20;</span><br><span class="line">private final OkHttpClient client;</span><br><span class="line">private final boolean forWebSocket;</span><br><span class="line">private StreamAllocation streamAllocation;</span><br><span class="line">private Object callStackTrace;</span><br><span class="line">private volatile boolean canceled;</span><br><span class="line"></span><br><span class="line">public RetryAndFollowUpInterceptor(OkHttpClient client, boolean forWebSocket) &#123;</span><br><span class="line">  this.client &#x3D; client;</span><br><span class="line">  this.forWebSocket &#x3D; forWebSocket;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override public Response intercept(Chain chain) throws IOException &#123;</span><br><span class="line">  Request request &#x3D; chain.request();</span><br><span class="line"></span><br><span class="line">  streamAllocation &#x3D; new StreamAllocation(</span><br><span class="line">      client.connectionPool(), createAddress(request.url()), callStackTrace);</span><br><span class="line"></span><br><span class="line">  int followUpCount &#x3D; 0;</span><br><span class="line">  Response priorResponse &#x3D; null;</span><br><span class="line">  while (true) &#123;</span><br><span class="line">    if (canceled) &#123;</span><br><span class="line">      streamAllocation.release();</span><br><span class="line">      throw new IOException(&quot;Canceled&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Response response &#x3D; null;</span><br><span class="line">    boolean releaseConnection &#x3D; true;</span><br><span class="line">    try &#123;</span><br><span class="line">    &#x2F;&#x2F;执行下一个拦截器链的proceed方法</span><br><span class="line">      response &#x3D; ((RealInterceptorChain) chain).proceed(request, streamAllocation, null, null);</span><br><span class="line">      releaseConnection &#x3D; false;</span><br><span class="line">    &#125; catch (RouteException e) &#123;</span><br><span class="line">          ...      </span><br><span class="line">    &#125;  finally &#123;</span><br><span class="line">      &#x2F;&#x2F; We&#39;re throwing an unchecked exception. Release any resources.</span><br><span class="line">      if (releaseConnection) &#123;</span><br><span class="line">        streamAllocation.streamFailed(null);</span><br><span class="line">        streamAllocation.release();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Attach the prior response if it exists. Such responses never have a body.</span><br><span class="line">    if (priorResponse !&#x3D; null) &#123;</span><br><span class="line">      response &#x3D; response.newBuilder()</span><br><span class="line">          .priorResponse(priorResponse.newBuilder()</span><br><span class="line">                  .body(null)</span><br><span class="line">                  .build())</span><br><span class="line">          .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Request followUp &#x3D; followUpRequest(response);</span><br><span class="line"></span><br><span class="line">    if (followUp &#x3D;&#x3D; null) &#123;</span><br><span class="line">      if (!forWebSocket) &#123;</span><br><span class="line">        streamAllocation.release();</span><br><span class="line">      &#125;</span><br><span class="line">      return response;</span><br><span class="line">    &#125;</span><br><span class="line">    closeQuietly(response.body());</span><br><span class="line"></span><br><span class="line">    if (!sameConnection(response, followUp.url())) &#123;</span><br><span class="line">      streamAllocation.release();</span><br><span class="line">      streamAllocation &#x3D; new StreamAllocation(</span><br><span class="line">          client.connectionPool(), createAddress(followUp.url()), callStackTrace);</span><br><span class="line">    &#125; else if (streamAllocation.codec() !&#x3D; null) &#123;</span><br><span class="line">      throw new IllegalStateException(&quot;Closing the body of &quot; + response</span><br><span class="line">          + &quot; didn&#39;t close its backing stream. Bad interceptor?&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    request &#x3D; followUp;</span><br><span class="line">    priorResponse &#x3D; response;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
经过删减后的代码还是有点多，但是我们只是理解流程的话，值需要特别关注第31行。这行代码是执行下一个拦截器链的<code>proceed</code>方法，而我们知道在下一个拦截器链中又会执行下一个拦截器的<code>intercept</code>方法。所以，整个执行过程都是一个拦截器与拦截链中交替执行，最终完成所有拦截器的操作。</li>
</ul>
<h2 id="BridgeInterceptor拦截器"><a href="#BridgeInterceptor拦截器" class="headerlink" title="BridgeInterceptor拦截器"></a>BridgeInterceptor拦截器</h2><p>作用：<br>    从用户的请求构建网络请求，然后提交给网络，最后从网络相应中提取出用户响应。<br>下面来看源码实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">public final class BridgeInterceptor implements Interceptor &#123;</span><br><span class="line"></span><br><span class="line">private final CookieJar cookieJar;</span><br><span class="line"></span><br><span class="line">  public BridgeInterceptor(CookieJar cookieJar) &#123;</span><br><span class="line">    this.cookieJar &#x3D; cookieJar;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> @Override public Response intercept(Chain chain) throws IOException &#123;</span><br><span class="line">    Request userRequest &#x3D; chain.request();</span><br><span class="line">    Request.Builder requestBuilder &#x3D; userRequest.newBuilder();</span><br><span class="line"></span><br><span class="line">    RequestBody body &#x3D; userRequest.body();</span><br><span class="line">    if (body !&#x3D; null) &#123;</span><br><span class="line">      MediaType contentType &#x3D; body.contentType();</span><br><span class="line">      if (contentType !&#x3D; null) &#123;</span><br><span class="line">        requestBuilder.header(&quot;Content-Type&quot;, contentType.toString());</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      long contentLength &#x3D; body.contentLength();</span><br><span class="line">      if (contentLength !&#x3D; -1) &#123;</span><br><span class="line">        requestBuilder.header(&quot;Content-Length&quot;, Long.toString(contentLength));</span><br><span class="line">        requestBuilder.removeHeader(&quot;Transfer-Encoding&quot;);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        requestBuilder.header(&quot;Transfer-Encoding&quot;, &quot;chunked&quot;);</span><br><span class="line">        requestBuilder.removeHeader(&quot;Content-Length&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (userRequest.header(&quot;Host&quot;) &#x3D;&#x3D; null) &#123;</span><br><span class="line">      requestBuilder.header(&quot;Host&quot;, hostHeader(userRequest.url(), false));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (userRequest.header(&quot;Connection&quot;) &#x3D;&#x3D; null) &#123;</span><br><span class="line">      requestBuilder.header(&quot;Connection&quot;, &quot;Keep-Alive&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; If we add an &quot;Accept-Encoding: gzip&quot; header field we&#39;re responsible for also decompressing</span><br><span class="line">    &#x2F;&#x2F; the transfer stream.</span><br><span class="line">    boolean transparentGzip &#x3D; false;</span><br><span class="line">    if (userRequest.header(&quot;Accept-Encoding&quot;) &#x3D;&#x3D; null &amp;&amp; userRequest.header(&quot;Range&quot;) &#x3D;&#x3D; null) &#123;</span><br><span class="line">      transparentGzip &#x3D; true;</span><br><span class="line">      requestBuilder.header(&quot;Accept-Encoding&quot;, &quot;gzip&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    List&lt;Cookie&gt; cookies &#x3D; cookieJar.loadForRequest(userRequest.url());</span><br><span class="line">    if (!cookies.isEmpty()) &#123;</span><br><span class="line">      requestBuilder.header(&quot;Cookie&quot;, cookieHeader(cookies));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (userRequest.header(&quot;User-Agent&quot;) &#x3D;&#x3D; null) &#123;</span><br><span class="line">      requestBuilder.header(&quot;User-Agent&quot;, Version.userAgent());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Response networkResponse &#x3D; chain.proceed(requestBuilder.build());</span><br><span class="line"></span><br><span class="line">    HttpHeaders.receiveHeaders(cookieJar, userRequest.url(), networkResponse.headers());</span><br><span class="line"></span><br><span class="line">    Response.Builder responseBuilder &#x3D; networkResponse.newBuilder()</span><br><span class="line">        .request(userRequest);</span><br><span class="line"></span><br><span class="line">    if (transparentGzip</span><br><span class="line">        &amp;&amp; &quot;gzip&quot;.equalsIgnoreCase(networkResponse.header(&quot;Content-Encoding&quot;))</span><br><span class="line">        &amp;&amp; HttpHeaders.hasBody(networkResponse)) &#123;</span><br><span class="line">      GzipSource responseBody &#x3D; new GzipSource(networkResponse.body().source());</span><br><span class="line">      Headers strippedHeaders &#x3D; networkResponse.headers().newBuilder()</span><br><span class="line">          .removeAll(&quot;Content-Encoding&quot;)</span><br><span class="line">          .removeAll(&quot;Content-Length&quot;)</span><br><span class="line">          .build();</span><br><span class="line">      responseBuilder.headers(strippedHeaders);</span><br><span class="line">      responseBuilder.body(new RealResponseBody(strippedHeaders, Okio.buffer(responseBody)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return responseBuilder.build();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，<code>BridgeInterceptor</code>中的实现就比较简单了。主要做了如下的工作：</p>
<ul>
<li>设置内容长度，内容编码</li>
<li>设置gzip编码，并在接收到内容后进行解压。</li>
<li>添加cookie</li>
<li>设置其他的报头，如<code>User-Agent</code>,<code>Host</code>,<code>Keep-Alive</code>等。</li>
</ul>
<h2 id="CacheInterceptor拦截器"><a href="#CacheInterceptor拦截器" class="headerlink" title="CacheInterceptor拦截器"></a>CacheInterceptor拦截器</h2><p>作用：主要负责Cache的管理<br>源码分析：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">public final class CacheInterceptor implements Interceptor &#123;</span><br><span class="line">  final InternalCache cache;</span><br><span class="line"></span><br><span class="line">  public CacheInterceptor(InternalCache cache) &#123;</span><br><span class="line">    this.cache &#x3D; cache;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override public Response intercept(Chain chain) throws IOException &#123;</span><br><span class="line">    Response cacheCandidate &#x3D; cache !&#x3D; null</span><br><span class="line">        ? cache.get(chain.request())</span><br><span class="line">        : null;</span><br><span class="line"></span><br><span class="line">    long now &#x3D; System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    CacheStrategy strategy &#x3D; new CacheStrategy.Factory(now, chain.request(), cacheCandidate).get();</span><br><span class="line">    Request networkRequest &#x3D; strategy.networkRequest;</span><br><span class="line">    Response cacheResponse &#x3D; strategy.cacheResponse;</span><br><span class="line"></span><br><span class="line">    if (cache !&#x3D; null) &#123;</span><br><span class="line">      cache.trackResponse(strategy);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (cacheCandidate !&#x3D; null &amp;&amp; cacheResponse &#x3D;&#x3D; null) &#123;</span><br><span class="line">      closeQuietly(cacheCandidate.body()); &#x2F;&#x2F; The cache candidate wasn&#39;t applicable. Close it.</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; If we&#39;re forbidden from using the network and the cache is insufficient, fail.</span><br><span class="line">    if (networkRequest &#x3D;&#x3D; null &amp;&amp; cacheResponse &#x3D;&#x3D; null) &#123;</span><br><span class="line">      return new Response.Builder()</span><br><span class="line">          .request(chain.request())</span><br><span class="line">          .protocol(Protocol.HTTP_1_1)</span><br><span class="line">          .code(504)</span><br><span class="line">          .message(&quot;Unsatisfiable Request (only-if-cached)&quot;)</span><br><span class="line">          .body(Util.EMPTY_RESPONSE)</span><br><span class="line">          .sentRequestAtMillis(-1L)</span><br><span class="line">          .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">          .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; If we don&#39;t need the network, we&#39;re done.</span><br><span class="line">    if (networkRequest &#x3D;&#x3D; null) &#123;</span><br><span class="line">      return cacheResponse.newBuilder()</span><br><span class="line">          .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">          .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Response networkResponse &#x3D; null;</span><br><span class="line">    try &#123;</span><br><span class="line">      networkResponse &#x3D; chain.proceed(networkRequest);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      &#x2F;&#x2F; If we&#39;re crashing on I&#x2F;O or otherwise, don&#39;t leak the cache body.</span><br><span class="line">      if (networkResponse &#x3D;&#x3D; null &amp;&amp; cacheCandidate !&#x3D; null) &#123;</span><br><span class="line">        closeQuietly(cacheCandidate.body());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; If we have a cache response too, then we&#39;re doing a conditional get.</span><br><span class="line">    if (cacheResponse !&#x3D; null) &#123;</span><br><span class="line">      if (networkResponse.code() &#x3D;&#x3D; HTTP_NOT_MODIFIED) &#123;</span><br><span class="line">        Response response &#x3D; cacheResponse.newBuilder()</span><br><span class="line">            .headers(combine(cacheResponse.headers(), networkResponse.headers()))</span><br><span class="line">            .sentRequestAtMillis(networkResponse.sentRequestAtMillis())</span><br><span class="line">            .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis())</span><br><span class="line">            .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">            .networkResponse(stripBody(networkResponse))</span><br><span class="line">            .build();</span><br><span class="line">        networkResponse.body().close();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Update the cache after combining headers but before stripping the</span><br><span class="line">        &#x2F;&#x2F; Content-Encoding header (as performed by initContentStream()).</span><br><span class="line">        cache.trackConditionalCacheHit();</span><br><span class="line">        cache.update(cacheResponse, response);</span><br><span class="line">        return response;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        closeQuietly(cacheResponse.body());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Response response &#x3D; networkResponse.newBuilder()</span><br><span class="line">        .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">        .networkResponse(stripBody(networkResponse))</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line">    if (cache !&#x3D; null) &#123;</span><br><span class="line">      if (HttpHeaders.hasBody(response) &amp;&amp; CacheStrategy.isCacheable(response, networkRequest)) &#123;</span><br><span class="line">        &#x2F;&#x2F; Offer this request to the cache.</span><br><span class="line">        CacheRequest cacheRequest &#x3D; cache.put(response);</span><br><span class="line">        return cacheWritingResponse(cacheRequest, response);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (HttpMethod.invalidatesCache(networkRequest.method())) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">          cache.remove(networkRequest);</span><br><span class="line">        &#125; catch (IOException ignored) &#123;</span><br><span class="line">          &#x2F;&#x2F; The cache cannot be written.</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return response;</span><br><span class="line">  &#125;</span><br><span class="line"> ...</span><br></pre></td></tr></table></figure>
<p>通过上面代码就可以分析出来，<code>CacheInterceptor</code>就是负责管理cache的，具体体现如下:</p>
<ul>
<li>当网络请求有符合要求的cache时直接返回Cache</li>
<li>当服务器返回内容有改变时更新当前cache</li>
<li>如果当前cache失效，则删除</li>
</ul>
<h2 id="ConnectInterceptor拦截器"><a href="#ConnectInterceptor拦截器" class="headerlink" title="ConnectInterceptor拦截器"></a>ConnectInterceptor拦截器</h2><p>作用：与服务端建立连接。<br>具体代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public final class ConnectInterceptor implements Interceptor &#123;</span><br><span class="line">  public final OkHttpClient client;</span><br><span class="line"></span><br><span class="line">  public ConnectInterceptor(OkHttpClient client) &#123;</span><br><span class="line">    this.client &#x3D; client;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override public Response intercept(Chain chain) throws IOException &#123;</span><br><span class="line">    RealInterceptorChain realChain &#x3D; (RealInterceptorChain) chain;</span><br><span class="line">    Request request &#x3D; realChain.request();</span><br><span class="line">    StreamAllocation streamAllocation &#x3D; realChain.streamAllocation();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; We need the network to satisfy this request. Possibly for validating a conditional GET.</span><br><span class="line">    boolean doExtensiveHealthChecks &#x3D; !request.method().equals(&quot;GET&quot;);</span><br><span class="line">    HttpCodec httpCodec &#x3D; streamAllocation.newStream(client, doExtensiveHealthChecks);</span><br><span class="line">    RealConnection connection &#x3D; streamAllocation.connection();</span><br><span class="line"></span><br><span class="line">    return realChain.proceed(request, streamAllocation, httpCodec, connection);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码比较简单，我们简单进行分析。在<code>intercept</code>方法中，通过第15行代码创建了一个<code>httpCodec</code>对象，他将在后面的步骤中用到。简单介绍一下<code>httpCodec</code>，他其实就是对HTTP协议操作的抽象，具体实现有<code>Http1Codec</code>(对象HTTP1.1)、<code>Http2Codec</code>(对应Http2.0)两种。<br>然后通过第16行与服务端建立联系，因为里面的代码比较多，就不展开了。</p>
<p>##CallServerInterceptor拦截器<br>作用：发送和接收数据。<br>具体源码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">@Override public Response intercept(Chain chain) throws IOException &#123;</span><br><span class="line">    RealInterceptorChain realChain &#x3D; (RealInterceptorChain) chain;</span><br><span class="line">    HttpCodec httpCodec &#x3D; realChain.httpStream();</span><br><span class="line">    StreamAllocation streamAllocation &#x3D; realChain.streamAllocation();</span><br><span class="line">    RealConnection connection &#x3D; (RealConnection) realChain.connection();</span><br><span class="line">    Request request &#x3D; realChain.request();</span><br><span class="line"></span><br><span class="line">    long sentRequestMillis &#x3D; System.currentTimeMillis();</span><br><span class="line">    httpCodec.writeRequestHeaders(request);</span><br><span class="line"></span><br><span class="line">    Response.Builder responseBuilder &#x3D; null;</span><br><span class="line">    if (HttpMethod.permitsRequestBody(request.method()) &amp;&amp; request.body() !&#x3D; null) &#123;</span><br><span class="line">      &#x2F;&#x2F; If there&#39;s a &quot;Expect: 100-continue&quot; header on the request, wait for a &quot;HTTP&#x2F;1.1 100</span><br><span class="line">      &#x2F;&#x2F; Continue&quot; response before transmitting the request body. If we don&#39;t get that, return what</span><br><span class="line">      &#x2F;&#x2F; we did get (such as a 4xx response) without ever transmitting the request body.</span><br><span class="line">      if (&quot;100-continue&quot;.equalsIgnoreCase(request.header(&quot;Expect&quot;))) &#123;</span><br><span class="line">        httpCodec.flushRequest();</span><br><span class="line">        responseBuilder &#x3D; httpCodec.readResponseHeaders(true);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (responseBuilder &#x3D;&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F; Write the request body if the &quot;Expect: 100-continue&quot; expectation was met.</span><br><span class="line">        Sink requestBodyOut &#x3D; httpCodec.createRequestBody(request, request.body().contentLength());</span><br><span class="line">        BufferedSink bufferedRequestBody &#x3D; Okio.buffer(requestBodyOut);</span><br><span class="line">        request.body().writeTo(bufferedRequestBody);</span><br><span class="line">        bufferedRequestBody.close();</span><br><span class="line">      &#125; else if (!connection.isMultiplexed()) &#123;</span><br><span class="line">        &#x2F;&#x2F; If the &quot;Expect: 100-continue&quot; expectation wasn&#39;t met, prevent the HTTP&#x2F;1 connection from</span><br><span class="line">        &#x2F;&#x2F; being reused. Otherwise we&#39;re still obligated to transmit the request body to leave the</span><br><span class="line">        &#x2F;&#x2F; connection in a consistent state.</span><br><span class="line">        streamAllocation.noNewStreams();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    httpCodec.finishRequest();</span><br><span class="line"></span><br><span class="line">    if (responseBuilder &#x3D;&#x3D; null) &#123;</span><br><span class="line">      responseBuilder &#x3D; httpCodec.readResponseHeaders(false);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Response response &#x3D; responseBuilder</span><br><span class="line">        .request(request)</span><br><span class="line">        .handshake(streamAllocation.connection().handshake())</span><br><span class="line">        .sentRequestAtMillis(sentRequestMillis)</span><br><span class="line">        .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">        .build();</span><br><span class="line">&#x2F;&#x2F;。。。省略部分代码。。。</span><br><span class="line">    return response;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>作为拦截连中最后的一个拦截器，我们有必要对其进行分析。我们还是只针对核心部分进行解析：这段代码主要做了这么几件事：</p>
<ol>
<li>首先获取<code>HttpCodec</code>对象，至于这个对象的产生在前面的<code>ConnectInterceptor</code>拦截器中。</li>
<li>通过<code>writeRequestHeaders</code>方法将<code>request</code>写入头部；</li>
<li>判断是否有需要写入请求的<code>body</code>部分，最后调用<code>finishRequest</code>将所有的数据刷新给底层的Sokcet；</li>
<li>通过调用<code>readResponseHeaders</code>方法读取响应的头部，；</li>
<li>然后通过构建一个新的<code>Response</code>对象，并通过<code>openResponseBody</code>获取返回的<code>body</code>。</li>
<li>最后将构建好的<code>response</code>对象返回。</li>
</ol>
<p>##总体流程图<br>通过上面的分析，对Okhttp网络请求的流程应该已经有一个比较清晰的认识了，下面是大神总结的一张整体流程图。<br><img src="http://upload-images.jianshu.io/upload_images/4037105-dc97d1a43aed5334?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="okHttp流程图"><br>这篇文章只是对Okhttp整体做流程进行分析，很多的细节部分并没有深入去了解。譬如缓存管理，比如真正的网络请求，譬如IO操作。我们都只停留在具体的方法上。通过这篇文章，我们只知道，Okhhtp的底层是通过Socket进行通信的，利用<code>OkIo</code>来进行高效的IO操作，在缓存方面，使用了LRUCache算法。具体的细节，这里就不展开具体去深入了。</p>
<h1 id="整体流程分析"><a href="#整体流程分析" class="headerlink" title="整体流程分析"></a>整体流程分析</h1><p>通过上面的简单使用来看，可以初步看出okhttp的整体流程。<br><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/f6e2ac304ee22891eca4ad1218602044.png" alt="总体架构图"><br>上图是OkHttp的总体架构，大致可以分为以下几层：</p>
<ul>
<li>Interface——接口层：接受网络访问请求</li>
<li>Protocol——协议层：处理协议逻辑</li>
<li>Connection——连接层：管理网络连接，发送新的请求，接收服务器访问</li>
<li>Cache——缓存层：管理本地缓存</li>
<li>I/O——I/O层：实际数据读写实现</li>
<li>Inteceptor——拦截器层：拦截网络访问，插入拦截逻辑</li>
</ul>
<h1 id="Okhttp的优势与特点"><a href="#Okhttp的优势与特点" class="headerlink" title="Okhttp的优势与特点"></a>Okhttp的优势与特点</h1><ul>
<li>支持HTTPS/HTTP2/WebSocket等协议</li>
<li>友好支持并发访问，支持多路复用</li>
<li>提供拦截器</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://github.com/square/okhttp" target="_blank" rel="noopener">okhttp的github地址</a></li>
<li><a href="https://yq.aliyun.com/articles/78105?spm=5176.100239.blogcont78104.10.kmOxk1" target="_blank" rel="noopener">OKhttp3.7源码分析</a></li>
<li><a href="http://frodoking.github.io/2015/03/12/android-okhttp/" target="_blank" rel="noopener">OKHttp源码解析</a></li>
<li><a href="http://www.jianshu.com/p/9ed2c2f2a52c" target="_blank" rel="noopener">android面试题-okhttp内核剖析</a></li>
<li><a href="http://blog.csdn.net/xiaanming/article/details/26810303/" target="_blank" rel="noopener">okhttp基本使用与介绍</a></li>
<li><a href="https://blog.piasy.com/2016/07/11/Understand-OkHttp/" target="_blank" rel="noopener">拆轮子系列，Okhttp解析</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://reoger.tk/2017/09/02/sourceCode/imageLoader%E8%A7%A3%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="reoger">
      <meta itemprop="description" content="reoger">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="reoger的记录">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/09/02/sourceCode/imageLoader%E8%A7%A3%E6%9E%90/" class="post-title-link" itemprop="url">imageLoader解析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-09-02 19:00:47" itemprop="dateCreated datePublished" datetime="2017-09-02T19:00:47+08:00">2017-09-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-07-18 13:47:21" itemprop="dateModified" datetime="2020-07-18T13:47:21+08:00">2020-07-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/sourceCode/" itemprop="url" rel="index"><span itemprop="name">sourceCode</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p><code>ImageLoader</code>是最早开源的 <code>Android</code> 图片缓存库, 强大的缓存机制, 早期使用这个图片加载框架的android应用非常多， 至今仍然有不少<code>Android</code> 开发者在使用。</p>
</blockquote>
<h1 id="ImagerLoader特征"><a href="#ImagerLoader特征" class="headerlink" title="ImagerLoader特征"></a>ImagerLoader特征</h1><ol>
<li>支持本地、网络图片，且支持图片下载的进度监听</li>
<li>支持个性化配置ImagerLoader，如线程池，内存缓存策略，图片显示选项等</li>
<li>三层缓存加快图片的加载速度</li>
<li>支持图片压缩</li>
</ol>
<h1 id="开始使用"><a href="#开始使用" class="headerlink" title="开始使用"></a>开始使用</h1><p>鉴于这篇是对ImageLoader源码来进行解析，我们首先回顾一下<code>ImageLoader</code>的使用。<br>可以通过<a href="https://github.com/nostra13/Android-Universal-Image-Loader/raw/master/downloads/universal-image-loader-1.9.5.jar" target="_blank" rel="noopener">这里</a>下载<code>universal-imager-loader</code>的jar包，并将其导入到自己的项目中。<br>然后可以在<code>Application</code>或者<code>Activity</code>中初始化<code>ImageLoade</code>，参考如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class YourApplication extends Application &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onCreate() &#123;</span><br><span class="line">        super.onCreate();</span><br><span class="line">        &#x2F;&#x2F;创建默认的ImageLoader配置参数  </span><br><span class="line">        ImageLoaderConfiguration configuration &#x3D; ImageLoaderConfiguration  </span><br><span class="line">                .createDefault(this);  </span><br><span class="line">          </span><br><span class="line">        &#x2F;&#x2F;Initialize ImageLoader with configuration.  </span><br><span class="line">        ImageLoader.getInstance().init(configuration);  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，如果涉及到网络操作和磁盘缓存的话，有或者是在<code>Application</code>中进行初始化的话，记得要在<code>Manifest</code>中进行申明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;manifest&gt;  </span><br><span class="line">    &lt;uses-permission android:name&#x3D;&quot;android.permission.INTERNET&quot; &#x2F;&gt;  </span><br><span class="line">    &lt;!-- Include next permission if you want to allow UIL to cache images on SD card --&gt;  </span><br><span class="line">    &lt;uses-permission android:name&#x3D;&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; &#x2F;&gt;  </span><br><span class="line">    ...  </span><br><span class="line">    &lt;application android:name&#x3D;&quot;YourApplication&quot;&gt;  </span><br><span class="line">        ...  </span><br><span class="line">    &lt;&#x2F;application&gt;  </span><br><span class="line">&lt;&#x2F;manifest&gt;</span><br></pre></td></tr></table></figure>
<p>接下来我们就可以愉快的来加载图片了，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ImageLoader.getInstance().displayImage(imageUri, imageView);</span><br></pre></td></tr></table></figure>
<p>当然，如果你想添加监听，可以这么写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ImageLoader.getInstance().loadImage(imageUrl, new SimpleImageLoadingListener()&#123;  </span><br><span class="line">  </span><br><span class="line">            @Override  </span><br><span class="line">            public void onLoadingComplete(String imageUri, View view,  </span><br><span class="line">                    Bitmap loadedImage) &#123;  </span><br><span class="line">                super.onLoadingComplete(imageUri, view, loadedImage);  </span><br><span class="line">                mImageView.setImageBitmap(loadedImage);  </span><br><span class="line">            &#125;  </span><br><span class="line">              </span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>
<p>至于更多的用法这里就不介绍了，如果有需要，可以参看这篇<a href="http://blog.csdn.net/abc6368765/article/details/52510761" target="_blank" rel="noopener">博客</a>，了解更多关于ImageLoader的用法。下面就开始了源码的解析之路。</p>
<h1 id="ImageLoaderConfiguration配置实现"><a href="#ImageLoaderConfiguration配置实现" class="headerlink" title="ImageLoaderConfiguration配置实现"></a>ImageLoaderConfiguration配置实现</h1><p>我们首先还是从<code>imageLoader</code>的配置开始开始源码的探究之旅把。在上面的使用实例中，我们使用<code>createDefault()</code>方法来初始化配置，那么<code>imageLoader</code>的默认配置究竟是些什么呢？下面直接上代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">public static ImageLoaderConfiguration createDefault(Context context) &#123;</span><br><span class="line">    return new Builder(context).build();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public ImageLoaderConfiguration build() &#123;</span><br><span class="line">    initEmptyFieldsWithDefaultValues();</span><br><span class="line">    return new ImageLoaderConfiguration(this);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void initEmptyFieldsWithDefaultValues() &#123;</span><br><span class="line">    if (taskExecutor &#x3D;&#x3D; null) &#123;</span><br><span class="line">        taskExecutor &#x3D; DefaultConfigurationFactory</span><br><span class="line">                .createExecutor(threadPoolSize, threadPriority, tasksProcessingType);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        customExecutor &#x3D; true;</span><br><span class="line">    &#125;</span><br><span class="line">    if (taskExecutorForCachedImages &#x3D;&#x3D; null) &#123;</span><br><span class="line">        taskExecutorForCachedImages &#x3D; DefaultConfigurationFactory</span><br><span class="line">                .createExecutor(threadPoolSize, threadPriority, tasksProcessingType);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        customExecutorForCachedImages &#x3D; true;</span><br><span class="line">    &#125;</span><br><span class="line">    if (diskCache &#x3D;&#x3D; null) &#123;</span><br><span class="line">        if (diskCacheFileNameGenerator &#x3D;&#x3D; null) &#123;</span><br><span class="line">            diskCacheFileNameGenerator &#x3D; DefaultConfigurationFactory.createFileNameGenerator();</span><br><span class="line">        &#125;</span><br><span class="line">        diskCache &#x3D; DefaultConfigurationFactory</span><br><span class="line">                .createDiskCache(context, diskCacheFileNameGenerator, diskCacheSize, diskCacheFileCount);</span><br><span class="line">    &#125;</span><br><span class="line">    if (memoryCache &#x3D;&#x3D; null) &#123;</span><br><span class="line">        memoryCache &#x3D; DefaultConfigurationFactory.createMemoryCache(context, memoryCacheSize);</span><br><span class="line">    &#125;</span><br><span class="line">    if (denyCacheImageMultipleSizesInMemory) &#123;</span><br><span class="line">        memoryCache &#x3D; new FuzzyKeyMemoryCache(memoryCache, MemoryCacheUtils.createFuzzyKeyComparator());</span><br><span class="line">    &#125;</span><br><span class="line">    if (downloader &#x3D;&#x3D; null) &#123;</span><br><span class="line">        downloader &#x3D; DefaultConfigurationFactory.createImageDownloader(context);</span><br><span class="line">    &#125;</span><br><span class="line">    if (decoder &#x3D;&#x3D; null) &#123;</span><br><span class="line">        decoder &#x3D; DefaultConfigurationFactory.createImageDecoder(writeLogs);</span><br><span class="line">    &#125;</span><br><span class="line">    if (defaultDisplayImageOptions &#x3D;&#x3D; null) &#123;</span><br><span class="line">        defaultDisplayImageOptions &#x3D; DisplayImageOptions.createSimple();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line">private ImageLoaderConfiguration(final Builder builder) &#123;</span><br><span class="line">    resources &#x3D; builder.context.getResources();&#x2F;&#x2F;程序本地资源访问器</span><br><span class="line">    maxImageWidthForMemoryCache &#x3D; builder.maxImageWidthForMemoryCache;&#x2F;&#x2F;内存缓存的图片最大宽度 </span><br><span class="line">    maxImageHeightForMemoryCache &#x3D; builder.maxImageHeightForMemoryCache;&#x2F;&#x2F;内存缓存的图片最大高度 </span><br><span class="line">    maxImageWidthForDiskCache &#x3D; builder.maxImageWidthForDiskCache;&#x2F;&#x2F;磁盘缓存的图片最大宽度 </span><br><span class="line">    maxImageHeightForDiskCache &#x3D; builder.maxImageHeightForDiskCache;&#x2F;&#x2F;磁盘缓存的图片最大高度 </span><br><span class="line">    processorForDiskCache &#x3D; builder.processorForDiskCache;&#x2F;&#x2F;图片处理器，用于处理从磁盘缓存中读取到的图片 </span><br><span class="line">    taskExecutor &#x3D; builder.taskExecutor;&#x2F;&#x2F;ImageLoaderEngine中用于执行从源获取图片任务的 Executor。</span><br><span class="line">    taskExecutorForCachedImages &#x3D; builder.taskExecutorForCachedImages;&#x2F;&#x2F;ImageLoaderEngine中用于执行从缓存获取图片任务的 Executor。</span><br><span class="line">    threadPoolSize &#x3D; builder.threadPoolSize;&#x2F;&#x2F;上面两个默认线程池的核心池大小，即最大并发数。</span><br><span class="line">    threadPriority &#x3D; builder.threadPriority;&#x2F;&#x2F;上面两个默认线程池的线程优先级。</span><br><span class="line">    tasksProcessingType &#x3D; builder.tasksProcessingType;&#x2F;&#x2F;上面两个默认线程池的线程队列类型。目前只有 FIFO, LIFO 两种可供选择。</span><br><span class="line">    diskCache &#x3D; builder.diskCache;&#x2F;&#x2F;图片磁盘缓存，一般放在 SD 卡。</span><br><span class="line">    memoryCache &#x3D; builder.memoryCache;&#x2F;&#x2F;图片内存缓存。</span><br><span class="line">    defaultDisplayImageOptions &#x3D; builder.defaultDisplayImageOptions;&#x2F;&#x2F;图片显示的配置项。比如加载前、加载中、加载失败应该显示的占位图片，图片是否需要在磁盘缓存，是否需要在内存缓存等。</span><br><span class="line">    downloader &#x3D; builder.downloader;&#x2F;&#x2F;图片下载器。</span><br><span class="line">    decoder &#x3D; builder.decoder;&#x2F;&#x2F;图片解码器，内部可使用我们常用的BitmapFactory.decode(…)将图片资源解码成Bitmap对象。</span><br><span class="line"></span><br><span class="line">    customExecutor &#x3D; builder.customExecutor;&#x2F;&#x2F;用户是否自定义了上面的 taskExecutor。</span><br><span class="line">    customExecutorForCachedImages &#x3D; builder.customExecutorForCachedImages;&#x2F;&#x2F;用户是否自定义了上面的 taskExecutorForCachedImages。</span><br><span class="line"></span><br><span class="line">    networkDeniedDownloader &#x3D; new NetworkDeniedImageDownloader(downloader);&#x2F;&#x2F;不允许访问网络的图片下载器。</span><br><span class="line">    slowNetworkDownloader &#x3D; new SlowNetworkImageDownloader(downloader);&#x2F;&#x2F;慢网络情况下的图片下载器。</span><br><span class="line"></span><br><span class="line">    L.writeDebugLogs(builder.writeLogs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码有点多，但是很简单也很清晰，就是一些列初始化的代码。通过一些系列的调用，在<code>initEmptyFieldsWithDefaultValues</code>方法中对一些没有配置的进行的项进行配置，并通过<code>ImageLoaderConfiguration</code>给出默认的参数配置。对于其中的一些配置，在上面的注释中已经表明，<code>ImageLoaderConfiguration</code>中默认的配置，可以参考第48-73行。<br>至于<code>initEmptyFieldsWithDefaultValues</code>中的配置，在这里进行简单的介绍：</p>
<ul>
<li><strong>taskExecutor</strong> 从源获取图片任务的线程池</li>
<li><strong>taskExecutorForCachedImages</strong> 用于执行从缓存获取图片任务的线程池<br>前面两个线程池的参数如下：<table>
<thead>
<tr>
<th>核心线程数</th>
<th align="right">最大线程数</th>
<th align="center">空闲线程等待时间</th>
<th>容器</th>
</tr>
</thead>
<tbody><tr>
<td>3</td>
<td align="right">3</td>
<td align="center">0s</td>
<td>2</td>
</tr>
<tr>
<td>前面两个线程池如果用户自定义的相应的线程池来实现的话，就会将<code>customExecutor</code>置为<code>true</code>，或将<code>customExecutorForCachedImages</code>置为<code>true</code>。其实<code>customExecutor</code>存在的意义就在于判断用户有没有自定义从源获取图片任务的线程池，<code>customExecutorForCachedImages</code>存在的意义判断在于用户判断用户有没有重写从缓存获取图片的线程池。</td>
<td align="right"></td>
<td align="center"></td>
<td></td>
</tr>
</tbody></table>
</li>
<li><strong>diskCacheFileNameGenerator</strong> 默认实现为<code>HashCodeFileNameGenerator</code>，即用<code>mageUri.hashCode()</code>值当前图片名字。</li>
<li><strong>diskCache</strong>用于表示图片磁盘的缓存，默认实现为<code>createDiskCache</code>，默认的算法为<code>LruDiskCache</code>算法，缓存的目录为SD卡下的<code>/data/data/&quot; + context.getPackageName() + &quot;/cache/uil-images</code>目录下。</li>
<li><strong>memoryCache</strong>用于表示图片内存的缓存，默认实现为<code>createMemoryCache</code>,默认使用的算法为<code>LruMemoryCache</code>。</li>
<li><strong>denyCacheImageMultipleSizesInMemory</strong> 为<code>true</code>时，表示内存缓存不允许缓存一张图片的多个尺寸。这个时候用通过<code>FuzzyKeyMemoryCache</code>来构建<code>memoryCache</code></li>
<li><strong>downloader</strong>表示图片下载器，默认实现为<code>createImageDownloader</code>，最终通过<code>BaseImageDownloader</code>构建下载器，其下载器中重要的两个参数分别为：连接超时时间<code>connectTimeout</code>默认值为5分钟，读取超时时间<code>readTimeout</code>默认值为20分钟。</li>
<li><strong>decoder</strong> 表示图片解码器，默认实现为<code>createImageDecoder</code>，最终通过<code>BaseImageDecoder</code>实现。</li>
<li><strong>defaultDisplayImageOptions</strong> 表示默认参数，最终回调到<code>DisplayImageOptions</code>方法中，里面设计相关的参数初始化。这里就不展开了。</li>
</ul>
<h1 id="加载配置"><a href="#加载配置" class="headerlink" title="加载配置"></a>加载配置</h1><p>我们首先看<code>Application</code>中<code>imgaerLoader</code>设置配置的方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ImageLoader.getInstance().init(configuration);</span><br></pre></td></tr></table></figure>
<p>接下来我们继续分析上面的代码是如何将配置应用到ImageLoader中的。首先是<code>ImageLoader.getInstance()</code>实例化一个<code>ImageLoader</code>，通过代码来看实例化的过程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static ImageLoader getInstance() &#123;</span><br><span class="line">    if (instance &#x3D;&#x3D; null) &#123;</span><br><span class="line">        synchronized (ImageLoader.class) &#123;</span><br><span class="line">            if (instance &#x3D;&#x3D; null) &#123;</span><br><span class="line">                instance &#x3D; new ImageLoader();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出来，<code>getInstance</code>就是获取一个<code>ImageLoader</code>实例，运用了一个双重锁的单利模式，很简单，就不做解释了。<br>重点看<code>init</code>方法。具体在<code>ImageLoader</code>类中的实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public synchronized void init(ImageLoaderConfiguration configuration) &#123;</span><br><span class="line">        if (configuration &#x3D;&#x3D; null) &#123;</span><br><span class="line">            throw new IllegalArgumentException(ERROR_INIT_CONFIG_WITH_NULL);</span><br><span class="line">        &#125;</span><br><span class="line">        if (this.configuration &#x3D;&#x3D; null) &#123;</span><br><span class="line">            L.d(LOG_INIT_CONFIG);</span><br><span class="line">            engine &#x3D; new ImageLoaderEngine(configuration);</span><br><span class="line">            this.configuration &#x3D; configuration;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            L.w(WARNING_RE_INIT_CONFIG);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看出来，<code>init</code>的实现也是非常简单的。首先判断传入的<code>configuration</code>参数是否为空，为空就直接抛出一个异常，不为空就判断当前类属性<code>configuration</code>是否为空，类中<code>configuration</code>属性为空时调用<code>ImageLoaderEngine</code>构建<code>engine</code>对象，否则就打印警告日志。所以整个方法中最重要的一个语句就是<code>new ImageLoaderEngine(configuration);</code>。这里首先介绍一个<code>ImageLoaderEngine</code>类的作用。简单描述就是<code>ImageLoaderEngine</code>是任务分发器，负责分发<code>LoadAndDisplayImageTask</code>和<code>ProcessAndDisplayImageTask</code>给具体的线程池去执行。具体实现后面会讲到。</p>
<h1 id="加载图片"><a href="#加载图片" class="headerlink" title="加载图片"></a>加载图片</h1><p>通过上面两个步骤，imgaeLoder的参数配置已经设置完毕，接下来我们就可以用imageLoader加载图片了。下面是三种加载图片的方式：<br><strong>加载方式一，异步加载并显示图片到对应的imagerAware上</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ImageLoader.getInstance().displayImage(imageUrl,imageView);</span><br></pre></td></tr></table></figure>
<p><strong>加载方式二，异步加载图片并执行回调接口</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">ImageLoader.getInstance().loadImage(imageUrl,new  ImageLoadingListener() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onLoadingStarted(String imageUri, View view) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onLoadingFailed(String imageUri, View view, FailReason failReason) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onLoadingComplete(String imageUri, View view, Bitmap loadedImage) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onLoadingCancelled(String imageUri, View view) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><strong>加载方式三，同步加载图片</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ImageLoader.getInstance().loadImageSync(imageUrl);</span><br></pre></td></tr></table></figure>
<p>针对上面三种方法，我们先分析第一种加载图片的方法，其余的两种加载图片的分析也差不多，后面就不具体分析了，只是简单的体现其不同点。<br>我们来看<code>displayImage</code>方法在<code>ImageLoader</code>类中的实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public void displayImage(String uri, ImageView imageView) &#123;</span><br><span class="line">    displayImage(uri, new ImageViewAware(imageView), null, null, null);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void displayImage(String uri, ImageView imageView, ImageSize targetImageSize) &#123;</span><br><span class="line">    displayImage(uri, new ImageViewAware(imageView), null, targetImageSize, null, null);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">public void displayImage(String uri, ImageView imageView, DisplayImageOptions options) &#123;</span><br><span class="line">    displayImage(uri, new ImageViewAware(imageView), options, null, null);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void displayImage(String uri, ImageView imageView, ImageLoadingListener listener) &#123;</span><br><span class="line">    displayImage(uri, new ImageViewAware(imageView), null, listener, null);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void displayImage(String uri, ImageView imageView, DisplayImageOptions options,</span><br><span class="line">        ImageLoadingListener listener) &#123;</span><br><span class="line">    displayImage(uri, imageView, options, listener, null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看到上面的<code>displayImage</code>有很多中重载的方法，最终他们都会调用到下面的这个<code>displayImage</code>方法中来。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">public void displayImage(String uri, ImageAware imageAware, DisplayImageOptions options,</span><br><span class="line">        ImageSize targetSize, ImageLoadingListener listener, ImageLoadingProgressListener progressListener) &#123;</span><br><span class="line">    &#x2F;&#x2F;省略了部分判空代码</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    if (targetSize &#x3D;&#x3D; null) &#123;</span><br><span class="line">        targetSize &#x3D; ImageSizeUtils.defineTargetSizeForView(imageAware, configuration.getMaxImageSize());</span><br><span class="line">    &#125;</span><br><span class="line">    String memoryCacheKey &#x3D; MemoryCacheUtils.generateKey(uri, targetSize);</span><br><span class="line">    engine.prepareDisplayTaskFor(imageAware, memoryCacheKey);</span><br><span class="line"></span><br><span class="line">    listener.onLoadingStarted(uri, imageAware.getWrappedView());</span><br><span class="line"></span><br><span class="line">    Bitmap bmp &#x3D; configuration.memoryCache.get(memoryCacheKey);</span><br><span class="line">    if (bmp !&#x3D; null &amp;&amp; !bmp.isRecycled()) &#123;</span><br><span class="line">        L.d(LOG_LOAD_IMAGE_FROM_MEMORY_CACHE, memoryCacheKey);</span><br><span class="line"></span><br><span class="line">        if (options.shouldPostProcess()) &#123;</span><br><span class="line">            ImageLoadingInfo imageLoadingInfo &#x3D; new ImageLoadingInfo(uri, imageAware, targetSize, memoryCacheKey,</span><br><span class="line">                    options, listener, progressListener, engine.getLockForUri(uri));</span><br><span class="line">            ProcessAndDisplayImageTask displayTask &#x3D; new ProcessAndDisplayImageTask(engine, bmp, imageLoadingInfo,</span><br><span class="line">                    defineHandler(options));</span><br><span class="line">            if (options.isSyncLoading()) &#123;</span><br><span class="line">                displayTask.run();</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                engine.submit(displayTask);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            options.getDisplayer().display(bmp, imageAware, LoadedFrom.MEMORY_CACHE);</span><br><span class="line">            listener.onLoadingComplete(uri, imageAware.getWrappedView(), bmp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (options.shouldShowImageOnLoading()) &#123;</span><br><span class="line">            imageAware.setImageDrawable(options.getImageOnLoading(configuration.resources));</span><br><span class="line">        &#125; else if (options.isResetViewBeforeLoading()) &#123;</span><br><span class="line">            imageAware.setImageDrawable(null);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ImageLoadingInfo imageLoadingInfo &#x3D; new ImageLoadingInfo(uri, imageAware, targetSize, memoryCacheKey,</span><br><span class="line">                options, listener, progressListener, engine.getLockForUri(uri));</span><br><span class="line">        LoadAndDisplayImageTask displayTask &#x3D; new LoadAndDisplayImageTask(engine, imageLoadingInfo,</span><br><span class="line">                defineHandler(options));</span><br><span class="line">        if (options.isSyncLoading()) &#123;</span><br><span class="line">            displayTask.run();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            engine.submit(displayTask);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从第6行开始看，当没有传入<code>targetSize</code>目标尺寸时，会通过第6行的代码产生一个合适的尺寸。具体逻辑为，当image没有尺寸时就采用测量出来的最大尺寸，当image有尺寸时就用image本身的尺寸。获取最大尺寸的逻辑为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ImageSize getMaxImageSize() &#123;</span><br><span class="line">        &#x2F;&#x2F;获取屏幕像素</span><br><span class="line">        DisplayMetrics displayMetrics &#x3D; resources.getDisplayMetrics();</span><br><span class="line"></span><br><span class="line">        int width &#x3D; maxImageWidthForMemoryCache;&#x2F;&#x2F;最大的图片内存缓存宽度</span><br><span class="line">        if (width &lt;&#x3D; 0) &#123;</span><br><span class="line">            width &#x3D; displayMetrics.widthPixels;&#x2F;&#x2F;屏幕宽度</span><br><span class="line">        &#125;</span><br><span class="line">        int height &#x3D; maxImageHeightForMemoryCache;&#x2F;&#x2F;最大的图片内存缓存高度</span><br><span class="line">        if (height &lt;&#x3D; 0) &#123;</span><br><span class="line">            height &#x3D; displayMetrics.heightPixels;&#x2F;&#x2F;屏幕高度</span><br><span class="line">        &#125;</span><br><span class="line">        return new ImageSize(width, height);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>即最大的尺寸为：如设置了<code>maxImageWidthForMemoryCache</code>值且该值大于0，则最大尺寸为其设置的值，否则屏幕宽度。在高度上也一样，就不赘述了。综上，我们可以知道要显示图片的大小的逻辑，<strong>我们设置了图片显示的尺寸，则图片尺寸为我们设置的尺寸。否则图片的本身有尺寸的时候，显示的就是自己本身的尺寸，否则就显示最大的图片尺寸。当最大图片内存缓存尺寸大于0时，最大图片尺寸即为最大图片内存尺寸，否则为屏幕尺寸。</strong><br>分析了那么久，其实还只是分析了<code>displayImage</code>方法的一个方法，下面我们继续看<code>displayImage</code>中的实现。在计算好目标图片的尺寸之后，利用<code>generateKey</code>方法生成一个<code>memoryCacheKey</code>，这里的<code>memoryCacheKey</code>的组成形式为<code>URI + size</code>，用于表示要加载到内存中的图片。通过第10行代码，将要加载的图片加入到<code>cacheKeysForImageAwares</code>队列中,他是一个<code>Collections.synchronizedMap(new HashMap&lt;Integer, String&gt;())</code>类型的队列，他用来记录正在加载的任务，加载图片的时候会将<code>ImageView</code>的<code>id</code>和图片的<code>url</code>加上尺寸加入到<code>HashMap</code>中，加载完成之后会将其移除。然后通过第12行的代码回调<code>onLoadingStarted</code>方法，这个方法就是我们在使用时的<code>onLoadingStarted</code>方法回调,具体参考上面的<strong>加载方式二，异步加载图片并执行回调接口</strong>的使用实例。<br>对于最终调用的<code>displayImage</code>方法代码很重要，所以我们继续往下分析其中的代码。以下的代码已经省略前面已经分析的代码，完整代码参考前面的代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Bitmap bmp &#x3D; configuration.memoryCache.get(memoryCacheKey);</span><br><span class="line">if (bmp !&#x3D; null &amp;&amp; !bmp.isRecycled()) &#123;&#x2F;&#x2F;本地能获取到图片</span><br><span class="line">    L.d(LOG_LOAD_IMAGE_FROM_MEMORY_CACHE, memoryCacheKey);</span><br><span class="line"></span><br><span class="line">    if (options.shouldPostProcess()) &#123;</span><br><span class="line">        ---</span><br><span class="line">        &#x2F;&#x2F;缺失的代码片段1</span><br><span class="line">        ---</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        options.getDisplayer().display(bmp, imageAware, LoadedFrom.MEMORY_CACHE);</span><br><span class="line">        listener.onLoadingComplete(uri, imageAware.getWrappedView(), bmp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    ---</span><br><span class="line">    这里实现从网络上获取图片的逻辑</span><br><span class="line">     &#x2F;&#x2F;缺失的代码片段2</span><br><span class="line">    ---</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先从内存中拿出将要加载的图片（bitmap格式），然后在图片不为空且没被回收的基础上开始加载图片的逻辑。第5行中有一个判断，我们如果在<code>DisplayImageOptions</code>中设置了<code>postProcessor</code>就进入true逻辑，不过默认<code>postProcessor</code>是为null的，<code>BitmapProcessor</code>接口主要是对<code>Bitmap</code>进行处理，这个框架并没有给出相对应的实现，如果我们有自己的需求的时候可以自己实现<code>BitmapProcessor</code>接口（比如将图片设置成圆形的）。我们先分析默认情况，即<code>shouldPostProcess</code>为<code>false</code>的情况下执行的第16-17行代码。第16行代码就将<code>Bitmap</code>设置到<code>ImageView</code>上面,这里我们可以在<code>DisplayImageOptions</code>中配置显示需求<code>displayer</code>，默认使用的是<code>SimpleBitmapDisplayer</code>，直接将<code>Bitmap</code>设置到<code>ImageView</code>上面。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public final class SimpleBitmapDisplayer implements BitmapDisplayer &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void display(Bitmap bitmap, ImageAware imageAware, LoadedFrom loadedFrom) &#123;</span><br><span class="line">        imageAware.setImageBitmap(bitmap);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，ImageLoader也为我们提供了其他显示的方式，如<code>CircleBitmapDisplayer</code>（）,<code>FadeInBitmapDisplayer</code>,<code>RoundeBitmapDisplayer</code>三种显示方式。第17行代码很好理解，就是回调到<code>onLoadingComplete</code>方法，提供给用户的回调。<br>接下来我们来看当用于设置了<code>postProcessor</code>下情况的逻辑，即上面缺失的代码片段1：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ImageLoadingInfo imageLoadingInfo &#x3D; new ImageLoadingInfo(uri, imageAware, targetSize, memoryCacheKey,</span><br><span class="line">                    options, listener, progressListener, engine.getLockForUri(uri));</span><br><span class="line">            ProcessAndDisplayImageTask displayTask &#x3D; new ProcessAndDisplayImageTask(engine, bmp, imageLoadingInfo,</span><br><span class="line">                    defineHandler(options));</span><br><span class="line">            if (options.isSyncLoading()) &#123;</span><br><span class="line">                displayTask.run();</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                engine.submit(displayTask);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>这里代码执行的情况就是用于需要回调图片记载的进度时执行，即用户指定了<code>postProcessor</code>对象，而<code>postProcessor</code>主要用于表示缓存在内存之后的处理程序。<br>其中的<code>ImageLoadingInfo</code>主要用来加载和显示图片任务需要的信息，<code>ProcessAndDisplayImageTask</code>主要用于处理并显示图片的任务，他实现了<code>Runnable</code>接口。然后通过<code>isSyncLoading</code>判断是同步还是异步，当<code>isSyncLoading</code>为ture时表示当前是同步执行。这里还有一个点需要特别说明以下：我们看第1行代码中的<code>engine.getLockForUri(uri)</code>，这个方法主要是用来给图片的URl加锁的，那么给URL要传入这个一个参数给<code>ImageLoadingInfo</code>呢？其实主要是实现对图片的复用，考虑这样一种场景，在一个LitView中，某个Item正在获取图片的过程中，我们将这个item滚出界面后又将其滚进来，滚进来如果没有加锁，该item又会去加载一次图片，为了避免多次对同一个URL重复请求，有必要对正在加载的URL加锁，当图片加载完成之后，就将锁释放掉。<br>我们在来分析同步执行的情况，直接执行<code>run()</code>,通过<code>displayTask</code>任务来执行，我们来了解<code>ProcessAndDisplayImageTask</code>中<code>run()</code>方法里面的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        L.d(LOG_POSTPROCESS_IMAGE, imageLoadingInfo.memoryCacheKey);</span><br><span class="line"></span><br><span class="line">        BitmapProcessor processor &#x3D; imageLoadingInfo.options.getPostProcessor();</span><br><span class="line">        &#x2F;&#x2F;图片处理器，用于处理从磁盘缓存中读取到的图片。</span><br><span class="line">        Bitmap processedBitmap &#x3D; processor.process(bitmap);</span><br><span class="line">        &#x2F;&#x2F;处理图片</span><br><span class="line">        DisplayBitmapTask displayBitmapTask &#x3D; new DisplayBitmapTask(processedBitmap, imageLoadingInfo, engine,</span><br><span class="line">                LoadedFrom.MEMORY_CACHE);</span><br><span class="line">                &#x2F;&#x2F;构建图片实现的任务</span><br><span class="line">        LoadAndDisplayImageTask.runTask(displayBitmapTask, imageLoadingInfo.options.isSyncLoading(), handler, engine);</span><br><span class="line">                &#x2F;&#x2F;执行图片显示任务</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，在从本地读取到图片的显示逻辑还是很简单的，<code>run</code>方法核心只有四行代码，首先对图片进行相对应的处理，然后构建图片显示的任务，最后执行图片显示的任务就OK了。我们来看<code>DisplayBitmapTask</code>中具体做了什么：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">final class DisplayBitmapTask implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    private final Bitmap bitmap;</span><br><span class="line">    private final String imageUri;</span><br><span class="line">    private final ImageAware imageAware;</span><br><span class="line">    private final String memoryCacheKey;</span><br><span class="line">    private final BitmapDisplayer displayer;</span><br><span class="line">    private final ImageLoadingListener listener;</span><br><span class="line">    private final ImageLoaderEngine engine;</span><br><span class="line">    private final LoadedFrom loadedFrom;</span><br><span class="line"></span><br><span class="line">    public DisplayBitmapTask(Bitmap bitmap, ImageLoadingInfo imageLoadingInfo, ImageLoaderEngine engine,</span><br><span class="line">            LoadedFrom loadedFrom) &#123;</span><br><span class="line">        this.bitmap &#x3D; bitmap;</span><br><span class="line">        imageUri &#x3D; imageLoadingInfo.uri;</span><br><span class="line">        imageAware &#x3D; imageLoadingInfo.imageAware;</span><br><span class="line">        memoryCacheKey &#x3D; imageLoadingInfo.memoryCacheKey;</span><br><span class="line">        displayer &#x3D; imageLoadingInfo.options.getDisplayer();</span><br><span class="line">        listener &#x3D; imageLoadingInfo.listener;</span><br><span class="line">        this.engine &#x3D; engine;</span><br><span class="line">        this.loadedFrom &#x3D; loadedFrom;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        if (imageAware.isCollected()) &#123;&#x2F;&#x2F;如果要显示的图片已经被GC回收</span><br><span class="line">            &#x2F;&#x2F;回调onLoadingCancelled接口</span><br><span class="line">            listener.onLoadingCancelled(imageUri, imageAware.getWrappedView());</span><br><span class="line">        &#125; else if (isViewWasReused()) &#123;&#x2F;&#x2F;如果</span><br><span class="line">             &#x2F;&#x2F;回调onLoadingCancelled接口</span><br><span class="line">            listener.onLoadingCancelled(imageUri, imageAware.getWrappedView());</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">             &#x2F;&#x2F;正在显示图片的逻辑</span><br><span class="line">            displayer.display(bitmap, imageAware, loadedFrom);</span><br><span class="line">            engine.cancelDisplayTaskFor(imageAware);</span><br><span class="line">            listener.onLoadingComplete(imageUri, imageAware.getWrappedView(), bitmap);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;** Checks whether memory cache key (image URI) for current ImageAware is actual *&#x2F;</span><br><span class="line">    &#x2F;&#x2F;检查内存中当前图片的key是否是真实存在的</span><br><span class="line">    private boolean isViewWasReused() &#123;</span><br><span class="line">        String currentCacheKey &#x3D; engine.getLoadingUriForView(imageAware);</span><br><span class="line">        return !memoryCacheKey.equals(currentCacheKey);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面<code>run</code>方法中的逻辑也比较清晰，首先对是否能进行图片显示的环境做一定的判断，在当前环境可以显示图片的前提下，利用<code>BitmapDisplayer</code>中的<code>display</code>方法显示图片，然后通过<code>cancelDisplayTaskFor</code>方法将当前显示的图片从<code>cacheKeysForImageAwares</code>队列中移除。这里的<code>cacheKeysForImageAwares</code>指的是<code>ImageAware</code>与内存缓存<code>key</code>对应的<code>map</code>，<code>key</code> 为<code>ImageAware</code>的<code>id</code>，<code>value</code>为内存缓存的<code>key</code>。完成之后就回调<code>onLoadingComplete</code>方法。<br>但是注意到，在<code>ProcessAndDisplayImageTask</code>中，并没有直接将<code>displayBitmapTask</code>通过<code>start</code>或者是<code>run</code>方法将其执行，而是通过一个<code>LoadAndDisplayImageTask</code>中的<code>runTask</code>方法，我们来看其实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static void runTask(Runnable r, boolean sync, Handler handler, ImageLoaderEngine engine) &#123;</span><br><span class="line">    if (sync) &#123;</span><br><span class="line">        r.run();</span><br><span class="line">    &#125; else if (handler &#x3D;&#x3D; null) &#123;</span><br><span class="line">        engine.fireCallback(r);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        handler.post(r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从实现上来说，还是比较简单的。如果是同步加载的话，就直接调用<code>run</code>方法，否则（异步执行）就调用<code>handler</code>调用<code>post</code>方法将其投递到主线程中去执行，这个<code>handler</code>的实现在<code>ImageLoader</code>中。如果<code>handler</code>为空的话，就取消图片显示，直接处理善后工作。这个<code>handler</code>在<code>ImageLoader</code>中的实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private static Handler defineHandler(DisplayImageOptions options) &#123;</span><br><span class="line">    Handler handler &#x3D; options.getHandler();</span><br><span class="line">    if (options.isSyncLoading()) &#123;</span><br><span class="line">        handler &#x3D; null;</span><br><span class="line">    &#125; else if (handler &#x3D;&#x3D; null &amp;&amp; Looper.myLooper() &#x3D;&#x3D; Looper.getMainLooper()) &#123;</span><br><span class="line">        handler &#x3D; new Handler();</span><br><span class="line">    &#125;</span><br><span class="line">    return handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出来，handler的创建也只会在异步加载的时候才会创建，同步情况下不会创建handler。</p>
<h2 id="从网络上加载图片"><a href="#从网络上加载图片" class="headerlink" title="从网络上加载图片"></a>从网络上加载图片</h2><p>分析完本地加载图片后，我们来分析上面<code>displayImage</code>中缺失的代码片段2，即本地无法获取图片的图片加载逻辑，我们先来看其中的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public void displayImage(String uri, ImageAware imageAware, DisplayImageOptions options,</span><br><span class="line">            ImageSize targetSize, ImageLoadingListener listener, ImageLoadingProgressListener progressListener) &#123;</span><br><span class="line">    ...</span><br><span class="line">        Bitmap bmp &#x3D; configuration.memoryCache.get(memoryCacheKey);</span><br><span class="line">        if (bmp !&#x3D; null &amp;&amp; !bmp.isRecycled()) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F;这下面的代码就是在本地无法获取图片的情况下加载图片的逻辑</span><br><span class="line">            if (options.shouldShowImageOnLoading()) &#123;</span><br><span class="line">                imageAware.setImageDrawable(options.getImageOnLoading(configuration.resources));</span><br><span class="line">            &#125; else if (options.isResetViewBeforeLoading()) &#123;</span><br><span class="line">                imageAware.setImageDrawable(null);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ImageLoadingInfo imageLoadingInfo &#x3D; new ImageLoadingInfo(uri, imageAware, targetSize, memoryCacheKey,</span><br><span class="line">                    options, listener, progressListener, engine.getLockForUri(uri));</span><br><span class="line">            LoadAndDisplayImageTask displayTask &#x3D; new LoadAndDisplayImageTask(engine, imageLoadingInfo,</span><br><span class="line">                    defineHandler(options));</span><br><span class="line">            if (options.isSyncLoading()) &#123;</span><br><span class="line">                displayTask.run();</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                engine.submit(displayTask);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，在无法获取本地图片情况下加载图片的逻辑稍微比本地加载图片的逻辑稍微多一点，但实现上很多方法是相同的，我们一点一点来开始分析：</p>
<ol>
<li>首先利用<code>shouldShowImageOnLoading</code>方法判断在加载的过程中是否需要显示图片，当用户设置了<code>imageResOnLoading</code>占位图片资源id，或者设置了加载中占位图片drawable对象时其返回值为<code>ture</code>，即执行在图片加载过程中显示占位图片的逻辑。</li>
<li>在用户没有设置占位图片的情况下，会继续判断是否需要重设图片，若需要重设图片，就将图片设为null。</li>
<li>至于这里的<code>ImageLoadingInfo</code>(加载和显示图片任务需要的信息)和前面的实现一样，这里就不重复介绍了。</li>
<li>这里的<code>LoadAndDisplayImageTask</code>，为下载和显示图片任务，用于从网络、文件系统或者内存获取图片并解析，然后调用<code>DisplayBitmapTask</code>在<code>ImageAware</code>中显示图片。</li>
<li>在同步加载的情况下，直接运行<code>displayTask</code>。</li>
<li>异步加载的情况下，将<code>displayTask</code>提交到<code>taskDistributor</code>线程池中运行。<br>接下来，我们就具体分析<code>LoadAndDisplayImageTask</code>中的<code>run</code>方法。下面是<code>LoadAndDisplayImageTask</code>类中<code>run</code>的具体实现：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">    if (waitIfPaused()) return;</span><br><span class="line">    if (delayIfNeed()) return;</span><br><span class="line"></span><br><span class="line">    ---</span><br><span class="line">    暂时神略</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
可以看到，<code>LoadAndDisplayImageTask</code>中的<code>run()</code>方法里面的逻辑还是稍微有点复杂的。我们一点一点来分析；<br>首先看前面两个方法的实现，即3-4行的代码实现，他们在<code>LoadAndDisplayImageTask</code>类中的实现代码如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;主要用于判断当前线程是否被打断，被打断返回ture，否则返回isTaskNotActual()的返回值</span><br><span class="line">private boolean waitIfPaused() &#123;</span><br><span class="line">    AtomicBoolean pause &#x3D; engine.getPause();</span><br><span class="line">    if (pause.get()) &#123;</span><br><span class="line">        synchronized (engine.getPauseLock()) &#123;</span><br><span class="line">            if (pause.get()) &#123;</span><br><span class="line">                L.d(LOG_WAITING_FOR_RESUME, memoryCacheKey);</span><br><span class="line">                try &#123;</span><br><span class="line">                    engine.getPauseLock().wait();</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    L.e(LOG_TASK_INTERRUPTED, memoryCacheKey);</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">                L.d(LOG_RESUME_AFTER_PAUSE, memoryCacheKey);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return isTaskNotActual();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;主要用于判断是否需要预处理，不要要返回false，需要返回isTaskNotActual()的返回值</span><br><span class="line">private boolean delayIfNeed() &#123;</span><br><span class="line">    if (options.shouldDelayBeforeLoading()) &#123;</span><br><span class="line">        L.d(LOG_DELAY_BEFORE_LOADING, options.getDelayBeforeLoading(), memoryCacheKey);</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(options.getDelayBeforeLoading());</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            L.e(LOG_TASK_INTERRUPTED, memoryCacheKey);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return isTaskNotActual();</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;主要用于判断imageVire是否被回收和重用，满足其中一个条件返回ture，否则返回false</span><br><span class="line">private boolean isTaskNotActual() &#123;</span><br><span class="line">    return isViewCollected() || isViewReused();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;主要用于判断ImageView是否被GC回收了，回收了返回ture，否者返回false</span><br><span class="line">private boolean isViewCollected() &#123;</span><br><span class="line">    if (imageAware.isCollected()) &#123;</span><br><span class="line">        L.d(LOG_TASK_CANCELLED_IMAGEAWARE_COLLECTED, memoryCacheKey);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;主要用于判断imageView是否被重用，被重用返回true，否则返回false</span><br><span class="line">private boolean isViewReused() &#123;</span><br><span class="line">    String currentCacheKey &#x3D; engine.getLoadingUriForView(imageAware);</span><br><span class="line">    &#x2F;&#x2F; Check whether memory cache key (image URI) for current ImageAware is actual.</span><br><span class="line">    &#x2F;&#x2F; If ImageAware is reused for another task then current task should be cancelled.</span><br><span class="line">    boolean imageAwareWasReused &#x3D; !memoryCacheKey.equals(currentCacheKey);</span><br><span class="line">    if (imageAwareWasReused) &#123;</span><br><span class="line">        L.d(LOG_TASK_CANCELLED_IMAGEAWARE_REUSED, memoryCacheKey);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
看起来好像也有点复杂，但是并不难，我们直接一路看过去就好了。每个方法的作用我都已经在代码中添加了注释了，这里我们来整理一下思路：通过上面的源码，我们基本上可以确定他们的作用是什么了，但是为什么需要他们呢？我们试想这样一种场景，在使用ListView来显示图片时，在手指滑动的时候一般不会去加载图片，因为在这个过程中很多图片是没有必要加载的。这个时候我们就可以通过<code>PauseOnScrollListener(ImageLoader imageLoader, boolean pauseOnScroll, boolean pauseOnFling)</code>来控制在滑动过程中图片的加载。第一个参数用来控制手指按着滑动情况下的是否加载图片，第二个参数用来控制手指松开后时候加载图片。至于中间参数的参数和值的传递比较简单，这里就不全部给出来了，可以自行通过查看源码了解<code>pauseOnScroll</code>是如何改变<code>waitIfPaused</code>方法中<code>pause</code>的值的（默认为false）。<br>至于<code>isViewReused</code>的方法存在的意义就更好理解了，在ListView中存在一种复用的优化策略，即在ListView在滑动时，会复用Item，为了避免图片显示时的错位情况，在ImageLoader就通过<code>isViewReused</code>来解决这个问题。</li>
</ol>
<p>接下来我们继续看<code>LoadAndDisplayImageTask</code>中的<code>run()</code>方法中剩下的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">    ...</span><br><span class="line">    ReentrantLock loadFromUriLock &#x3D; imageLoadingInfo.loadFromUriLock;&#x2F;&#x2F;获取锁</span><br><span class="line">    L.d(LOG_START_DISPLAY_IMAGE_TASK, memoryCacheKey);</span><br><span class="line">    if (loadFromUriLock.isLocked()) &#123;   &#x2F;&#x2F;判断锁是否被持有</span><br><span class="line">        L.d(LOG_WAITING_FOR_IMAGE_LOADED, memoryCacheKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    loadFromUriLock.lock();&#x2F;加锁</span><br><span class="line">    Bitmap bmp;</span><br><span class="line">    try &#123;</span><br><span class="line">        checkTaskNotActual();&#x2F;&#x2F;判断当前请求是否是可实现的，（当imageView被GC回收或者此次请求的URL无法获取imageView时时为不可实现的请求）</span><br><span class="line"></span><br><span class="line">        bmp &#x3D; configuration.memoryCache.get(memoryCacheKey);&#x2F;&#x2F;尝试从内存中加载图片</span><br><span class="line">        if (bmp &#x3D;&#x3D; null || bmp.isRecycled()) &#123;</span><br><span class="line">            bmp &#x3D; tryLoadBitmap();&#x2F;&#x2F;尝试从文件中加载图片，如果没有再去网络中获取，然后将bitmap保存在文件系统中。</span><br><span class="line">            &#x2F;&#x2F;这个方法是重点，后面会进行讲到</span><br><span class="line">            if (bmp &#x3D;&#x3D; null) return; &#x2F;&#x2F; listener callback already was fired</span><br><span class="line"></span><br><span class="line">            checkTaskNotActual();</span><br><span class="line">            checkTaskInterrupted();&#x2F;&#x2F;用于判断当前任务有没有被打断，被打断直接抛出异常</span><br><span class="line"></span><br><span class="line">            if (options.shouldPreProcess()) &#123;&#x2F;&#x2F;默认为ture，表示缓存在内存之前没有要处理的程序</span><br><span class="line">                L.d(LOG_PREPROCESS_IMAGE, memoryCacheKey);</span><br><span class="line">                bmp &#x3D; options.getPreProcessor().process(bmp);&#x2F;&#x2F;对bitmap进行适当的剪裁</span><br><span class="line">                if (bmp &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    L.e(ERROR_PRE_PROCESSOR_NULL, memoryCacheKey);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (bmp !&#x3D; null &amp;&amp; options.isCacheInMemory()) &#123;&#x2F;&#x2F;如果有必要缓存到内存中的话</span><br><span class="line">                L.d(LOG_CACHE_IMAGE_IN_MEMORY, memoryCacheKey);</span><br><span class="line">                configuration.memoryCache.put(memoryCacheKey, bmp);&#x2F;&#x2F;将图片保存到内存缓存中去</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            loadedFrom &#x3D; LoadedFrom.MEMORY_CACHE;</span><br><span class="line">            L.d(LOG_GET_IMAGE_FROM_MEMORY_CACHE_AFTER_WAITING, memoryCacheKey);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (bmp !&#x3D; null &amp;&amp; options.shouldPostProcess()) &#123;</span><br><span class="line">            L.d(LOG_POSTPROCESS_IMAGE, memoryCacheKey);</span><br><span class="line">            bmp &#x3D; options.getPostProcessor().process(bmp);&#x2F;&#x2F;自定义的bitmap操作会在这里进行</span><br><span class="line">            if (bmp &#x3D;&#x3D; null) &#123;</span><br><span class="line">                L.e(ERROR_POST_PROCESSOR_NULL, memoryCacheKey);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        checkTaskNotActual();</span><br><span class="line">        checkTaskInterrupted();</span><br><span class="line">    &#125; catch (TaskCancelledException e) &#123;</span><br><span class="line">        fireCancelEvent(); &#x2F;&#x2F;解移除的监听 上面很多方法会抛出异常都需要这个方法来移除监听</span><br><span class="line">        return;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        loadFromUriLock.unlock();&#x2F;&#x2F;释放锁</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DisplayBitmapTask displayBitmapTask &#x3D; new DisplayBitmapTask(bmp, imageLoadingInfo, engine, loadedFrom); &#x2F;&#x2F;构建显示任务</span><br><span class="line">    runTask(displayBitmapTask, syncLoading, handler, engine);&#x2F;&#x2F;将图片显示到指定的imageView上</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码也有点多，但是在添加了先关的注解之后，详细阅读起来还是比较简单的。这里在梳理一下整个<code>LoadAndDisplayImageTask</code>中的<code>run</code>方法的相关逻辑。首先会判断当前是否是可以加载图片的状态，不可以加载图片的话就直接返回，什么都不做。在可以加载图片的前提下，会给以下的核心逻辑代码添加一个锁：【首先尝试从内存中获取图片，没有对应的图片就会从磁盘中寻找，如果磁盘中也找不到，那么就只能从网络中去需找，在找到图片后将其存在文件系统中，如果用户定义了图片的预处理，就会执行用户定义的图片预处理，如果需要缓存到内存就会缓存到内存中，继而执行用户定义的图片后处理（提前是用户定义了图片后处理），最后判断一下当前状态是否还可以显示图片，若当前状态不能显示图片就会直接抛出异常，在catch语句中移除相关的监听。如果当前状态还可以显示图片，在finally语句中释放锁 】以此保障多线程的可靠性，然后执行图片显示任务将图片显示到图片上，到此完成了整个图片的加载。用流程图表示如下：<br><img src="http://upload-images.jianshu.io/upload_images/2178834-16069ef078012739.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片加载流程"></p>
<p>下面我们来分析上面<code>run()</code>方法中最重要的一个方法<code>tryLoadBitmap（）</code>，他的实现也在<code>LoadAndDisplayImageTask</code>类中，实现代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">private Bitmap tryLoadBitmap() throws TaskCancelledException &#123;</span><br><span class="line">    Bitmap bitmap &#x3D; null;</span><br><span class="line">    try &#123;</span><br><span class="line">        File imageFile &#x3D; configuration.diskCache.get(uri);&#x2F;&#x2F;先判断文件中有没有该文件</span><br><span class="line">        if (imageFile !&#x3D; null &amp;&amp; imageFile.exists() &amp;&amp; imageFile.length() &gt; 0) &#123;&#x2F;&#x2F;如果文件中有该文件，就直接调用decodeImage去解码图片</span><br><span class="line">            L.d(LOG_LOAD_IMAGE_FROM_DISK_CACHE, memoryCacheKey);</span><br><span class="line">            loadedFrom &#x3D; LoadedFrom.DISC_CACHE;</span><br><span class="line"></span><br><span class="line">            checkTaskNotActual();&#x2F;&#x2F;判断当前是否具有加载图片的状态，这个方法在前面已经解析过了</span><br><span class="line">            bitmap &#x3D; decodeImage(Scheme.FILE.wrap(imageFile.getAbsolutePath()));&#x2F;&#x2F;解码图片</span><br><span class="line">        &#125;</span><br><span class="line">        if (bitmap &#x3D;&#x3D; null || bitmap.getWidth() &lt;&#x3D; 0 || bitmap.getHeight() &lt;&#x3D; 0) &#123;</span><br><span class="line">        &#x2F;&#x2F;表示文件中没有找到图片，就会指定到网络上获取bitmap，</span><br><span class="line">            L.d(LOG_LOAD_IMAGE_FROM_NETWORK, memoryCacheKey);</span><br><span class="line">            loadedFrom &#x3D; LoadedFrom.NETWORK;</span><br><span class="line"></span><br><span class="line">            String imageUriForDecoding &#x3D; uri;</span><br><span class="line">            if (options.isCacheOnDisk() &amp;&amp; tryCacheImageOnDisk()) &#123;</span><br><span class="line">            &#x2F;&#x2F;options.isCacheOnDisk()用来表是否需要将图片缓存到文件系统中，默认为fasle。</span><br><span class="line">                imageFile &#x3D; configuration.diskCache.get(uri);</span><br><span class="line">                if (imageFile !&#x3D; null) &#123;</span><br><span class="line">                    imageUriForDecoding &#x3D; Scheme.FILE.wrap(imageFile.getAbsolutePath());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; </span><br><span class="line"></span><br><span class="line">            checkTaskNotActual();</span><br><span class="line">            bitmap &#x3D; decodeImage(imageUriForDecoding);</span><br><span class="line"></span><br><span class="line">            if (bitmap &#x3D;&#x3D; null || bitmap.getWidth() &lt;&#x3D; 0 || bitmap.getHeight() &lt;&#x3D; 0) &#123;</span><br><span class="line">                fireFailEvent(FailType.DECODING_ERROR, null);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (IllegalStateException e) &#123;</span><br><span class="line">        fireFailEvent(FailType.NETWORK_DENIED, null);</span><br><span class="line">    &#125; catch (TaskCancelledException e) &#123;</span><br><span class="line">        throw e;</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        L.e(e);</span><br><span class="line">        fireFailEvent(FailType.IO_ERROR, e);</span><br><span class="line">    &#125; catch (OutOfMemoryError e) &#123;</span><br><span class="line">        L.e(e);</span><br><span class="line">        fireFailEvent(FailType.OUT_OF_MEMORY, e);</span><br><span class="line">    &#125; catch (Throwable e) &#123;</span><br><span class="line">        L.e(e);</span><br><span class="line">        fireFailEvent(FailType.UNKNOWN, e);</span><br><span class="line">    &#125;</span><br><span class="line">    return bitmap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码虽然看起来有点多，但是逻辑还是很清晰的，我在关键的地方都添加了注释，相信阅读起来很简单。这里再次梳理一下<code>tryLoadBitmap</code>的逻辑吧。首先从尝试从文件中去获取图片，如果能从文件中获取图片的话，就判断当前状态是否可以加载图片，然后通过<code>decodeImage</code>方法将图片解码成可以显示的格式。如果文件中没有要显示的图片，在设置了从网络获取图片的前提下就会利用<code>tryCacheImageOnDisk</code>方法从网络上获取图片，然后将图片解码成要显示的格式，可以参考下面的流程图：<br><img src="http://upload-images.jianshu.io/upload_images/2178834-96999153d13488db.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="tryLoadBitmap流程图"><br>在上面的流程中，我们对其中两个重要的方法来进一步的探究其实现，一个方法是<code>decodeImage</code>，另一个是<code>tryCacheImageOnDisk()</code>。着两个方法的实现源码如下，他们都在<code>LoadAndDisplayImageTask</code>类中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;解码图片</span><br><span class="line">private Bitmap decodeImage(String imageUri) throws IOException &#123;</span><br><span class="line">&#x2F;&#x2F;获取图片的</span><br><span class="line">    ViewScaleType viewScaleType &#x3D; imageAware.getScaleType();</span><br><span class="line">    ImageDecodingInfo decodingInfo &#x3D; new ImageDecodingInfo(memoryCacheKey, imageUri, uri, targetSize, viewScaleType,</span><br><span class="line">            getDownloader(), options);</span><br><span class="line">    return decoder.decode(decodingInfo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;** @return &lt;b&gt;true&lt;&#x2F;b&gt; - if image was downloaded successfully; &lt;b&gt;false&lt;&#x2F;b&gt; - otherwise *&#x2F;</span><br><span class="line">private boolean tryCacheImageOnDisk() throws TaskCancelledException &#123;</span><br><span class="line">    L.d(LOG_CACHE_IMAGE_ON_DISK, memoryCacheKey);</span><br><span class="line"></span><br><span class="line">    boolean loaded;</span><br><span class="line">    try &#123;</span><br><span class="line">        loaded &#x3D; downloadImage();</span><br><span class="line">        if (loaded) &#123;</span><br><span class="line">            int width &#x3D; configuration.maxImageWidthForDiskCache;</span><br><span class="line">            int height &#x3D; configuration.maxImageHeightForDiskCache;</span><br><span class="line">            if (width &gt; 0 || height &gt; 0) &#123;</span><br><span class="line">                L.d(LOG_RESIZE_CACHED_IMAGE_FILE, memoryCacheKey);</span><br><span class="line">                resizeAndSaveImage(width, height); &#x2F;&#x2F; TODO : process boolean result</span><br><span class="line">                &#x2F;&#x2F;解码成bitmap图片，并保存他。关于这个方法就不在深入了。</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        L.e(e);</span><br><span class="line">        loaded &#x3D; false;</span><br><span class="line">    &#125;</span><br><span class="line">    return loaded;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;负责下载图片，并将其保存到文件缓存中</span><br><span class="line">private boolean downloadImage() throws IOException &#123;</span><br><span class="line">    InputStream is &#x3D; getDownloader().getStream(uri, options.getExtraForDownloader());</span><br><span class="line">    if (is &#x3D;&#x3D; null) &#123;</span><br><span class="line">        L.e(ERROR_NO_IMAGE_STREAM, memoryCacheKey);</span><br><span class="line">        return false;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            return configuration.diskCache.save(uri, is, this);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            IoUtils.closeSilently(is);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里就不对上面的代码进行解释了，我们直接看<code>decode</code>方法在<code>BaseImageDecoder</code>中的具体实现，至于其他的方法，请参考注释。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Bitmap decode(ImageDecodingInfo decodingInfo) throws IOException &#123;</span><br><span class="line">    Bitmap decodedBitmap;</span><br><span class="line">    ImageFileInfo imageInfo;</span><br><span class="line"></span><br><span class="line">    InputStream imageStream &#x3D; getImageStream(decodingInfo);</span><br><span class="line">    if (imageStream &#x3D;&#x3D; null) &#123;</span><br><span class="line">        L.e(ERROR_NO_IMAGE_STREAM, decodingInfo.getImageKey());</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    try &#123;</span><br><span class="line">        imageInfo &#x3D; defineImageSizeAndRotation(imageStream, decodingInfo);</span><br><span class="line">        imageStream &#x3D; resetStream(imageStream, decodingInfo);</span><br><span class="line">        Options decodingOptions &#x3D; prepareDecodingOptions(imageInfo.imageSize, decodingInfo);</span><br><span class="line">        decodedBitmap &#x3D; BitmapFactory.decodeStream(imageStream, null, decodingOptions);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        IoUtils.closeSilently(imageStream);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (decodedBitmap &#x3D;&#x3D; null) &#123;</span><br><span class="line">        L.e(ERROR_CANT_DECODE_IMAGE, decodingInfo.getImageKey());</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        decodedBitmap &#x3D; considerExactScaleAndOrientatiton(decodedBitmap, decodingInfo, imageInfo.exif.rotation,</span><br><span class="line">                imageInfo.exif.flipHorizontal);</span><br><span class="line">    &#125;</span><br><span class="line">    return decodedBitmap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>综上，我们暂时分析完了<code>run()</code>方法中逻辑和主要方法。接下来我们继续分析异步的情况，这里再次贴出之前<code>displayImage</code>的主要流程代码。因为之前的代码隔得有点远了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public void displayImage(String uri, ImageAware imageAware, DisplayImageOptions options,</span><br><span class="line">ImageSize targetSize, ImageLoadingListener listener, ImageLoadingProgressListener progressListener) &#123;</span><br><span class="line">      ---</span><br><span class="line">Bitmap bmp &#x3D; configuration.memoryCache.get(memoryCacheKey);</span><br><span class="line">    if (bmp !&#x3D; null &amp;&amp; !bmp.isRecycled()) &#123;</span><br><span class="line">        if (options.shouldPostProcess()) &#123;</span><br><span class="line">           ...</span><br><span class="line">           if (options.isSyncLoading()) &#123;</span><br><span class="line">                displayTask.run();</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                engine.submit(displayTask);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            options.getDisplayer().display(bmp, imageAware, LoadedFrom.MEMORY_CACHE);</span><br><span class="line">            listener.onLoadingComplete(uri, imageAware.getWrappedView(), bmp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">       ...</span><br><span class="line">       缺失的代码片段2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们之前已经分析了<code>displayTask.run();</code>的主要流程，接下来我们分析异步的执行<code>engine.submit(displayTask);</code>的主要流程和方法，他的实现主要在<code>ImageLoaderEngine</code>中，<code>submit</code>的实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void submit(ProcessAndDisplayImageTask task) &#123;</span><br><span class="line">    initExecutorsIfNeed();</span><br><span class="line">    taskExecutorForCachedImages.execute(task);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法很简单，首先只有两个方法调用，第一行代码从名字分析就应该是用来初始化Executor的（有必要的话），然后执行将此次任务提交到线程池中运行。在线程池中的执行也会执行调用之前的run方法，这里就不再分析了。我们分析一下第一行代码，验证一下我们的猜想是不是正确的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private void initExecutorsIfNeed() &#123;</span><br><span class="line">    if (!configuration.customExecutor &amp;&amp; ((ExecutorService) taskExecutor).isShutdown()) &#123;</span><br><span class="line">        taskExecutor &#x3D; createTaskExecutor();</span><br><span class="line">    &#125;</span><br><span class="line">    if (!configuration.customExecutorForCachedImages &amp;&amp; ((ExecutorService) taskExecutorForCachedImages)</span><br><span class="line">            .isShutdown()) &#123;</span><br><span class="line">        taskExecutorForCachedImages &#x3D; createTaskExecutor();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面代码分析：首先判断当前的<code>taskExecutor</code>是不是关闭了，如果处于关闭状态就创建一个新<code>的Executor</code>，这里的<code>taskExecutor</code>指的是用与执行从源获取图片任务的线程池。然后判断<code>taskExecutorForCachedImages</code>是不是就绪，如果他被关闭的话就创建一个新的线程池<code>taskExecutorForCachedImages</code>，用于执行从缓存获取图片任务的线程池。综上，源码验证了我们之前的猜测，<code>initExecutorsIfNeed</code>方法的确是用来初始化相关线程池的。</p>
<h2 id="displayImage方法总结"><a href="#displayImage方法总结" class="headerlink" title="displayImage方法总结"></a>displayImage方法总结</h2><p>从上面的流程中，可以明显看出来，<code>displayImage</code>方法就是<code>imageLoader</code>加载图片的核心，我们在这里在来总结一下整个<code>displayImage</code>的逻辑，先将整个<code>displayImage</code>代码完整的贴上来：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">public void displayImage(String uri, ImageAware imageAware, DisplayImageOptions options,</span><br><span class="line">        ImageSize targetSize, ImageLoadingListener listener, ImageLoadingProgressListener progressListener) &#123;</span><br><span class="line">    checkConfiguration();</span><br><span class="line">    if (imageAware &#x3D;&#x3D; null) &#123;</span><br><span class="line">        throw new IllegalArgumentException(ERROR_WRONG_ARGUMENTS);</span><br><span class="line">    &#125;</span><br><span class="line">    if (listener &#x3D;&#x3D; null) &#123;</span><br><span class="line">        listener &#x3D; defaultListener;</span><br><span class="line">    &#125;</span><br><span class="line">    if (options &#x3D;&#x3D; null) &#123;</span><br><span class="line">        options &#x3D; configuration.defaultDisplayImageOptions;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (TextUtils.isEmpty(uri)) &#123;</span><br><span class="line">        engine.cancelDisplayTaskFor(imageAware);</span><br><span class="line">        listener.onLoadingStarted(uri, imageAware.getWrappedView());</span><br><span class="line">        if (options.shouldShowImageForEmptyUri()) &#123;</span><br><span class="line">            imageAware.setImageDrawable(options.getImageForEmptyUri(configuration.resources));</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            imageAware.setImageDrawable(null);</span><br><span class="line">        &#125;</span><br><span class="line">        listener.onLoadingComplete(uri, imageAware.getWrappedView(), null);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (targetSize &#x3D;&#x3D; null) &#123;</span><br><span class="line">        targetSize &#x3D; ImageSizeUtils.defineTargetSizeForView(imageAware, configuration.getMaxImageSize());</span><br><span class="line">    &#125;</span><br><span class="line">    String memoryCacheKey &#x3D; MemoryCacheUtils.generateKey(uri, targetSize);</span><br><span class="line">    engine.prepareDisplayTaskFor(imageAware, memoryCacheKey);</span><br><span class="line"></span><br><span class="line">    listener.onLoadingStarted(uri, imageAware.getWrappedView());</span><br><span class="line"></span><br><span class="line">    Bitmap bmp &#x3D; configuration.memoryCache.get(memoryCacheKey);</span><br><span class="line">    if (bmp !&#x3D; null &amp;&amp; !bmp.isRecycled()) &#123;</span><br><span class="line">        L.d(LOG_LOAD_IMAGE_FROM_MEMORY_CACHE, memoryCacheKey);</span><br><span class="line"></span><br><span class="line">        if (options.shouldPostProcess()) &#123;</span><br><span class="line">            ImageLoadingInfo imageLoadingInfo &#x3D; new ImageLoadingInfo(uri, imageAware, targetSize, memoryCacheKey,</span><br><span class="line">                    options, listener, progressListener, engine.getLockForUri(uri));</span><br><span class="line">            ProcessAndDisplayImageTask displayTask &#x3D; new ProcessAndDisplayImageTask(engine, bmp, imageLoadingInfo,</span><br><span class="line">                    defineHandler(options));</span><br><span class="line">            if (options.isSyncLoading()) &#123;</span><br><span class="line">                displayTask.run();</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                engine.submit(displayTask);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            options.getDisplayer().display(bmp, imageAware, LoadedFrom.MEMORY_CACHE);</span><br><span class="line">            listener.onLoadingComplete(uri, imageAware.getWrappedView(), bmp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (options.shouldShowImageOnLoading()) &#123;</span><br><span class="line">            imageAware.setImageDrawable(options.getImageOnLoading(configuration.resources));</span><br><span class="line">        &#125; else if (options.isResetViewBeforeLoading()) &#123;</span><br><span class="line">            imageAware.setImageDrawable(null);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ImageLoadingInfo imageLoadingInfo &#x3D; new ImageLoadingInfo(uri, imageAware, targetSize, memoryCacheKey,</span><br><span class="line">                options, listener, progressListener, engine.getLockForUri(uri));</span><br><span class="line">        LoadAndDisplayImageTask displayTask &#x3D; new LoadAndDisplayImageTask(engine, imageLoadingInfo,</span><br><span class="line">                defineHandler(options));</span><br><span class="line">        if (options.isSyncLoading()) &#123;</span><br><span class="line">            displayTask.run();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            engine.submit(displayTask);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将上面代码用流程图可以表示为以下的表现形式。<br><img src="http://ovec6nnof.bkt.clouddn.com/imagerLoader%E4%B8%AD%E7%9A%84dispalyer%E9%80%BB%E8%BE%91.svg" alt="displayImage"></p>
<p align="center">（原创图，敬请批评指正）</p>

<p>可以看到，在上面流程图算比较复杂，但是逻辑很清晰，基本上所有的功能集中在<code>displayImage</code>中进行调度使用，所以给我们分析<code>ImageLoader</code>降低了不少的难度。<br>至于上面流程图中没有具体体现的任务可以参考前面的分析。</p>
<p>针对上面三种显示图片的方法，最终都会通过调用<code>displayImage</code>来实现，只是对其中的参数进行了一定的设置，这里就不在详细介绍了，有兴趣的可以自己查阅源码。</p>
<h1 id="LRUCache和DisLruCacher分析"><a href="#LRUCache和DisLruCacher分析" class="headerlink" title="LRUCache和DisLruCacher分析"></a>LRUCache和DisLruCacher分析</h1><h2 id="LRUCache"><a href="#LRUCache" class="headerlink" title="LRUCache"></a>LRUCache</h2><p>LruCache是android 3.1所提供的一个缓存类，他是一个泛型类，他内部采用一个<code>LinkedHashMap</code>以强引用的方式存储外界的缓存对象，其提供了<code>get</code>和<code>put</code>方法来完成缓存的获取和添加属性，当缓存满时，LruCache会移除较早使用的缓存对象，然后在添加新的缓存对象。<br>构造方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public LruCache(int maxSize) &#123;</span><br><span class="line">       if (maxSize &lt;&#x3D; 0) &#123;</span><br><span class="line">           throw new IllegalArgumentException(&quot;maxSize &lt;&#x3D; 0&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">       this.maxSize &#x3D; maxSize;</span><br><span class="line">       this.map &#x3D; new LinkedHashMap&lt;K, V&gt;(0, 0.75f, true);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，<code>LruCache</code>的构造方法非常简单，只需要传入一个maxSize设置最大的缓存对象即可，然后实例化<code>map</code>对象。<br>这里也附上get和put的源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">public final V get(K key) &#123;</span><br><span class="line">    if (key &#x3D;&#x3D; null) &#123;</span><br><span class="line">        throw new NullPointerException(&quot;key &#x3D;&#x3D; null&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    V mapValue;</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">        mapValue &#x3D; map.get(key);</span><br><span class="line">        if (mapValue !&#x3D; null) &#123;</span><br><span class="line">            hitCount++;</span><br><span class="line">            return mapValue;</span><br><span class="line">        &#125;</span><br><span class="line">        missCount++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  V createdValue &#x3D; create(key);</span><br><span class="line">    if (createdValue &#x3D;&#x3D; null) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">        createCount++;</span><br><span class="line">        mapValue &#x3D; map.put(key, createdValue);</span><br><span class="line"></span><br><span class="line">        if (mapValue !&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F; There was a conflict so undo that last put</span><br><span class="line">            map.put(key, mapValue);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            size +&#x3D; safeSizeOf(key, createdValue);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (mapValue !&#x3D; null) &#123;</span><br><span class="line">        entryRemoved(false, key, createdValue, mapValue);</span><br><span class="line">        return mapValue;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        trimToSize(maxSize);</span><br><span class="line">        return createdValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">public final V put(K key, V value) &#123;</span><br><span class="line">    if (key &#x3D;&#x3D; null || value &#x3D;&#x3D; null) &#123;</span><br><span class="line">        throw new NullPointerException(&quot;key &#x3D;&#x3D; null || value &#x3D;&#x3D; null&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    V previous;</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">        putCount++;</span><br><span class="line">        size +&#x3D; safeSizeOf(key, value);</span><br><span class="line">        previous &#x3D; map.put(key, value);</span><br><span class="line">        if (previous !&#x3D; null) &#123;</span><br><span class="line">            size -&#x3D; safeSizeOf(key, previous);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (previous !&#x3D; null) &#123;</span><br><span class="line">        entryRemoved(false, key, previous, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    trimToSize(maxSize);</span><br><span class="line">    return previous;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更多的分析可以参考<a href="http://blog.csdn.net/xiaanming/article/details/27525741" target="_blank" rel="noopener">这里</a>。</p>
<h2 id="DisLruCache"><a href="#DisLruCache" class="headerlink" title="DisLruCache"></a>DisLruCache</h2><p>DisLruCache用于实现存储设置缓存，即磁盘缓存，他通过将缓存对象写入文件系统从而实现缓存的效果。<br>我们在这里对其创建，缓存添加和移除缓存进行简单的分析。<br>创建过程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private DiskLruCache(File directory, int appVersion, int valueCount, long maxSize) &#123;</span><br><span class="line"> ...简单的赋值，就不贴出来了</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中的四个参数分别是：</p>
<ul>
<li><code>directory</code>表示磁盘存在文件系统中的存储路径；</li>
<li><code>appVersion</code> 表示应用的版本号，一般设置1就可；</li>
<li><code>valueCount</code> 表示单个节点锁对应的数据的个数，一般设为1就可以了；</li>
<li><code>maxSize</code> 表示缓存的总大小，比如50MB，当缓存大小超过这个设置值后，DisLruCache会清除一些缓存从而保证总大小不大于这个设定值。<br>当然，<code>DiskLruCache</code>提供了<code>open</code>方法来创建自身：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public static DiskLruCache open(File directory, int appVersion, int valueCount, long maxSize)</span><br><span class="line">    throws IOException &#123;</span><br><span class="line">  if (maxSize &lt;&#x3D; 0) &#123;</span><br><span class="line">    throw new IllegalArgumentException(&quot;maxSize &lt;&#x3D; 0&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  if (valueCount &lt;&#x3D; 0) &#123;</span><br><span class="line">    throw new IllegalArgumentException(&quot;valueCount &lt;&#x3D; 0&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; If a bkp file exists, use it instead.</span><br><span class="line">  File backupFile &#x3D; new File(directory, JOURNAL_FILE_BACKUP);</span><br><span class="line">  if (backupFile.exists()) &#123;</span><br><span class="line">    File journalFile &#x3D; new File(directory, JOURNAL_FILE);</span><br><span class="line">    &#x2F;&#x2F; If journal file also exists just delete backup file.</span><br><span class="line">    if (journalFile.exists()) &#123;</span><br><span class="line">      backupFile.delete();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      renameTo(backupFile, journalFile, false);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
<li><em>DisLruCacher的缓存添加：*</em><br>DisLruCache的缓存操作通过Editor完成的，Editor表示一个缓存对象的编辑对象。在ImageLoader的运用，首先需要获取图片的URL所对用的Key，然后根据Key就可以通过<code>edit()</code>方法来获取Editor对象，如果这个缓存正在被编辑，那么edit会返回null，即DisLrucache不允许同时编辑一个缓存对象。之所以要把url转换成key，是因为url中可能有特殊字符，这将影响url在Adnroid中的直接使用，一般采用url的md5值作为key。</li>
</ul>
<p><strong>DisLruCacher的缓存查找：</strong><br>缓存查找过程也需要将url转换成key，然后通过<code>DisLrache</code>的get方法得到一个<code>snapshot</code>对象即可得到缓存的文件输入流，进而得到Bitmap对象。为了避免加载图片过程中导致的OOM问题，一般建议不直接加载原始图片，建议先对图片进行压缩之后在去加载。下面是<code>get</code>方法的实现逻辑：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public synchronized Value get(String key) throws IOException &#123;</span><br><span class="line">   checkNotClosed();</span><br><span class="line">   Entry entry &#x3D; lruEntries.get(key);</span><br><span class="line">   if (entry &#x3D;&#x3D; null) &#123;</span><br><span class="line">     return null;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   if (!entry.readable) &#123;</span><br><span class="line">     return null;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   for (File file : entry.cleanFiles) &#123;</span><br><span class="line">       &#x2F;&#x2F; A file must have been deleted manually!</span><br><span class="line">       if (!file.exists()) &#123;</span><br><span class="line">           return null;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   redundantOpCount++;</span><br><span class="line">   journalWriter.append(READ);</span><br><span class="line">   journalWriter.append(&#39; &#39;);</span><br><span class="line">   journalWriter.append(key);</span><br><span class="line">   journalWriter.append(&#39;\n&#39;);</span><br><span class="line">   if (journalRebuildRequired()) &#123;</span><br><span class="line">     executorService.submit(cleanupCallable);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   return new Value(key, entry.sequenceNumber, entry.cleanFiles, entry.lengths);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p><strong>DisLruCacher的缓存删除：</strong><br><code>DisLruCacher</code>提供了<code>remove</code>,<code>delete</code>方法来进行磁盘的删除操作。删除通过需要将url转换成key，然后从<code>lruEntries</code>的<code>LinkedHashMap</code>对象中获取该对象，在对象存在的前提下，删除文件中对应的文件，然后移除<code>lruEntries</code>对应的key值。代码实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public synchronized boolean remove(String key) throws IOException &#123;</span><br><span class="line">   checkNotClosed();</span><br><span class="line">   Entry entry &#x3D; lruEntries.get(key);</span><br><span class="line">   if (entry &#x3D;&#x3D; null || entry.currentEditor !&#x3D; null) &#123;</span><br><span class="line">     return false;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   for (int i &#x3D; 0; i &lt; valueCount; i++) &#123;</span><br><span class="line">     File file &#x3D; entry.getCleanFile(i);</span><br><span class="line">     if (file.exists() &amp;&amp; !file.delete()) &#123;</span><br><span class="line">       throw new IOException(&quot;failed to delete &quot; + file);</span><br><span class="line">     &#125;</span><br><span class="line">     size -&#x3D; entry.lengths[i];</span><br><span class="line">     entry.lengths[i] &#x3D; 0;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   redundantOpCount++;</span><br><span class="line">   journalWriter.append(REMOVE);</span><br><span class="line">   journalWriter.append(&#39; &#39;);</span><br><span class="line">   journalWriter.append(key);</span><br><span class="line">   journalWriter.append(&#39;\n&#39;);</span><br><span class="line"></span><br><span class="line">   lruEntries.remove(key);</span><br><span class="line"></span><br><span class="line">   if (journalRebuildRequired()) &#123;</span><br><span class="line">     executorService.submit(cleanupCallable);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   return true;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h1 id="杂谈"><a href="#杂谈" class="headerlink" title="杂谈"></a>杂谈</h1><p>下面是我对<code>imageLoader</code>源码分析之后的一些感悟和一些总结，有一些还是面试时被问到的问题，这里一并记录下来。</p>
<h2 id="ImageLoader运用的设计模式"><a href="#ImageLoader运用的设计模式" class="headerlink" title="ImageLoader运用的设计模式"></a>ImageLoader运用的设计模式</h2><p>从源码分析上来看，最明显的就是建造者模式和单例模式，这两种模式在实际项目中也是运行最广的设计模式。还使用了工厂模式，装饰者模式，代理模式，策略模式等等。<a href="https://github.com/mingjunli/JavaDesignPatterns" target="_blank" rel="noopener">设计模式参考</a></p>
<h2 id="当ListView显示图片，滚动时ImageLoader是如何避免OOM的？"><a href="#当ListView显示图片，滚动时ImageLoader是如何避免OOM的？" class="headerlink" title="当ListView显示图片，滚动时ImageLoader是如何避免OOM的？"></a>当ListView显示图片，滚动时ImageLoader是如何避免OOM的？</h2><p>首先是对缓存进行管理，具体管理内存的方法是LruCache，实现算法是LRU：通过优先淘汰最近最少使用的缓存对象，保证总缓存大小不高于限定值。</p>
<h2 id="LRUCacher算法的具体实现"><a href="#LRUCacher算法的具体实现" class="headerlink" title="LRUCacher算法的具体实现"></a>LRUCacher算法的具体实现</h2><p>他内部采用一个LinkedhashMap以强引用的方式存储外界的缓存对象，其提供了get和put方法来完成缓存的获取和添加操作，当缓存满时，LRUcacher会移除较早使用的缓存对象，然后再添加新的缓存对象。</p>
<h2 id="ImagerLoader的为什么会被淘汰"><a href="#ImagerLoader的为什么会被淘汰" class="headerlink" title="ImagerLoader的为什么会被淘汰"></a>ImagerLoader的为什么会被淘汰</h2><ul>
<li>首先相对于Gilde来说，ImagerLoader的配置相对繁琐，需要对其中的参数有比较详细的了解才能比较好的驾驭ImageLoader，而Gilde简单易用，没有繁琐复杂的配置；</li>
<li>Gilde中的内存管理比ImageLoader做的更好，虽然ImageLoader也说有三层缓存，但是实际上是两层，一个磁盘，一个内存缓存。而Gilde中的内存管理做到了两级内存缓存，更加可靠；</li>
<li>在网络请求方面，ImageLoader采用的是HttpConnection，而Gilde默认采用更加高效的okhttp，虽然两者都支持自定义下载器，但是明显Gilde的支持更好。</li>
</ul>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul>
<li><a href="https://github.com/nostra13/Android-Universal-Image-Loader" target="_blank" rel="noopener">官方github</a></li>
<li><a href="http://a.codekk.com/detail/Android/huxian99/Android%20Universal%20Image%20Loader%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90" target="_blank" rel="noopener">Android Universal Image Loader 源码分析</a></li>
<li><a href="http://blog.csdn.net/xiaanming/article/details/26810303" target="_blank" rel="noopener">universal-imager-Loader完全解析</a></li>
<li>《android开发艺术探索》</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://reoger.tk/2017/08/30/other/%E6%96%87%E6%A1%A3%E6%9F%A5%E7%9C%8B%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="reoger">
      <meta itemprop="description" content="reoger">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="reoger的记录">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/08/30/other/%E6%96%87%E6%A1%A3%E6%9F%A5%E7%9C%8B%E5%99%A8/" class="post-title-link" itemprop="url">文档查看器</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2017-08-30 12:52:40 / 修改时间：12:55:00" itemprop="dateCreated datePublished" datetime="2017-08-30T12:52:40+08:00">2017-08-30</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="原型参考界面"><a href="#原型参考界面" class="headerlink" title="原型参考界面"></a>原型参考界面</h2><iframe src="https://modao.cc/app/N1EtppyLzE5qVlcEzY1FvdEvE65lYLn/embed" width="488" height="900" allowTransparency="true" frameborder="0"></iframe>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/5/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/7/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">reoger</p>
  <div class="site-description" itemprop="description">reoger</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">63</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">42</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/reoger" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;reoger" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:reoger112@gmail.com" title="E-Mail → mailto:reoger112@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2018 – 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">reoger</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
