<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"reoger.tk","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="reoger">
<meta property="og:type" content="website">
<meta property="og:title" content="reoger的记录">
<meta property="og:url" content="http://reoger.tk/page/6/index.html">
<meta property="og:site_name" content="reoger的记录">
<meta property="og:description" content="reoger">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="reoger">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://reoger.tk/page/6/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>reoger的记录</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">reoger的记录</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">--以后的你会感激现在那么努力的自己</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://reoger.tk/2017/09/02/okhttp%E8%A7%A3%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="reoger">
      <meta itemprop="description" content="reoger">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="reoger的记录">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/09/02/okhttp%E8%A7%A3%E6%9E%90/" class="post-title-link" itemprop="url">okhttp解析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-09-02 20:19:55" itemprop="dateCreated datePublished" datetime="2017-09-02T20:19:55+08:00">2017-09-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-12 23:04:52" itemprop="dateModified" datetime="2020-04-12T23:04:52+08:00">2020-04-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/" itemprop="url" rel="index"><span itemprop="name">源码解读</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>OkHttp是一个处理网络请求的开源项目,是Android端最火热的轻量级框架,由移动支付Square公司贡献用于替代HttpUrlConnection和Apache HttpClient。随着OkHttp的不断成熟，越来越多的Android开发者使用OkHttp作为网络框架。</p>
</blockquote>
<h1 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h1><p>在真正进行源码分析之前，简单的回顾一个okhttp的简单使用。首先将okhttp继承到自己的项目中,在<code>build.gradle</code>添加如下的依赖：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compile &#39;com.squareup.okhttp3:okhttp:3.7.0&#39;</span><br></pre></td></tr></table></figure>
<p>下面是一个okhttp简单进行get请求的一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;1.拿到okhttpClient对象</span><br><span class="line">OkHttpClient okHttpClient &#x3D; new OkHttpClient();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;2. 构造request对象</span><br><span class="line">Request.Builder builder &#x3D; new Request.Builder();</span><br><span class="line">Request request &#x3D; builder.get().url(&quot;http:&#x2F;&#x2F;www.baidu.com&quot;).build();</span><br><span class="line"> &#x2F;&#x2F;3. 构建Call对象</span><br><span class="line">okhttp3.Call call &#x3D; okHttpClient.newCall(request);</span><br><span class="line">&#x2F;&#x2F;4.执行</span><br><span class="line">&#x2F;&#x2F;同步执行 call.execute();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;异步执行</span><br><span class="line">call.enqueue(new Callback() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onFailure(okhttp3.Call call, IOException e) &#123;</span><br><span class="line">       &#x2F;&#x2F;失败的回调</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void onResponse(okhttp3.Call call, Response response) throws IOException &#123;</span><br><span class="line">        &#x2F;&#x2F;成功的回调</span><br><span class="line">        final String repo &#x3D; response.body().string();</span><br><span class="line">        Log.d(&quot;TAG&quot;,repo+&quot; &quot;);</span><br><span class="line">        runOnUiThread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                mText.setText(repo);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面的代码用okhttp实现了一个简单的网络请求，主要由四步组成。关于okhttp更多的用法请参考<a href="http://blog.csdn.net/reoger/article/details/70953609" target="_blank" rel="noopener">博客</a>。对上面的okhttp中常用的类做一个简单的介绍：</p>
<ol>
<li><strong>OkHttpClient</strong> 可以理解用户面板，发送的网络请求都是通过他来实现的，每个<code>OkhttpClient</code>都在内部都维护了属于自己的任务队列，连接池，Cache，拦截器等，所以在使用<code>OkHttp</code>作为网络框架时应该全局共享一个<code>OkHttpClient</code>实例。</li>
<li><strong>Request</strong> 可以理解为用户发送的请求。</li>
<li><strong>Response</strong> 是响应是对请求的回复，包含状态码、HTTP头和主体部分。</li>
<li><strong>Call</strong> 描述一个实际的访问请求，用户的每一个网络请求都是一个Call实例。</li>
</ol>
<hr>
<p>下面将对上面的四步一步一步来进行分析，并探究其源码的实现。</p>
<h1 id="创建okhttpClient对象"><a href="#创建okhttpClient对象" class="headerlink" title="创建okhttpClient对象"></a>创建okhttpClient对象</h1><p>关于<code>okhttpClient</code>对象，在上面已经进行了一个简单的解释，那么他为甚是这个样子的，下面通过源码来验证。下面是<code>OkHttpClient</code>类中的部分代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public OkHttpClient() &#123;</span><br><span class="line">  this(new Builder());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> public Builder() &#123;</span><br><span class="line">    dispatcher &#x3D; new Dispatcher();&#x2F;&#x2F;分发器</span><br><span class="line">    protocols &#x3D; DEFAULT_PROTOCOLS;&#x2F;&#x2F;协议</span><br><span class="line">    connectionSpecs &#x3D; DEFAULT_CONNECTION_SPECS;&#x2F;&#x2F;传输层版本和连接协议</span><br><span class="line">    eventListenerFactory &#x3D; EventListener.factory(EventListener.NONE);&#x2F;&#x2F;事件工厂</span><br><span class="line">    proxySelector &#x3D; ProxySelector.getDefault();&#x2F;&#x2F;代理选择</span><br><span class="line">    cookieJar &#x3D; CookieJar.NO_COOKIES;&#x2F;&#x2F;cookie</span><br><span class="line">    socketFactory &#x3D; SocketFactory.getDefault();&#x2F;&#x2F;socket工厂</span><br><span class="line">    hostnameVerifier &#x3D; OkHostnameVerifier.INSTANCE;&#x2F;&#x2F;主机名字确认</span><br><span class="line">    certificatePinner &#x3D; CertificatePinner.DEFAULT;&#x2F;&#x2F;证书链</span><br><span class="line">    proxyAuthenticator &#x3D; Authenticator.NONE;&#x2F;&#x2F;代理身份验证</span><br><span class="line">    authenticator &#x3D; Authenticator.NONE;&#x2F;&#x2F;本地身份验证</span><br><span class="line">    connectionPool &#x3D; new ConnectionPool();&#x2F;&#x2F;连接池，复用连接</span><br><span class="line">    dns &#x3D; Dns.SYSTEM;&#x2F;&#x2F;域名</span><br><span class="line">    followSslRedirects &#x3D; true;&#x2F;&#x2F;安全套接层重定向</span><br><span class="line">    followRedirects &#x3D; true;&#x2F;&#x2F;本地重定向</span><br><span class="line">    retryOnConnectionFailure &#x3D; true;&#x2F;&#x2F;重试连接失败</span><br><span class="line">    connectTimeout &#x3D; 10_000;&#x2F;&#x2F;连接超时时间</span><br><span class="line">    readTimeout &#x3D; 10_000;&#x2F;&#x2F;读超时</span><br><span class="line">    writeTimeout &#x3D; 10_000;&#x2F;&#x2F;写超时</span><br><span class="line">    pingInterval &#x3D; 0;&#x2F;&#x2F;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>
<p>可以看出来，直接创建的<code>OkHttpClient</code>对象并且默认构造<code>builder</code>对象进行初始化。当然，直接创建<code>OkhttpClient</code>是非常简单的，但是其中的配置就只能用默认的配置了。如果需要子的自定义配置，可以通过下面的方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">OkHttpClient  okHttpClient&#x3D; new c.Builder()</span><br><span class="line">                    .cookieJar(new CookieJar() &#123;</span><br><span class="line">                        private final HashMap&lt;HttpUrl, List&lt;Cookie&gt;&gt; cookieStore &#x3D; new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">                        @Override</span><br><span class="line">                        public void saveFromResponse(HttpUrl url, List&lt;Cookie&gt; cookies) &#123;</span><br><span class="line">                            cookieStore.put(url, cookies);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        @Override</span><br><span class="line">                        public List&lt;Cookie&gt; loadForRequest(HttpUrl url) &#123;</span><br><span class="line">                            List&lt;Cookie&gt; cookies &#x3D; cookieStore.get(url);</span><br><span class="line">                            return cookies !&#x3D; null ? cookies : new ArrayList&lt;Cookie&gt;();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;)</span><br><span class="line">                    .build();</span><br><span class="line">                    &#x2F;&#x2F;为请求添加CookieJar。</span><br></pre></td></tr></table></figure>
<p>至于实现，也非常简单，就是一个Builder模式。具体实现就不做过多的介绍了。</p>
<h1 id="构造request对象"><a href="#构造request对象" class="headerlink" title="构造request对象"></a>构造request对象</h1><p>构建<code>request</code>对象的代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Request request &#x3D; new Request.Builder().get().url(&quot;url&quot;).build();</span><br></pre></td></tr></table></figure>
<p>Request的构建过程也非常简单，在<code>request</code>中的实现如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public Builder() &#123;</span><br><span class="line">   this.method &#x3D; &quot;GET&quot;;</span><br><span class="line">   this.headers &#x3D; new Headers.Builder();</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> public Builder get() &#123;</span><br><span class="line">   return method(&quot;GET&quot;, null);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> public Builder url(String url) &#123;</span><br><span class="line">   if (url &#x3D;&#x3D; null) throw new NullPointerException(&quot;url &#x3D;&#x3D; null&quot;);</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; Silently replace web socket URLs with HTTP URLs.</span><br><span class="line">   if (url.regionMatches(true, 0, &quot;ws:&quot;, 0, 3)) &#123;</span><br><span class="line">     url &#x3D; &quot;http:&quot; + url.substring(3);</span><br><span class="line">   &#125; else if (url.regionMatches(true, 0, &quot;wss:&quot;, 0, 4)) &#123;</span><br><span class="line">     url &#x3D; &quot;https:&quot; + url.substring(4);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   HttpUrl parsed &#x3D; HttpUrl.parse(url);</span><br><span class="line">   if (parsed &#x3D;&#x3D; null) throw new IllegalArgumentException(&quot;unexpected url: &quot; + url);</span><br><span class="line">   return url(parsed);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">   public Request build() &#123;</span><br><span class="line">   if (url &#x3D;&#x3D; null) throw new IllegalStateException(&quot;url &#x3D;&#x3D; null&quot;);</span><br><span class="line">   return new Request(this);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>可以看出来，<code>request</code>的构建过程其实也是非常简单的，也是利用建造者模式构建出<code>request</code>对象。在<code>request</code>配置URl、get、等一些列的参数。整体来说，比较简单。</p>
<h1 id="构建Call对象并执行"><a href="#构建Call对象并执行" class="headerlink" title="构建Call对象并执行"></a>构建Call对象并执行</h1><p>前两步都是非常简单的，不管是从源码的实现上，还是从我们代码的调用上来看都是非常简单的。但是前面的只是开胃菜，真正的大餐才正要开始。<br>我们将实例代码的三、四步放到一起来进行分析：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">okhttp3.Call call &#x3D; okHttpClient.newCall(request);</span><br><span class="line"> Response execute &#x3D; call.execute();</span><br></pre></td></tr></table></figure>
<p>从调用代码上来看，其实现也是非常简单的。下面将从源码的角度一步一步进行分析。<br>首先是构建<code>Call</code>对象，在<code>OkHttpClient</code>类中的实现如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Override public Call newCall(Request request) &#123;</span><br><span class="line">  return new RealCall(this, request, false &#x2F;* for web socket *&#x2F;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出来，在<code>okhttpClient</code>中只是简单的调用了<code>RealCall</code>方法，我们继续来看在<code>RealCall</code>类中<code>RealCall</code>方法的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">RealCall(OkHttpClient client, Request originalRequest, boolean forWebSocket) &#123;</span><br><span class="line">  final EventListener.Factory eventListenerFactory &#x3D; client.eventListenerFactory();</span><br><span class="line"></span><br><span class="line">  this.client &#x3D; client;</span><br><span class="line">  this.originalRequest &#x3D; originalRequest;</span><br><span class="line">  this.forWebSocket &#x3D; forWebSocket;</span><br><span class="line">  this.retryAndFollowUpInterceptor &#x3D; new RetryAndFollowUpInterceptor(client, forWebSocket);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; TODO(jwilson): this is unsafe publication and not threadsafe.</span><br><span class="line">  this.eventListener &#x3D; eventListenerFactory.create(this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>RealCall</code>方法也只是对其中的参数进行一些设置。当然，对其中的参数有还是需要有一定的了解。</p>
<ul>
<li><code>client</code>对象就是我们前面创建的<code>okhttpClient</code>对象</li>
<li><code>originalRequest</code>对象就是已经构建完毕的<code>Request</code>对象</li>
<li><code>forWebSocket</code>值是为了区分是不是进行<code>web socket</code>通信，是为true，否为false；</li>
<li><code>eventListener</code>是为后面执行完之后的回调设置的监听。<br>构建一个<code>call</code>对象之后，就通过这个call对象来进行网络请求了。具体执行（同步执行）在<code>RealCall</code>类中的实现代码如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;同步执行网路请求</span><br><span class="line">@Override public Response execute() throws IOException &#123;</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">      if (executed) throw new IllegalStateException(&quot;Already Executed&quot;);</span><br><span class="line">      executed &#x3D; true;</span><br><span class="line">    &#125;</span><br><span class="line">    captureCallStackTrace();</span><br><span class="line">    try &#123;</span><br><span class="line">      client.dispatcher().executed(this);</span><br><span class="line">      Response result &#x3D; getResponseWithInterceptorChain();</span><br><span class="line">      if (result &#x3D;&#x3D; null) throw new IOException(&quot;Canceled&quot;);</span><br><span class="line">      return result;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      client.dispatcher().finished(this);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F;跟踪调用栈的信息,这里追踪的是response.body().close()方法的调用信息</span><br><span class="line">private void captureCallStackTrace() &#123;</span><br><span class="line">    Object callStackTrace &#x3D; Platform.get().getStackTraceForCloseable(&quot;response.body().close()&quot;);</span><br><span class="line">    retryAndFollowUpInterceptor.setCallStackTrace(callStackTrace);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F;添加一堆的拦截器。</span><br><span class="line">  Response getResponseWithInterceptorChain() throws IOException &#123;</span><br><span class="line">    &#x2F;&#x2F; Build a full stack of interceptors.</span><br><span class="line">    List&lt;Interceptor&gt; interceptors &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    interceptors.addAll(client.interceptors());</span><br><span class="line">    interceptors.add(retryAndFollowUpInterceptor);</span><br><span class="line">    interceptors.add(new BridgeInterceptor(client.cookieJar()));</span><br><span class="line">    interceptors.add(new CacheInterceptor(client.internalCache()));</span><br><span class="line">    interceptors.add(new ConnectInterceptor(client));</span><br><span class="line">    if (!forWebSocket) &#123;</span><br><span class="line">      interceptors.addAll(client.networkInterceptors());</span><br><span class="line">    &#125;</span><br><span class="line">    interceptors.add(new CallServerInterceptor(forWebSocket));</span><br><span class="line"></span><br><span class="line">    Interceptor.Chain chain &#x3D; new RealInterceptorChain(</span><br><span class="line">        interceptors, null, null, null, 0, originalRequest);</span><br><span class="line">    return chain.proceed(originalRequest);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
简单分析上面代码的实现：首先利用<code>synchronized</code>加锁，是为了确保一个<code>call</code>对象只能执行一次。<code>captureCallStackTrace</code>方法用于追踪调用栈的信息。通过<code>client.dispatcher().executed(this)</code>将当前的call加入到<code>runningSyncCalls</code>这样一个正在运行的队列中。关于这点，后面将会重点讲到，这里先只是提出这么一个概念。我们继续解析上面的代码，在将当前的call添加到运行队列中后，通过<code>getResponseWithInterceptorChain</code>为当前的call添加一堆的拦截器，并将网络请求的结果返回回来，至于<code>getResponseWithInterceptorChain</code>里面的具体实现，我们放在后面来讲。最后，通过<code>client.dispatcher().finished(this);</code>来结束当前访问和释放相关资源。<br>下面来了解异步执行的相关逻辑。代码的实现部分同样是在<code>RealCall</code>类中，相关的代码如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Override public void enqueue(Callback responseCallback) &#123;</span><br><span class="line">  synchronized (this) &#123;</span><br><span class="line">    if (executed) throw new IllegalStateException(&quot;Already Executed&quot;);</span><br><span class="line">    executed &#x3D; true;</span><br><span class="line">  &#125;</span><br><span class="line">  captureCallStackTrace();</span><br><span class="line">  client.dispatcher().enqueue(new AsyncCall(responseCallback));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
通过前面的同步访问的分析，我们对异步访问的分析，现在看异步请求就很简单了。前面的步骤都是一样的，就不一一介绍了。我们直接看最后一句，其中的参数<code>AsyncCall</code>表示的其实就是我们要添加的任务请求。在<code>RealCall</code>类中有如下的实现代码：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">final class AsyncCall extends NamedRunnable &#123;</span><br><span class="line">    private final Callback responseCallback;</span><br><span class="line"></span><br><span class="line">    AsyncCall(Callback responseCallback) &#123;</span><br><span class="line">      super(&quot;OkHttp %s&quot;, redactedUrl());</span><br><span class="line">      this.responseCallback &#x3D; responseCallback;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String host() &#123;</span><br><span class="line">      return originalRequest.url().host();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Request request() &#123;</span><br><span class="line">      return originalRequest;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    RealCall get() &#123;</span><br><span class="line">      return RealCall.this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override protected void execute() &#123;</span><br><span class="line">      boolean signalledCallback &#x3D; false;</span><br><span class="line">      try &#123;</span><br><span class="line">        Response response &#x3D; getResponseWithInterceptorChain();</span><br><span class="line">        if (retryAndFollowUpInterceptor.isCanceled()) &#123;</span><br><span class="line">          signalledCallback &#x3D; true;</span><br><span class="line">          responseCallback.onFailure(RealCall.this, new IOException(&quot;Canceled&quot;));</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          signalledCallback &#x3D; true;</span><br><span class="line">          responseCallback.onResponse(RealCall.this, response);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; catch (IOException e) &#123;</span><br><span class="line">        if (signalledCallback) &#123;</span><br><span class="line">          &#x2F;&#x2F; Do not signal the callback twice!</span><br><span class="line">          Platform.get().log(INFO, &quot;Callback failure for &quot; + toLoggableString(), e);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          responseCallback.onFailure(RealCall.this, e);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; finally &#123;</span><br><span class="line">        client.dispatcher().finished(this);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
而上面<code>AsyncCall</code>继承的<code>NamedRunnable</code>本身也实现了<code>Runnable</code>的接口。所以本质来说，<code>AsyncCall</code>其实就是一个<code>Runnbale</code>，即一个任务。在这里值访问请求任务。我们发现在<code>execute</code>方法中，真正实现访问请求的也是<code>getResponseWithInterceptorChain</code>，如果访问成功就回调<code>onResponse</code>方法，并将response传递过去；否则就回调<code>onFailure</code>方法，并将错误信息和CallBack对象传递过去。当然，最终也是通过<code>finished</code>方法结束访问。分析完了<code>AsyncCall</code>，接来继续分析前面的<code>enqueue</code>方法。发现其在<code>Dispatcher</code>类中的实现逻辑如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;** Ready async calls in the order they&#39;ll be run. *&#x2F;</span><br><span class="line">&#x2F;&#x2F;这个队列代表准备好的异步请求</span><br><span class="line">  private final Deque&lt;AsyncCall&gt; readyAsyncCalls &#x3D; new ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  &#x2F;** Running asynchronous calls. Includes canceled calls that haven&#39;t finished yet. *&#x2F;</span><br><span class="line">  &#x2F;&#x2F;这个队列代表正在运行的异步请求</span><br><span class="line">  private final Deque&lt;AsyncCall&gt; runningAsyncCalls &#x3D; new ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  &#x2F;** Running synchronous calls. Includes canceled calls that haven&#39;t finished yet. *&#x2F;</span><br><span class="line">  &#x2F;&#x2F;这个队列代表正在运行的同步请求。</span><br><span class="line">  private final Deque&lt;RealCall&gt; runningSyncCalls &#x3D; new ArrayDeque&lt;&gt;();</span><br><span class="line">  </span><br><span class="line">  private int maxRequests &#x3D; 64;</span><br><span class="line">  private int maxRequestsPerHost &#x3D; 5;</span><br><span class="line">  </span><br><span class="line">  synchronized void enqueue(AsyncCall call) &#123;</span><br><span class="line">    if (runningAsyncCalls.size() &lt; maxRequests &amp;&amp; runningCallsForHost(call) &lt; maxRequestsPerHost) &#123;</span><br><span class="line">      runningAsyncCalls.add(call);</span><br><span class="line">      executorService().execute(call);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      readyAsyncCalls.add(call);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>即在当前运行异步请求队列数量小于64且访问同一个主机数量的队列小于5个时，将当前的请求直接加入正在运行的请求队列中，并通过<code>executorService().execute(call)</code>执行，否则的话就将请求添加到准备的请求队列中。至于<code>executorService().execute(call)</code>的方法的实现<code>Dispatcher</code>中创建<code>executorService</code>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public synchronized ExecutorService executorService() &#123;</span><br><span class="line">    if (executorService &#x3D;&#x3D; null) &#123;</span><br><span class="line">      executorService &#x3D; new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60, TimeUnit.SECONDS,</span><br><span class="line">          new SynchronousQueue&lt;Runnable&gt;(), Util.threadFactory(&quot;OkHttp Dispatcher&quot;, false));</span><br><span class="line">    &#125;</span><br><span class="line">    return executorService;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>通过代码可以很清楚的了解，<code>executorService</code>就是创建一个线程池，核心线程数为0，最大线程数为<code>MAX_VALUE</code>，线程空闲时最大的存活时间为60s，容器为先进先出的队列。然后执行<code>execute</code>方法，在线程池中运行该请求。那么运行完毕后，是怎么将请求从运行异步队列中移除？其实，在前面的分析过程中，我们对<code>execute</code>同步请求和<code>enqueue</code>异步请求的都最终会调用的一个方法<code>client.dispatcher().finished(this);</code>并没有仔细的去分析，下面我们分析该方法是如何将运行完成的请求从运行异步队列中移除的。下面是关键性的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;** Used by &#123;@code AsyncCall#run&#125; to signal completion. *&#x2F;</span><br><span class="line">void finished(AsyncCall call) &#123;</span><br><span class="line">  finished(runningAsyncCalls, call, true);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;** Used by &#123;@code Call#execute&#125; to signal completion. *&#x2F;</span><br><span class="line">void finished(RealCall call) &#123;</span><br><span class="line">  finished(runningSyncCalls, call, false);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private &lt;T&gt; void finished(Deque&lt;T&gt; calls, T call, boolean promoteCalls) &#123;</span><br><span class="line">  int runningCallsCount;</span><br><span class="line">  Runnable idleCallback;</span><br><span class="line">  synchronized (this) &#123;</span><br><span class="line">    if (!calls.remove(call)) throw new AssertionError(&quot;Call wasn&#39;t in-flight!&quot;);</span><br><span class="line">    if (promoteCalls) promoteCalls();</span><br><span class="line">    runningCallsCount &#x3D; runningCallsCount();</span><br><span class="line">    idleCallback &#x3D; this.idleCallback;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>通过上面的代码，很容易就发现其实现<code>finished</code>中实现主要就是将已经运行完成的请求从正在运行的异步队列中移除。可以看到，当调用<code>finished(RealCall call)</code>方法时，会调用<code>promoteCalls</code>方法。我们继续来看其实现:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">private void promoteCalls() &#123;</span><br><span class="line">    if (runningAsyncCalls.size() &gt;&#x3D; maxRequests) return; &#x2F;&#x2F; Already running max capacity.</span><br><span class="line">    if (readyAsyncCalls.isEmpty()) return; &#x2F;&#x2F; No ready calls to promote.</span><br><span class="line"></span><br><span class="line">    for (Iterator&lt;AsyncCall&gt; i &#x3D; readyAsyncCalls.iterator(); i.hasNext(); ) &#123;</span><br><span class="line">      AsyncCall call &#x3D; i.next();</span><br><span class="line"></span><br><span class="line">      if (runningCallsForHost(call) &lt; maxRequestsPerHost) &#123;</span><br><span class="line">        i.remove();</span><br><span class="line">        runningAsyncCalls.add(call);</span><br><span class="line">        executorService().execute(call);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (runningAsyncCalls.size() &gt;&#x3D; maxRequests) return; &#x2F;&#x2F; Reached max capacity.</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>很清晰的可以看出来，<code>promoteCalls</code>方法就是在<code>runningAsyncCalls</code>队列数量小于64时，将<code>readyAsyncCalls</code>队列中的请求放入到<code>runningAsyncCalls</code>队列中。然后分别执行。否则就直接返回，什么也不做。相信这里的算是很简单的代码吧，就不多介绍了。到这里，在总结一下上面的三个队列的作用和转化吧。</p>
<ul>
<li><code>runningAsyncCalls</code>就用存储正在运行的异步请求，当正在请求的数量大于64时，将后面添加的请求放入到<code>readyAsyncCalls</code>队列中，在合适的时机（即当<code>runningAsyncCalls</code>数量小于64时），将<code>readyAsyncCalls</code>放入到<code>runningAsyncCalls</code>队列中。通过这种方式来保障当前正在运行的异步请求数量不会过大，相当于一个排队机制。</li>
<li><code>runningSyncCalls</code>这个队列用于存储正在运行的同步请求，对于同步请求，并没有什么排队机制，因为他是阻塞式的，所以用一个队列来存储即可。</li>
</ul>
<h1 id="拦截器-amp-网络请求的实现"><a href="#拦截器-amp-网络请求的实现" class="headerlink" title="拦截器&amp;网络请求的实现"></a>拦截器&amp;网络请求的实现</h1><p>通过上面的分析，我们并没有真正发现网络请求的实现，在前面的分析过程中，我们只丢下了一个重要的方法并没有深入来讲，即<code>getResponseWithInterceptorChain</code>这个方法。对前面分析的内容比较熟悉的话，应该知道无论是异步请求还是同步请求，都是通过<code>getResponseWithInterceptorChain</code>这个方法获取返回值，然后将在继续下面的内容的。那么肯定，网络请求的具体实现就在<code>getResponseWithInterceptorChain</code>这个方法中了。他在<code>RealCall</code>中的实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Response getResponseWithInterceptorChain() throws IOException &#123;</span><br><span class="line">    &#x2F;&#x2F; Build a full stack of interceptors.</span><br><span class="line">    List&lt;Interceptor&gt; interceptors &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    interceptors.addAll(client.interceptors());</span><br><span class="line">    interceptors.add(retryAndFollowUpInterceptor);</span><br><span class="line">    interceptors.add(new BridgeInterceptor(client.cookieJar()));</span><br><span class="line">    interceptors.add(new CacheInterceptor(client.internalCache()));</span><br><span class="line">    interceptors.add(new ConnectInterceptor(client));</span><br><span class="line">    if (!forWebSocket) &#123;</span><br><span class="line">      interceptors.addAll(client.networkInterceptors());</span><br><span class="line">    &#125;</span><br><span class="line">    interceptors.add(new CallServerInterceptor(forWebSocket));</span><br><span class="line"></span><br><span class="line">    Interceptor.Chain chain &#x3D; new RealInterceptorChain(</span><br><span class="line">        interceptors, null, null, null, 0, originalRequest);</span><br><span class="line">    return chain.proceed(originalRequest);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>通过代码，我们可以看到，首先添加了一系列的拦截器。然后创建一个拦截器链<code>RealInterceptorChain</code>，并执行了拦截器链的<code>proceed</code>方法。<br>我们首先对其中的拦截器进行解析，然后在来解析具体的网路请求。首先，先解释一下<code>interceptors</code>(拦截器)是什么吧。简单来说：<br><strong>拦截器是一种强大的机制，可以监视，重写和重试调用。</strong><br>如果相对拦截器更加深入的了解，可以参考<a href="https://github.com/square/okhttp/wiki/Interceptors" target="_blank" rel="noopener">githu上的wiki</a>,如果阅读有困难的话，可以参考<a href="http://www.jianshu.com/p/2710ed1e6b48" target="_blank" rel="noopener">中文版</a>。<br>一个网络请求实际上就是一个个拦截器执行其<code>intercept</code>方法的过程。而这其中除了用户自定义的拦截器以外还有几个核心的拦截器完成网络访问的核心逻辑，按照先后顺序以此是：</p>
<ol>
<li><strong>RetryAndFollowUpInterceptor</strong> 负责失败重试以及重定向</li>
<li><strong>BridgeInterceptor</strong> 负责把用户构造的请求转换为发送到服务器的请求、把服务器返回的响应转换为用户友好的响应</li>
<li><strong>CacheInterceptor</strong> 负责读取缓存直接返回、更新缓存</li>
<li><strong>ConnectInterceptor</strong> 负责和服务器建立连接</li>
<li><strong>networkInterceptors</strong> 配置<code>okHttpClent</code>时设置的，当然，此拦截器不适用于<code>web Socket</code></li>
<li><strong>CallServerInterceptor</strong> 责向服务器发送请求数据、从服务器读取响应数据<br>当然，如果有用户自己设计的拦截器，会在上面拦截其执行之前执行。<br>在添加拦截器之后，会构建一个拦截器链<code>RealInterceptorChain</code>，并通过<code>proceed</code>方法开启链式调用。<br>下面我们先来看一下<code>RealInterceptorChain</code>拦截器链的具体实现：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">**</span><br><span class="line"> * A concrete interceptor chain that carries the entire interceptor chain: all application</span><br><span class="line"> * interceptors, the OkHttp core, all network interceptors, and finally the network caller.</span><br><span class="line"> *&#x2F;</span><br><span class="line">public final class RealInterceptorChain implements Interceptor.Chain &#123;</span><br><span class="line">  private final List&lt;Interceptor&gt; interceptors;</span><br><span class="line">  private final StreamAllocation streamAllocation;</span><br><span class="line">  private final HttpCodec httpCodec;</span><br><span class="line">  private final RealConnection connection;</span><br><span class="line">  private final int index;</span><br><span class="line">  private final Request request;</span><br><span class="line">  private int calls;</span><br><span class="line"></span><br><span class="line">  public RealInterceptorChain(List&lt;Interceptor&gt; interceptors, StreamAllocation streamAllocation,</span><br><span class="line">      HttpCodec httpCodec, RealConnection connection, int index, Request request) &#123;</span><br><span class="line">    this.interceptors &#x3D; interceptors;</span><br><span class="line">    this.connection &#x3D; connection;</span><br><span class="line">    this.streamAllocation &#x3D; streamAllocation;</span><br><span class="line">    this.httpCodec &#x3D; httpCodec;</span><br><span class="line">    this.index &#x3D; index;</span><br><span class="line">    this.request &#x3D; request;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override public Connection connection() &#123;</span><br><span class="line">    return connection;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public StreamAllocation streamAllocation() &#123;</span><br><span class="line">    return streamAllocation;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public HttpCodec httpStream() &#123;</span><br><span class="line">    return httpCodec;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override public Request request() &#123;</span><br><span class="line">    return request;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override public Response proceed(Request request) throws IOException &#123;</span><br><span class="line">    return proceed(request, streamAllocation, httpCodec, connection);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public Response proceed(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec,</span><br><span class="line">      RealConnection connection) throws IOException &#123;</span><br><span class="line">    if (index &gt;&#x3D; interceptors.size()) throw new AssertionError();</span><br><span class="line"></span><br><span class="line">    calls++;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; If we already have a stream, confirm that the incoming request will use it.</span><br><span class="line">    if (this.httpCodec !&#x3D; null &amp;&amp; !this.connection.supportsUrl(request.url())) &#123;</span><br><span class="line">      throw new IllegalStateException(&quot;network interceptor &quot; + interceptors.get(index - 1)</span><br><span class="line">          + &quot; must retain the same host and port&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; If we already have a stream, confirm that this is the only call to chain.proceed().</span><br><span class="line">    if (this.httpCodec !&#x3D; null &amp;&amp; calls &gt; 1) &#123;</span><br><span class="line">      throw new IllegalStateException(&quot;network interceptor &quot; + interceptors.get(index - 1)</span><br><span class="line">          + &quot; must call proceed() exactly once&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Call the next interceptor in the chain.</span><br><span class="line">    RealInterceptorChain next &#x3D; new RealInterceptorChain(</span><br><span class="line">        interceptors, streamAllocation, httpCodec, connection, index + 1, request);</span><br><span class="line">    Interceptor interceptor &#x3D; interceptors.get(index);</span><br><span class="line">    Response response &#x3D; interceptor.intercept(next);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Confirm that the next interceptor made its required call to chain.proceed().</span><br><span class="line">    if (httpCodec !&#x3D; null &amp;&amp; index + 1 &lt; interceptors.size() &amp;&amp; next.calls !&#x3D; 1) &#123;</span><br><span class="line">      throw new IllegalStateException(&quot;network interceptor &quot; + interceptor</span><br><span class="line">          + &quot; must call proceed() exactly once&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Confirm that the intercepted response isn&#39;t null.</span><br><span class="line">    if (response &#x3D;&#x3D; null) &#123;</span><br><span class="line">      throw new NullPointerException(&quot;interceptor &quot; + interceptor + &quot; returned null&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return response;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
上面代码比较多，重要的内容并不多，我们只需要看着重看第63行到66行就可以。从整体上来说，<code>RealInterceptorChain</code>中的<code>proceed</code>方法主要做了两件事情：</li>
</ol>
<ul>
<li>实例化下一个拦截器对应的<code>RealIterceptorChain</code>对象，这个对象会传递给当前的拦截器</li>
<li>调用当前拦截器的<code>intercept</code>方法，将下一个拦截器的<code>orChain</code>对象传递下去。</li>
</ul>
<p>接下来我们就来分析以下传入到拦截器链中的拦截器的具体内容.我们首先来分析第一个拦截器：</p>
<h2 id="RetryAndFollowUpInterceptor拦截器"><a href="#RetryAndFollowUpInterceptor拦截器" class="headerlink" title="RetryAndFollowUpInterceptor拦截器"></a>RetryAndFollowUpInterceptor拦截器</h2><p>作用：</p>
<ul>
<li>在网络请求失败后重试</li>
<li>当服务器返回当前请求需要进行重定向时直接发起新的请求，并在条件允许的情况下复用当前连接<br>其在<code>RetryAndFollowUpInterceptor</code>类中的构造函数和重要方法<code>Response</code>的实现如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">private static final int MAX_FOLLOW_UPS &#x3D; 20;</span><br><span class="line">private final OkHttpClient client;</span><br><span class="line">private final boolean forWebSocket;</span><br><span class="line">private StreamAllocation streamAllocation;</span><br><span class="line">private Object callStackTrace;</span><br><span class="line">private volatile boolean canceled;</span><br><span class="line"></span><br><span class="line">public RetryAndFollowUpInterceptor(OkHttpClient client, boolean forWebSocket) &#123;</span><br><span class="line">  this.client &#x3D; client;</span><br><span class="line">  this.forWebSocket &#x3D; forWebSocket;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override public Response intercept(Chain chain) throws IOException &#123;</span><br><span class="line">  Request request &#x3D; chain.request();</span><br><span class="line"></span><br><span class="line">  streamAllocation &#x3D; new StreamAllocation(</span><br><span class="line">      client.connectionPool(), createAddress(request.url()), callStackTrace);</span><br><span class="line"></span><br><span class="line">  int followUpCount &#x3D; 0;</span><br><span class="line">  Response priorResponse &#x3D; null;</span><br><span class="line">  while (true) &#123;</span><br><span class="line">    if (canceled) &#123;</span><br><span class="line">      streamAllocation.release();</span><br><span class="line">      throw new IOException(&quot;Canceled&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Response response &#x3D; null;</span><br><span class="line">    boolean releaseConnection &#x3D; true;</span><br><span class="line">    try &#123;</span><br><span class="line">    &#x2F;&#x2F;执行下一个拦截器链的proceed方法</span><br><span class="line">      response &#x3D; ((RealInterceptorChain) chain).proceed(request, streamAllocation, null, null);</span><br><span class="line">      releaseConnection &#x3D; false;</span><br><span class="line">    &#125; catch (RouteException e) &#123;</span><br><span class="line">          ...      </span><br><span class="line">    &#125;  finally &#123;</span><br><span class="line">      &#x2F;&#x2F; We&#39;re throwing an unchecked exception. Release any resources.</span><br><span class="line">      if (releaseConnection) &#123;</span><br><span class="line">        streamAllocation.streamFailed(null);</span><br><span class="line">        streamAllocation.release();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Attach the prior response if it exists. Such responses never have a body.</span><br><span class="line">    if (priorResponse !&#x3D; null) &#123;</span><br><span class="line">      response &#x3D; response.newBuilder()</span><br><span class="line">          .priorResponse(priorResponse.newBuilder()</span><br><span class="line">                  .body(null)</span><br><span class="line">                  .build())</span><br><span class="line">          .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Request followUp &#x3D; followUpRequest(response);</span><br><span class="line"></span><br><span class="line">    if (followUp &#x3D;&#x3D; null) &#123;</span><br><span class="line">      if (!forWebSocket) &#123;</span><br><span class="line">        streamAllocation.release();</span><br><span class="line">      &#125;</span><br><span class="line">      return response;</span><br><span class="line">    &#125;</span><br><span class="line">    closeQuietly(response.body());</span><br><span class="line"></span><br><span class="line">    if (!sameConnection(response, followUp.url())) &#123;</span><br><span class="line">      streamAllocation.release();</span><br><span class="line">      streamAllocation &#x3D; new StreamAllocation(</span><br><span class="line">          client.connectionPool(), createAddress(followUp.url()), callStackTrace);</span><br><span class="line">    &#125; else if (streamAllocation.codec() !&#x3D; null) &#123;</span><br><span class="line">      throw new IllegalStateException(&quot;Closing the body of &quot; + response</span><br><span class="line">          + &quot; didn&#39;t close its backing stream. Bad interceptor?&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    request &#x3D; followUp;</span><br><span class="line">    priorResponse &#x3D; response;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
经过删减后的代码还是有点多，但是我们只是理解流程的话，值需要特别关注第31行。这行代码是执行下一个拦截器链的<code>proceed</code>方法，而我们知道在下一个拦截器链中又会执行下一个拦截器的<code>intercept</code>方法。所以，整个执行过程都是一个拦截器与拦截链中交替执行，最终完成所有拦截器的操作。</li>
</ul>
<h2 id="BridgeInterceptor拦截器"><a href="#BridgeInterceptor拦截器" class="headerlink" title="BridgeInterceptor拦截器"></a>BridgeInterceptor拦截器</h2><p>作用：<br>    从用户的请求构建网络请求，然后提交给网络，最后从网络相应中提取出用户响应。<br>下面来看源码实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">public final class BridgeInterceptor implements Interceptor &#123;</span><br><span class="line"></span><br><span class="line">private final CookieJar cookieJar;</span><br><span class="line"></span><br><span class="line">  public BridgeInterceptor(CookieJar cookieJar) &#123;</span><br><span class="line">    this.cookieJar &#x3D; cookieJar;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> @Override public Response intercept(Chain chain) throws IOException &#123;</span><br><span class="line">    Request userRequest &#x3D; chain.request();</span><br><span class="line">    Request.Builder requestBuilder &#x3D; userRequest.newBuilder();</span><br><span class="line"></span><br><span class="line">    RequestBody body &#x3D; userRequest.body();</span><br><span class="line">    if (body !&#x3D; null) &#123;</span><br><span class="line">      MediaType contentType &#x3D; body.contentType();</span><br><span class="line">      if (contentType !&#x3D; null) &#123;</span><br><span class="line">        requestBuilder.header(&quot;Content-Type&quot;, contentType.toString());</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      long contentLength &#x3D; body.contentLength();</span><br><span class="line">      if (contentLength !&#x3D; -1) &#123;</span><br><span class="line">        requestBuilder.header(&quot;Content-Length&quot;, Long.toString(contentLength));</span><br><span class="line">        requestBuilder.removeHeader(&quot;Transfer-Encoding&quot;);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        requestBuilder.header(&quot;Transfer-Encoding&quot;, &quot;chunked&quot;);</span><br><span class="line">        requestBuilder.removeHeader(&quot;Content-Length&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (userRequest.header(&quot;Host&quot;) &#x3D;&#x3D; null) &#123;</span><br><span class="line">      requestBuilder.header(&quot;Host&quot;, hostHeader(userRequest.url(), false));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (userRequest.header(&quot;Connection&quot;) &#x3D;&#x3D; null) &#123;</span><br><span class="line">      requestBuilder.header(&quot;Connection&quot;, &quot;Keep-Alive&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; If we add an &quot;Accept-Encoding: gzip&quot; header field we&#39;re responsible for also decompressing</span><br><span class="line">    &#x2F;&#x2F; the transfer stream.</span><br><span class="line">    boolean transparentGzip &#x3D; false;</span><br><span class="line">    if (userRequest.header(&quot;Accept-Encoding&quot;) &#x3D;&#x3D; null &amp;&amp; userRequest.header(&quot;Range&quot;) &#x3D;&#x3D; null) &#123;</span><br><span class="line">      transparentGzip &#x3D; true;</span><br><span class="line">      requestBuilder.header(&quot;Accept-Encoding&quot;, &quot;gzip&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    List&lt;Cookie&gt; cookies &#x3D; cookieJar.loadForRequest(userRequest.url());</span><br><span class="line">    if (!cookies.isEmpty()) &#123;</span><br><span class="line">      requestBuilder.header(&quot;Cookie&quot;, cookieHeader(cookies));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (userRequest.header(&quot;User-Agent&quot;) &#x3D;&#x3D; null) &#123;</span><br><span class="line">      requestBuilder.header(&quot;User-Agent&quot;, Version.userAgent());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Response networkResponse &#x3D; chain.proceed(requestBuilder.build());</span><br><span class="line"></span><br><span class="line">    HttpHeaders.receiveHeaders(cookieJar, userRequest.url(), networkResponse.headers());</span><br><span class="line"></span><br><span class="line">    Response.Builder responseBuilder &#x3D; networkResponse.newBuilder()</span><br><span class="line">        .request(userRequest);</span><br><span class="line"></span><br><span class="line">    if (transparentGzip</span><br><span class="line">        &amp;&amp; &quot;gzip&quot;.equalsIgnoreCase(networkResponse.header(&quot;Content-Encoding&quot;))</span><br><span class="line">        &amp;&amp; HttpHeaders.hasBody(networkResponse)) &#123;</span><br><span class="line">      GzipSource responseBody &#x3D; new GzipSource(networkResponse.body().source());</span><br><span class="line">      Headers strippedHeaders &#x3D; networkResponse.headers().newBuilder()</span><br><span class="line">          .removeAll(&quot;Content-Encoding&quot;)</span><br><span class="line">          .removeAll(&quot;Content-Length&quot;)</span><br><span class="line">          .build();</span><br><span class="line">      responseBuilder.headers(strippedHeaders);</span><br><span class="line">      responseBuilder.body(new RealResponseBody(strippedHeaders, Okio.buffer(responseBody)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return responseBuilder.build();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，<code>BridgeInterceptor</code>中的实现就比较简单了。主要做了如下的工作：</p>
<ul>
<li>设置内容长度，内容编码</li>
<li>设置gzip编码，并在接收到内容后进行解压。</li>
<li>添加cookie</li>
<li>设置其他的报头，如<code>User-Agent</code>,<code>Host</code>,<code>Keep-Alive</code>等。</li>
</ul>
<h2 id="CacheInterceptor拦截器"><a href="#CacheInterceptor拦截器" class="headerlink" title="CacheInterceptor拦截器"></a>CacheInterceptor拦截器</h2><p>作用：主要负责Cache的管理<br>源码分析：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">public final class CacheInterceptor implements Interceptor &#123;</span><br><span class="line">  final InternalCache cache;</span><br><span class="line"></span><br><span class="line">  public CacheInterceptor(InternalCache cache) &#123;</span><br><span class="line">    this.cache &#x3D; cache;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override public Response intercept(Chain chain) throws IOException &#123;</span><br><span class="line">    Response cacheCandidate &#x3D; cache !&#x3D; null</span><br><span class="line">        ? cache.get(chain.request())</span><br><span class="line">        : null;</span><br><span class="line"></span><br><span class="line">    long now &#x3D; System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    CacheStrategy strategy &#x3D; new CacheStrategy.Factory(now, chain.request(), cacheCandidate).get();</span><br><span class="line">    Request networkRequest &#x3D; strategy.networkRequest;</span><br><span class="line">    Response cacheResponse &#x3D; strategy.cacheResponse;</span><br><span class="line"></span><br><span class="line">    if (cache !&#x3D; null) &#123;</span><br><span class="line">      cache.trackResponse(strategy);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (cacheCandidate !&#x3D; null &amp;&amp; cacheResponse &#x3D;&#x3D; null) &#123;</span><br><span class="line">      closeQuietly(cacheCandidate.body()); &#x2F;&#x2F; The cache candidate wasn&#39;t applicable. Close it.</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; If we&#39;re forbidden from using the network and the cache is insufficient, fail.</span><br><span class="line">    if (networkRequest &#x3D;&#x3D; null &amp;&amp; cacheResponse &#x3D;&#x3D; null) &#123;</span><br><span class="line">      return new Response.Builder()</span><br><span class="line">          .request(chain.request())</span><br><span class="line">          .protocol(Protocol.HTTP_1_1)</span><br><span class="line">          .code(504)</span><br><span class="line">          .message(&quot;Unsatisfiable Request (only-if-cached)&quot;)</span><br><span class="line">          .body(Util.EMPTY_RESPONSE)</span><br><span class="line">          .sentRequestAtMillis(-1L)</span><br><span class="line">          .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">          .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; If we don&#39;t need the network, we&#39;re done.</span><br><span class="line">    if (networkRequest &#x3D;&#x3D; null) &#123;</span><br><span class="line">      return cacheResponse.newBuilder()</span><br><span class="line">          .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">          .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Response networkResponse &#x3D; null;</span><br><span class="line">    try &#123;</span><br><span class="line">      networkResponse &#x3D; chain.proceed(networkRequest);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      &#x2F;&#x2F; If we&#39;re crashing on I&#x2F;O or otherwise, don&#39;t leak the cache body.</span><br><span class="line">      if (networkResponse &#x3D;&#x3D; null &amp;&amp; cacheCandidate !&#x3D; null) &#123;</span><br><span class="line">        closeQuietly(cacheCandidate.body());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; If we have a cache response too, then we&#39;re doing a conditional get.</span><br><span class="line">    if (cacheResponse !&#x3D; null) &#123;</span><br><span class="line">      if (networkResponse.code() &#x3D;&#x3D; HTTP_NOT_MODIFIED) &#123;</span><br><span class="line">        Response response &#x3D; cacheResponse.newBuilder()</span><br><span class="line">            .headers(combine(cacheResponse.headers(), networkResponse.headers()))</span><br><span class="line">            .sentRequestAtMillis(networkResponse.sentRequestAtMillis())</span><br><span class="line">            .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis())</span><br><span class="line">            .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">            .networkResponse(stripBody(networkResponse))</span><br><span class="line">            .build();</span><br><span class="line">        networkResponse.body().close();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Update the cache after combining headers but before stripping the</span><br><span class="line">        &#x2F;&#x2F; Content-Encoding header (as performed by initContentStream()).</span><br><span class="line">        cache.trackConditionalCacheHit();</span><br><span class="line">        cache.update(cacheResponse, response);</span><br><span class="line">        return response;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        closeQuietly(cacheResponse.body());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Response response &#x3D; networkResponse.newBuilder()</span><br><span class="line">        .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">        .networkResponse(stripBody(networkResponse))</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line">    if (cache !&#x3D; null) &#123;</span><br><span class="line">      if (HttpHeaders.hasBody(response) &amp;&amp; CacheStrategy.isCacheable(response, networkRequest)) &#123;</span><br><span class="line">        &#x2F;&#x2F; Offer this request to the cache.</span><br><span class="line">        CacheRequest cacheRequest &#x3D; cache.put(response);</span><br><span class="line">        return cacheWritingResponse(cacheRequest, response);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (HttpMethod.invalidatesCache(networkRequest.method())) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">          cache.remove(networkRequest);</span><br><span class="line">        &#125; catch (IOException ignored) &#123;</span><br><span class="line">          &#x2F;&#x2F; The cache cannot be written.</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return response;</span><br><span class="line">  &#125;</span><br><span class="line"> ...</span><br></pre></td></tr></table></figure>
<p>通过上面代码就可以分析出来，<code>CacheInterceptor</code>就是负责管理cache的，具体体现如下:</p>
<ul>
<li>当网络请求有符合要求的cache时直接返回Cache</li>
<li>当服务器返回内容有改变时更新当前cache</li>
<li>如果当前cache失效，则删除</li>
</ul>
<h2 id="ConnectInterceptor拦截器"><a href="#ConnectInterceptor拦截器" class="headerlink" title="ConnectInterceptor拦截器"></a>ConnectInterceptor拦截器</h2><p>作用：与服务端建立连接。<br>具体代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public final class ConnectInterceptor implements Interceptor &#123;</span><br><span class="line">  public final OkHttpClient client;</span><br><span class="line"></span><br><span class="line">  public ConnectInterceptor(OkHttpClient client) &#123;</span><br><span class="line">    this.client &#x3D; client;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override public Response intercept(Chain chain) throws IOException &#123;</span><br><span class="line">    RealInterceptorChain realChain &#x3D; (RealInterceptorChain) chain;</span><br><span class="line">    Request request &#x3D; realChain.request();</span><br><span class="line">    StreamAllocation streamAllocation &#x3D; realChain.streamAllocation();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; We need the network to satisfy this request. Possibly for validating a conditional GET.</span><br><span class="line">    boolean doExtensiveHealthChecks &#x3D; !request.method().equals(&quot;GET&quot;);</span><br><span class="line">    HttpCodec httpCodec &#x3D; streamAllocation.newStream(client, doExtensiveHealthChecks);</span><br><span class="line">    RealConnection connection &#x3D; streamAllocation.connection();</span><br><span class="line"></span><br><span class="line">    return realChain.proceed(request, streamAllocation, httpCodec, connection);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码比较简单，我们简单进行分析。在<code>intercept</code>方法中，通过第15行代码创建了一个<code>httpCodec</code>对象，他将在后面的步骤中用到。简单介绍一下<code>httpCodec</code>，他其实就是对HTTP协议操作的抽象，具体实现有<code>Http1Codec</code>(对象HTTP1.1)、<code>Http2Codec</code>(对应Http2.0)两种。<br>然后通过第16行与服务端建立联系，因为里面的代码比较多，就不展开了。</p>
<p>##CallServerInterceptor拦截器<br>作用：发送和接收数据。<br>具体源码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">@Override public Response intercept(Chain chain) throws IOException &#123;</span><br><span class="line">    RealInterceptorChain realChain &#x3D; (RealInterceptorChain) chain;</span><br><span class="line">    HttpCodec httpCodec &#x3D; realChain.httpStream();</span><br><span class="line">    StreamAllocation streamAllocation &#x3D; realChain.streamAllocation();</span><br><span class="line">    RealConnection connection &#x3D; (RealConnection) realChain.connection();</span><br><span class="line">    Request request &#x3D; realChain.request();</span><br><span class="line"></span><br><span class="line">    long sentRequestMillis &#x3D; System.currentTimeMillis();</span><br><span class="line">    httpCodec.writeRequestHeaders(request);</span><br><span class="line"></span><br><span class="line">    Response.Builder responseBuilder &#x3D; null;</span><br><span class="line">    if (HttpMethod.permitsRequestBody(request.method()) &amp;&amp; request.body() !&#x3D; null) &#123;</span><br><span class="line">      &#x2F;&#x2F; If there&#39;s a &quot;Expect: 100-continue&quot; header on the request, wait for a &quot;HTTP&#x2F;1.1 100</span><br><span class="line">      &#x2F;&#x2F; Continue&quot; response before transmitting the request body. If we don&#39;t get that, return what</span><br><span class="line">      &#x2F;&#x2F; we did get (such as a 4xx response) without ever transmitting the request body.</span><br><span class="line">      if (&quot;100-continue&quot;.equalsIgnoreCase(request.header(&quot;Expect&quot;))) &#123;</span><br><span class="line">        httpCodec.flushRequest();</span><br><span class="line">        responseBuilder &#x3D; httpCodec.readResponseHeaders(true);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (responseBuilder &#x3D;&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F; Write the request body if the &quot;Expect: 100-continue&quot; expectation was met.</span><br><span class="line">        Sink requestBodyOut &#x3D; httpCodec.createRequestBody(request, request.body().contentLength());</span><br><span class="line">        BufferedSink bufferedRequestBody &#x3D; Okio.buffer(requestBodyOut);</span><br><span class="line">        request.body().writeTo(bufferedRequestBody);</span><br><span class="line">        bufferedRequestBody.close();</span><br><span class="line">      &#125; else if (!connection.isMultiplexed()) &#123;</span><br><span class="line">        &#x2F;&#x2F; If the &quot;Expect: 100-continue&quot; expectation wasn&#39;t met, prevent the HTTP&#x2F;1 connection from</span><br><span class="line">        &#x2F;&#x2F; being reused. Otherwise we&#39;re still obligated to transmit the request body to leave the</span><br><span class="line">        &#x2F;&#x2F; connection in a consistent state.</span><br><span class="line">        streamAllocation.noNewStreams();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    httpCodec.finishRequest();</span><br><span class="line"></span><br><span class="line">    if (responseBuilder &#x3D;&#x3D; null) &#123;</span><br><span class="line">      responseBuilder &#x3D; httpCodec.readResponseHeaders(false);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Response response &#x3D; responseBuilder</span><br><span class="line">        .request(request)</span><br><span class="line">        .handshake(streamAllocation.connection().handshake())</span><br><span class="line">        .sentRequestAtMillis(sentRequestMillis)</span><br><span class="line">        .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">        .build();</span><br><span class="line">&#x2F;&#x2F;。。。省略部分代码。。。</span><br><span class="line">    return response;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>作为拦截连中最后的一个拦截器，我们有必要对其进行分析。我们还是只针对核心部分进行解析：这段代码主要做了这么几件事：</p>
<ol>
<li>首先获取<code>HttpCodec</code>对象，至于这个对象的产生在前面的<code>ConnectInterceptor</code>拦截器中。</li>
<li>通过<code>writeRequestHeaders</code>方法将<code>request</code>写入头部；</li>
<li>判断是否有需要写入请求的<code>body</code>部分，最后调用<code>finishRequest</code>将所有的数据刷新给底层的Sokcet；</li>
<li>通过调用<code>readResponseHeaders</code>方法读取响应的头部，；</li>
<li>然后通过构建一个新的<code>Response</code>对象，并通过<code>openResponseBody</code>获取返回的<code>body</code>。</li>
<li>最后将构建好的<code>response</code>对象返回。</li>
</ol>
<p>##总体流程图<br>通过上面的分析，对Okhttp网络请求的流程应该已经有一个比较清晰的认识了，下面是大神总结的一张整体流程图。<br><img src="http://upload-images.jianshu.io/upload_images/4037105-dc97d1a43aed5334?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="okHttp流程图"><br>这篇文章只是对Okhttp整体做流程进行分析，很多的细节部分并没有深入去了解。譬如缓存管理，比如真正的网络请求，譬如IO操作。我们都只停留在具体的方法上。通过这篇文章，我们只知道，Okhhtp的底层是通过Socket进行通信的，利用<code>OkIo</code>来进行高效的IO操作，在缓存方面，使用了LRUCache算法。具体的细节，这里就不展开具体去深入了。</p>
<h1 id="整体流程分析"><a href="#整体流程分析" class="headerlink" title="整体流程分析"></a>整体流程分析</h1><p>通过上面的简单使用来看，可以初步看出okhttp的整体流程。<br><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/f6e2ac304ee22891eca4ad1218602044.png" alt="总体架构图"><br>上图是OkHttp的总体架构，大致可以分为以下几层：</p>
<ul>
<li>Interface——接口层：接受网络访问请求</li>
<li>Protocol——协议层：处理协议逻辑</li>
<li>Connection——连接层：管理网络连接，发送新的请求，接收服务器访问</li>
<li>Cache——缓存层：管理本地缓存</li>
<li>I/O——I/O层：实际数据读写实现</li>
<li>Inteceptor——拦截器层：拦截网络访问，插入拦截逻辑</li>
</ul>
<h1 id="Okhttp的优势与特点"><a href="#Okhttp的优势与特点" class="headerlink" title="Okhttp的优势与特点"></a>Okhttp的优势与特点</h1><ul>
<li>支持HTTPS/HTTP2/WebSocket等协议</li>
<li>友好支持并发访问，支持多路复用</li>
<li>提供拦截器</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://github.com/square/okhttp" target="_blank" rel="noopener">okhttp的github地址</a></li>
<li><a href="https://yq.aliyun.com/articles/78105?spm=5176.100239.blogcont78104.10.kmOxk1" target="_blank" rel="noopener">OKhttp3.7源码分析</a></li>
<li><a href="http://frodoking.github.io/2015/03/12/android-okhttp/" target="_blank" rel="noopener">OKHttp源码解析</a></li>
<li><a href="http://www.jianshu.com/p/9ed2c2f2a52c" target="_blank" rel="noopener">android面试题-okhttp内核剖析</a></li>
<li><a href="http://blog.csdn.net/xiaanming/article/details/26810303/" target="_blank" rel="noopener">okhttp基本使用与介绍</a></li>
<li><a href="https://blog.piasy.com/2016/07/11/Understand-OkHttp/" target="_blank" rel="noopener">拆轮子系列，Okhttp解析</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://reoger.tk/2017/09/02/imageLoader%E8%A7%A3%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="reoger">
      <meta itemprop="description" content="reoger">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="reoger的记录">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/09/02/imageLoader%E8%A7%A3%E6%9E%90/" class="post-title-link" itemprop="url">imageLoader解析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-09-02 19:00:47" itemprop="dateCreated datePublished" datetime="2017-09-02T19:00:47+08:00">2017-09-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2017-09-11 15:32:08" itemprop="dateModified" datetime="2017-09-11T15:32:08+08:00">2017-09-11</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/" itemprop="url" rel="index"><span itemprop="name">源码解读</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p><code>ImageLoader</code>是最早开源的 <code>Android</code> 图片缓存库, 强大的缓存机制, 早期使用这个图片加载框架的android应用非常多， 至今仍然有不少<code>Android</code> 开发者在使用。</p>
</blockquote>
<h1 id="ImagerLoader特征"><a href="#ImagerLoader特征" class="headerlink" title="ImagerLoader特征"></a>ImagerLoader特征</h1><ol>
<li>支持本地、网络图片，且支持图片下载的进度监听</li>
<li>支持个性化配置ImagerLoader，如线程池，内存缓存策略，图片显示选项等</li>
<li>三层缓存加快图片的加载速度</li>
<li>支持图片压缩</li>
</ol>
<h1 id="开始使用"><a href="#开始使用" class="headerlink" title="开始使用"></a>开始使用</h1><p>鉴于这篇是对ImageLoader源码来进行解析，我们首先回顾一下<code>ImageLoader</code>的使用。<br>可以通过<a href="https://github.com/nostra13/Android-Universal-Image-Loader/raw/master/downloads/universal-image-loader-1.9.5.jar" target="_blank" rel="noopener">这里</a>下载<code>universal-imager-loader</code>的jar包，并将其导入到自己的项目中。<br>然后可以在<code>Application</code>或者<code>Activity</code>中初始化<code>ImageLoade</code>，参考如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class YourApplication extends Application &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onCreate() &#123;</span><br><span class="line">        super.onCreate();</span><br><span class="line">        &#x2F;&#x2F;创建默认的ImageLoader配置参数  </span><br><span class="line">        ImageLoaderConfiguration configuration &#x3D; ImageLoaderConfiguration  </span><br><span class="line">                .createDefault(this);  </span><br><span class="line">          </span><br><span class="line">        &#x2F;&#x2F;Initialize ImageLoader with configuration.  </span><br><span class="line">        ImageLoader.getInstance().init(configuration);  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，如果涉及到网络操作和磁盘缓存的话，有或者是在<code>Application</code>中进行初始化的话，记得要在<code>Manifest</code>中进行申明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;manifest&gt;  </span><br><span class="line">    &lt;uses-permission android:name&#x3D;&quot;android.permission.INTERNET&quot; &#x2F;&gt;  </span><br><span class="line">    &lt;!-- Include next permission if you want to allow UIL to cache images on SD card --&gt;  </span><br><span class="line">    &lt;uses-permission android:name&#x3D;&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; &#x2F;&gt;  </span><br><span class="line">    ...  </span><br><span class="line">    &lt;application android:name&#x3D;&quot;YourApplication&quot;&gt;  </span><br><span class="line">        ...  </span><br><span class="line">    &lt;&#x2F;application&gt;  </span><br><span class="line">&lt;&#x2F;manifest&gt;</span><br></pre></td></tr></table></figure>
<p>接下来我们就可以愉快的来加载图片了，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ImageLoader.getInstance().displayImage(imageUri, imageView);</span><br></pre></td></tr></table></figure>
<p>当然，如果你想添加监听，可以这么写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ImageLoader.getInstance().loadImage(imageUrl, new SimpleImageLoadingListener()&#123;  </span><br><span class="line">  </span><br><span class="line">            @Override  </span><br><span class="line">            public void onLoadingComplete(String imageUri, View view,  </span><br><span class="line">                    Bitmap loadedImage) &#123;  </span><br><span class="line">                super.onLoadingComplete(imageUri, view, loadedImage);  </span><br><span class="line">                mImageView.setImageBitmap(loadedImage);  </span><br><span class="line">            &#125;  </span><br><span class="line">              </span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>
<p>至于更多的用法这里就不介绍了，如果有需要，可以参看这篇<a href="http://blog.csdn.net/abc6368765/article/details/52510761" target="_blank" rel="noopener">博客</a>，了解更多关于ImageLoader的用法。下面就开始了源码的解析之路。</p>
<h1 id="ImageLoaderConfiguration配置实现"><a href="#ImageLoaderConfiguration配置实现" class="headerlink" title="ImageLoaderConfiguration配置实现"></a>ImageLoaderConfiguration配置实现</h1><p>我们首先还是从<code>imageLoader</code>的配置开始开始源码的探究之旅把。在上面的使用实例中，我们使用<code>createDefault()</code>方法来初始化配置，那么<code>imageLoader</code>的默认配置究竟是些什么呢？下面直接上代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">public static ImageLoaderConfiguration createDefault(Context context) &#123;</span><br><span class="line">    return new Builder(context).build();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public ImageLoaderConfiguration build() &#123;</span><br><span class="line">    initEmptyFieldsWithDefaultValues();</span><br><span class="line">    return new ImageLoaderConfiguration(this);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void initEmptyFieldsWithDefaultValues() &#123;</span><br><span class="line">    if (taskExecutor &#x3D;&#x3D; null) &#123;</span><br><span class="line">        taskExecutor &#x3D; DefaultConfigurationFactory</span><br><span class="line">                .createExecutor(threadPoolSize, threadPriority, tasksProcessingType);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        customExecutor &#x3D; true;</span><br><span class="line">    &#125;</span><br><span class="line">    if (taskExecutorForCachedImages &#x3D;&#x3D; null) &#123;</span><br><span class="line">        taskExecutorForCachedImages &#x3D; DefaultConfigurationFactory</span><br><span class="line">                .createExecutor(threadPoolSize, threadPriority, tasksProcessingType);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        customExecutorForCachedImages &#x3D; true;</span><br><span class="line">    &#125;</span><br><span class="line">    if (diskCache &#x3D;&#x3D; null) &#123;</span><br><span class="line">        if (diskCacheFileNameGenerator &#x3D;&#x3D; null) &#123;</span><br><span class="line">            diskCacheFileNameGenerator &#x3D; DefaultConfigurationFactory.createFileNameGenerator();</span><br><span class="line">        &#125;</span><br><span class="line">        diskCache &#x3D; DefaultConfigurationFactory</span><br><span class="line">                .createDiskCache(context, diskCacheFileNameGenerator, diskCacheSize, diskCacheFileCount);</span><br><span class="line">    &#125;</span><br><span class="line">    if (memoryCache &#x3D;&#x3D; null) &#123;</span><br><span class="line">        memoryCache &#x3D; DefaultConfigurationFactory.createMemoryCache(context, memoryCacheSize);</span><br><span class="line">    &#125;</span><br><span class="line">    if (denyCacheImageMultipleSizesInMemory) &#123;</span><br><span class="line">        memoryCache &#x3D; new FuzzyKeyMemoryCache(memoryCache, MemoryCacheUtils.createFuzzyKeyComparator());</span><br><span class="line">    &#125;</span><br><span class="line">    if (downloader &#x3D;&#x3D; null) &#123;</span><br><span class="line">        downloader &#x3D; DefaultConfigurationFactory.createImageDownloader(context);</span><br><span class="line">    &#125;</span><br><span class="line">    if (decoder &#x3D;&#x3D; null) &#123;</span><br><span class="line">        decoder &#x3D; DefaultConfigurationFactory.createImageDecoder(writeLogs);</span><br><span class="line">    &#125;</span><br><span class="line">    if (defaultDisplayImageOptions &#x3D;&#x3D; null) &#123;</span><br><span class="line">        defaultDisplayImageOptions &#x3D; DisplayImageOptions.createSimple();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line">private ImageLoaderConfiguration(final Builder builder) &#123;</span><br><span class="line">    resources &#x3D; builder.context.getResources();&#x2F;&#x2F;程序本地资源访问器</span><br><span class="line">    maxImageWidthForMemoryCache &#x3D; builder.maxImageWidthForMemoryCache;&#x2F;&#x2F;内存缓存的图片最大宽度 </span><br><span class="line">    maxImageHeightForMemoryCache &#x3D; builder.maxImageHeightForMemoryCache;&#x2F;&#x2F;内存缓存的图片最大高度 </span><br><span class="line">    maxImageWidthForDiskCache &#x3D; builder.maxImageWidthForDiskCache;&#x2F;&#x2F;磁盘缓存的图片最大宽度 </span><br><span class="line">    maxImageHeightForDiskCache &#x3D; builder.maxImageHeightForDiskCache;&#x2F;&#x2F;磁盘缓存的图片最大高度 </span><br><span class="line">    processorForDiskCache &#x3D; builder.processorForDiskCache;&#x2F;&#x2F;图片处理器，用于处理从磁盘缓存中读取到的图片 </span><br><span class="line">    taskExecutor &#x3D; builder.taskExecutor;&#x2F;&#x2F;ImageLoaderEngine中用于执行从源获取图片任务的 Executor。</span><br><span class="line">    taskExecutorForCachedImages &#x3D; builder.taskExecutorForCachedImages;&#x2F;&#x2F;ImageLoaderEngine中用于执行从缓存获取图片任务的 Executor。</span><br><span class="line">    threadPoolSize &#x3D; builder.threadPoolSize;&#x2F;&#x2F;上面两个默认线程池的核心池大小，即最大并发数。</span><br><span class="line">    threadPriority &#x3D; builder.threadPriority;&#x2F;&#x2F;上面两个默认线程池的线程优先级。</span><br><span class="line">    tasksProcessingType &#x3D; builder.tasksProcessingType;&#x2F;&#x2F;上面两个默认线程池的线程队列类型。目前只有 FIFO, LIFO 两种可供选择。</span><br><span class="line">    diskCache &#x3D; builder.diskCache;&#x2F;&#x2F;图片磁盘缓存，一般放在 SD 卡。</span><br><span class="line">    memoryCache &#x3D; builder.memoryCache;&#x2F;&#x2F;图片内存缓存。</span><br><span class="line">    defaultDisplayImageOptions &#x3D; builder.defaultDisplayImageOptions;&#x2F;&#x2F;图片显示的配置项。比如加载前、加载中、加载失败应该显示的占位图片，图片是否需要在磁盘缓存，是否需要在内存缓存等。</span><br><span class="line">    downloader &#x3D; builder.downloader;&#x2F;&#x2F;图片下载器。</span><br><span class="line">    decoder &#x3D; builder.decoder;&#x2F;&#x2F;图片解码器，内部可使用我们常用的BitmapFactory.decode(…)将图片资源解码成Bitmap对象。</span><br><span class="line"></span><br><span class="line">    customExecutor &#x3D; builder.customExecutor;&#x2F;&#x2F;用户是否自定义了上面的 taskExecutor。</span><br><span class="line">    customExecutorForCachedImages &#x3D; builder.customExecutorForCachedImages;&#x2F;&#x2F;用户是否自定义了上面的 taskExecutorForCachedImages。</span><br><span class="line"></span><br><span class="line">    networkDeniedDownloader &#x3D; new NetworkDeniedImageDownloader(downloader);&#x2F;&#x2F;不允许访问网络的图片下载器。</span><br><span class="line">    slowNetworkDownloader &#x3D; new SlowNetworkImageDownloader(downloader);&#x2F;&#x2F;慢网络情况下的图片下载器。</span><br><span class="line"></span><br><span class="line">    L.writeDebugLogs(builder.writeLogs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码有点多，但是很简单也很清晰，就是一些列初始化的代码。通过一些系列的调用，在<code>initEmptyFieldsWithDefaultValues</code>方法中对一些没有配置的进行的项进行配置，并通过<code>ImageLoaderConfiguration</code>给出默认的参数配置。对于其中的一些配置，在上面的注释中已经表明，<code>ImageLoaderConfiguration</code>中默认的配置，可以参考第48-73行。<br>至于<code>initEmptyFieldsWithDefaultValues</code>中的配置，在这里进行简单的介绍：</p>
<ul>
<li><strong>taskExecutor</strong> 从源获取图片任务的线程池</li>
<li><strong>taskExecutorForCachedImages</strong> 用于执行从缓存获取图片任务的线程池<br>前面两个线程池的参数如下：<table>
<thead>
<tr>
<th>核心线程数</th>
<th align="right">最大线程数</th>
<th align="center">空闲线程等待时间</th>
<th>容器</th>
</tr>
</thead>
<tbody><tr>
<td>3</td>
<td align="right">3</td>
<td align="center">0s</td>
<td>2</td>
</tr>
<tr>
<td>前面两个线程池如果用户自定义的相应的线程池来实现的话，就会将<code>customExecutor</code>置为<code>true</code>，或将<code>customExecutorForCachedImages</code>置为<code>true</code>。其实<code>customExecutor</code>存在的意义就在于判断用户有没有自定义从源获取图片任务的线程池，<code>customExecutorForCachedImages</code>存在的意义判断在于用户判断用户有没有重写从缓存获取图片的线程池。</td>
<td align="right"></td>
<td align="center"></td>
<td></td>
</tr>
</tbody></table>
</li>
<li><strong>diskCacheFileNameGenerator</strong> 默认实现为<code>HashCodeFileNameGenerator</code>，即用<code>mageUri.hashCode()</code>值当前图片名字。</li>
<li><strong>diskCache</strong>用于表示图片磁盘的缓存，默认实现为<code>createDiskCache</code>，默认的算法为<code>LruDiskCache</code>算法，缓存的目录为SD卡下的<code>/data/data/&quot; + context.getPackageName() + &quot;/cache/uil-images</code>目录下。</li>
<li><strong>memoryCache</strong>用于表示图片内存的缓存，默认实现为<code>createMemoryCache</code>,默认使用的算法为<code>LruMemoryCache</code>。</li>
<li><strong>denyCacheImageMultipleSizesInMemory</strong> 为<code>true</code>时，表示内存缓存不允许缓存一张图片的多个尺寸。这个时候用通过<code>FuzzyKeyMemoryCache</code>来构建<code>memoryCache</code></li>
<li><strong>downloader</strong>表示图片下载器，默认实现为<code>createImageDownloader</code>，最终通过<code>BaseImageDownloader</code>构建下载器，其下载器中重要的两个参数分别为：连接超时时间<code>connectTimeout</code>默认值为5分钟，读取超时时间<code>readTimeout</code>默认值为20分钟。</li>
<li><strong>decoder</strong> 表示图片解码器，默认实现为<code>createImageDecoder</code>，最终通过<code>BaseImageDecoder</code>实现。</li>
<li><strong>defaultDisplayImageOptions</strong> 表示默认参数，最终回调到<code>DisplayImageOptions</code>方法中，里面设计相关的参数初始化。这里就不展开了。</li>
</ul>
<h1 id="加载配置"><a href="#加载配置" class="headerlink" title="加载配置"></a>加载配置</h1><p>我们首先看<code>Application</code>中<code>imgaerLoader</code>设置配置的方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ImageLoader.getInstance().init(configuration);</span><br></pre></td></tr></table></figure>
<p>接下来我们继续分析上面的代码是如何将配置应用到ImageLoader中的。首先是<code>ImageLoader.getInstance()</code>实例化一个<code>ImageLoader</code>，通过代码来看实例化的过程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static ImageLoader getInstance() &#123;</span><br><span class="line">    if (instance &#x3D;&#x3D; null) &#123;</span><br><span class="line">        synchronized (ImageLoader.class) &#123;</span><br><span class="line">            if (instance &#x3D;&#x3D; null) &#123;</span><br><span class="line">                instance &#x3D; new ImageLoader();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出来，<code>getInstance</code>就是获取一个<code>ImageLoader</code>实例，运用了一个双重锁的单利模式，很简单，就不做解释了。<br>重点看<code>init</code>方法。具体在<code>ImageLoader</code>类中的实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public synchronized void init(ImageLoaderConfiguration configuration) &#123;</span><br><span class="line">        if (configuration &#x3D;&#x3D; null) &#123;</span><br><span class="line">            throw new IllegalArgumentException(ERROR_INIT_CONFIG_WITH_NULL);</span><br><span class="line">        &#125;</span><br><span class="line">        if (this.configuration &#x3D;&#x3D; null) &#123;</span><br><span class="line">            L.d(LOG_INIT_CONFIG);</span><br><span class="line">            engine &#x3D; new ImageLoaderEngine(configuration);</span><br><span class="line">            this.configuration &#x3D; configuration;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            L.w(WARNING_RE_INIT_CONFIG);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看出来，<code>init</code>的实现也是非常简单的。首先判断传入的<code>configuration</code>参数是否为空，为空就直接抛出一个异常，不为空就判断当前类属性<code>configuration</code>是否为空，类中<code>configuration</code>属性为空时调用<code>ImageLoaderEngine</code>构建<code>engine</code>对象，否则就打印警告日志。所以整个方法中最重要的一个语句就是<code>new ImageLoaderEngine(configuration);</code>。这里首先介绍一个<code>ImageLoaderEngine</code>类的作用。简单描述就是<code>ImageLoaderEngine</code>是任务分发器，负责分发<code>LoadAndDisplayImageTask</code>和<code>ProcessAndDisplayImageTask</code>给具体的线程池去执行。具体实现后面会讲到。</p>
<h1 id="加载图片"><a href="#加载图片" class="headerlink" title="加载图片"></a>加载图片</h1><p>通过上面两个步骤，imgaeLoder的参数配置已经设置完毕，接下来我们就可以用imageLoader加载图片了。下面是三种加载图片的方式：<br><strong>加载方式一，异步加载并显示图片到对应的imagerAware上</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ImageLoader.getInstance().displayImage(imageUrl,imageView);</span><br></pre></td></tr></table></figure>
<p><strong>加载方式二，异步加载图片并执行回调接口</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">ImageLoader.getInstance().loadImage(imageUrl,new  ImageLoadingListener() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onLoadingStarted(String imageUri, View view) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onLoadingFailed(String imageUri, View view, FailReason failReason) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onLoadingComplete(String imageUri, View view, Bitmap loadedImage) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onLoadingCancelled(String imageUri, View view) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><strong>加载方式三，同步加载图片</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ImageLoader.getInstance().loadImageSync(imageUrl);</span><br></pre></td></tr></table></figure>
<p>针对上面三种方法，我们先分析第一种加载图片的方法，其余的两种加载图片的分析也差不多，后面就不具体分析了，只是简单的体现其不同点。<br>我们来看<code>displayImage</code>方法在<code>ImageLoader</code>类中的实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public void displayImage(String uri, ImageView imageView) &#123;</span><br><span class="line">    displayImage(uri, new ImageViewAware(imageView), null, null, null);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void displayImage(String uri, ImageView imageView, ImageSize targetImageSize) &#123;</span><br><span class="line">    displayImage(uri, new ImageViewAware(imageView), null, targetImageSize, null, null);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">public void displayImage(String uri, ImageView imageView, DisplayImageOptions options) &#123;</span><br><span class="line">    displayImage(uri, new ImageViewAware(imageView), options, null, null);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void displayImage(String uri, ImageView imageView, ImageLoadingListener listener) &#123;</span><br><span class="line">    displayImage(uri, new ImageViewAware(imageView), null, listener, null);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void displayImage(String uri, ImageView imageView, DisplayImageOptions options,</span><br><span class="line">        ImageLoadingListener listener) &#123;</span><br><span class="line">    displayImage(uri, imageView, options, listener, null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看到上面的<code>displayImage</code>有很多中重载的方法，最终他们都会调用到下面的这个<code>displayImage</code>方法中来。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">public void displayImage(String uri, ImageAware imageAware, DisplayImageOptions options,</span><br><span class="line">        ImageSize targetSize, ImageLoadingListener listener, ImageLoadingProgressListener progressListener) &#123;</span><br><span class="line">    &#x2F;&#x2F;省略了部分判空代码</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    if (targetSize &#x3D;&#x3D; null) &#123;</span><br><span class="line">        targetSize &#x3D; ImageSizeUtils.defineTargetSizeForView(imageAware, configuration.getMaxImageSize());</span><br><span class="line">    &#125;</span><br><span class="line">    String memoryCacheKey &#x3D; MemoryCacheUtils.generateKey(uri, targetSize);</span><br><span class="line">    engine.prepareDisplayTaskFor(imageAware, memoryCacheKey);</span><br><span class="line"></span><br><span class="line">    listener.onLoadingStarted(uri, imageAware.getWrappedView());</span><br><span class="line"></span><br><span class="line">    Bitmap bmp &#x3D; configuration.memoryCache.get(memoryCacheKey);</span><br><span class="line">    if (bmp !&#x3D; null &amp;&amp; !bmp.isRecycled()) &#123;</span><br><span class="line">        L.d(LOG_LOAD_IMAGE_FROM_MEMORY_CACHE, memoryCacheKey);</span><br><span class="line"></span><br><span class="line">        if (options.shouldPostProcess()) &#123;</span><br><span class="line">            ImageLoadingInfo imageLoadingInfo &#x3D; new ImageLoadingInfo(uri, imageAware, targetSize, memoryCacheKey,</span><br><span class="line">                    options, listener, progressListener, engine.getLockForUri(uri));</span><br><span class="line">            ProcessAndDisplayImageTask displayTask &#x3D; new ProcessAndDisplayImageTask(engine, bmp, imageLoadingInfo,</span><br><span class="line">                    defineHandler(options));</span><br><span class="line">            if (options.isSyncLoading()) &#123;</span><br><span class="line">                displayTask.run();</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                engine.submit(displayTask);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            options.getDisplayer().display(bmp, imageAware, LoadedFrom.MEMORY_CACHE);</span><br><span class="line">            listener.onLoadingComplete(uri, imageAware.getWrappedView(), bmp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (options.shouldShowImageOnLoading()) &#123;</span><br><span class="line">            imageAware.setImageDrawable(options.getImageOnLoading(configuration.resources));</span><br><span class="line">        &#125; else if (options.isResetViewBeforeLoading()) &#123;</span><br><span class="line">            imageAware.setImageDrawable(null);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ImageLoadingInfo imageLoadingInfo &#x3D; new ImageLoadingInfo(uri, imageAware, targetSize, memoryCacheKey,</span><br><span class="line">                options, listener, progressListener, engine.getLockForUri(uri));</span><br><span class="line">        LoadAndDisplayImageTask displayTask &#x3D; new LoadAndDisplayImageTask(engine, imageLoadingInfo,</span><br><span class="line">                defineHandler(options));</span><br><span class="line">        if (options.isSyncLoading()) &#123;</span><br><span class="line">            displayTask.run();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            engine.submit(displayTask);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从第6行开始看，当没有传入<code>targetSize</code>目标尺寸时，会通过第6行的代码产生一个合适的尺寸。具体逻辑为，当image没有尺寸时就采用测量出来的最大尺寸，当image有尺寸时就用image本身的尺寸。获取最大尺寸的逻辑为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ImageSize getMaxImageSize() &#123;</span><br><span class="line">        &#x2F;&#x2F;获取屏幕像素</span><br><span class="line">        DisplayMetrics displayMetrics &#x3D; resources.getDisplayMetrics();</span><br><span class="line"></span><br><span class="line">        int width &#x3D; maxImageWidthForMemoryCache;&#x2F;&#x2F;最大的图片内存缓存宽度</span><br><span class="line">        if (width &lt;&#x3D; 0) &#123;</span><br><span class="line">            width &#x3D; displayMetrics.widthPixels;&#x2F;&#x2F;屏幕宽度</span><br><span class="line">        &#125;</span><br><span class="line">        int height &#x3D; maxImageHeightForMemoryCache;&#x2F;&#x2F;最大的图片内存缓存高度</span><br><span class="line">        if (height &lt;&#x3D; 0) &#123;</span><br><span class="line">            height &#x3D; displayMetrics.heightPixels;&#x2F;&#x2F;屏幕高度</span><br><span class="line">        &#125;</span><br><span class="line">        return new ImageSize(width, height);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>即最大的尺寸为：如设置了<code>maxImageWidthForMemoryCache</code>值且该值大于0，则最大尺寸为其设置的值，否则屏幕宽度。在高度上也一样，就不赘述了。综上，我们可以知道要显示图片的大小的逻辑，<strong>我们设置了图片显示的尺寸，则图片尺寸为我们设置的尺寸。否则图片的本身有尺寸的时候，显示的就是自己本身的尺寸，否则就显示最大的图片尺寸。当最大图片内存缓存尺寸大于0时，最大图片尺寸即为最大图片内存尺寸，否则为屏幕尺寸。</strong><br>分析了那么久，其实还只是分析了<code>displayImage</code>方法的一个方法，下面我们继续看<code>displayImage</code>中的实现。在计算好目标图片的尺寸之后，利用<code>generateKey</code>方法生成一个<code>memoryCacheKey</code>，这里的<code>memoryCacheKey</code>的组成形式为<code>URI + size</code>，用于表示要加载到内存中的图片。通过第10行代码，将要加载的图片加入到<code>cacheKeysForImageAwares</code>队列中,他是一个<code>Collections.synchronizedMap(new HashMap&lt;Integer, String&gt;())</code>类型的队列，他用来记录正在加载的任务，加载图片的时候会将<code>ImageView</code>的<code>id</code>和图片的<code>url</code>加上尺寸加入到<code>HashMap</code>中，加载完成之后会将其移除。然后通过第12行的代码回调<code>onLoadingStarted</code>方法，这个方法就是我们在使用时的<code>onLoadingStarted</code>方法回调,具体参考上面的<strong>加载方式二，异步加载图片并执行回调接口</strong>的使用实例。<br>对于最终调用的<code>displayImage</code>方法代码很重要，所以我们继续往下分析其中的代码。以下的代码已经省略前面已经分析的代码，完整代码参考前面的代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Bitmap bmp &#x3D; configuration.memoryCache.get(memoryCacheKey);</span><br><span class="line">if (bmp !&#x3D; null &amp;&amp; !bmp.isRecycled()) &#123;&#x2F;&#x2F;本地能获取到图片</span><br><span class="line">    L.d(LOG_LOAD_IMAGE_FROM_MEMORY_CACHE, memoryCacheKey);</span><br><span class="line"></span><br><span class="line">    if (options.shouldPostProcess()) &#123;</span><br><span class="line">        ---</span><br><span class="line">        &#x2F;&#x2F;缺失的代码片段1</span><br><span class="line">        ---</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        options.getDisplayer().display(bmp, imageAware, LoadedFrom.MEMORY_CACHE);</span><br><span class="line">        listener.onLoadingComplete(uri, imageAware.getWrappedView(), bmp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    ---</span><br><span class="line">    这里实现从网络上获取图片的逻辑</span><br><span class="line">     &#x2F;&#x2F;缺失的代码片段2</span><br><span class="line">    ---</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先从内存中拿出将要加载的图片（bitmap格式），然后在图片不为空且没被回收的基础上开始加载图片的逻辑。第5行中有一个判断，我们如果在<code>DisplayImageOptions</code>中设置了<code>postProcessor</code>就进入true逻辑，不过默认<code>postProcessor</code>是为null的，<code>BitmapProcessor</code>接口主要是对<code>Bitmap</code>进行处理，这个框架并没有给出相对应的实现，如果我们有自己的需求的时候可以自己实现<code>BitmapProcessor</code>接口（比如将图片设置成圆形的）。我们先分析默认情况，即<code>shouldPostProcess</code>为<code>false</code>的情况下执行的第16-17行代码。第16行代码就将<code>Bitmap</code>设置到<code>ImageView</code>上面,这里我们可以在<code>DisplayImageOptions</code>中配置显示需求<code>displayer</code>，默认使用的是<code>SimpleBitmapDisplayer</code>，直接将<code>Bitmap</code>设置到<code>ImageView</code>上面。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public final class SimpleBitmapDisplayer implements BitmapDisplayer &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void display(Bitmap bitmap, ImageAware imageAware, LoadedFrom loadedFrom) &#123;</span><br><span class="line">        imageAware.setImageBitmap(bitmap);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，ImageLoader也为我们提供了其他显示的方式，如<code>CircleBitmapDisplayer</code>（）,<code>FadeInBitmapDisplayer</code>,<code>RoundeBitmapDisplayer</code>三种显示方式。第17行代码很好理解，就是回调到<code>onLoadingComplete</code>方法，提供给用户的回调。<br>接下来我们来看当用于设置了<code>postProcessor</code>下情况的逻辑，即上面缺失的代码片段1：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ImageLoadingInfo imageLoadingInfo &#x3D; new ImageLoadingInfo(uri, imageAware, targetSize, memoryCacheKey,</span><br><span class="line">                    options, listener, progressListener, engine.getLockForUri(uri));</span><br><span class="line">            ProcessAndDisplayImageTask displayTask &#x3D; new ProcessAndDisplayImageTask(engine, bmp, imageLoadingInfo,</span><br><span class="line">                    defineHandler(options));</span><br><span class="line">            if (options.isSyncLoading()) &#123;</span><br><span class="line">                displayTask.run();</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                engine.submit(displayTask);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>这里代码执行的情况就是用于需要回调图片记载的进度时执行，即用户指定了<code>postProcessor</code>对象，而<code>postProcessor</code>主要用于表示缓存在内存之后的处理程序。<br>其中的<code>ImageLoadingInfo</code>主要用来加载和显示图片任务需要的信息，<code>ProcessAndDisplayImageTask</code>主要用于处理并显示图片的任务，他实现了<code>Runnable</code>接口。然后通过<code>isSyncLoading</code>判断是同步还是异步，当<code>isSyncLoading</code>为ture时表示当前是同步执行。这里还有一个点需要特别说明以下：我们看第1行代码中的<code>engine.getLockForUri(uri)</code>，这个方法主要是用来给图片的URl加锁的，那么给URL要传入这个一个参数给<code>ImageLoadingInfo</code>呢？其实主要是实现对图片的复用，考虑这样一种场景，在一个LitView中，某个Item正在获取图片的过程中，我们将这个item滚出界面后又将其滚进来，滚进来如果没有加锁，该item又会去加载一次图片，为了避免多次对同一个URL重复请求，有必要对正在加载的URL加锁，当图片加载完成之后，就将锁释放掉。<br>我们在来分析同步执行的情况，直接执行<code>run()</code>,通过<code>displayTask</code>任务来执行，我们来了解<code>ProcessAndDisplayImageTask</code>中<code>run()</code>方法里面的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        L.d(LOG_POSTPROCESS_IMAGE, imageLoadingInfo.memoryCacheKey);</span><br><span class="line"></span><br><span class="line">        BitmapProcessor processor &#x3D; imageLoadingInfo.options.getPostProcessor();</span><br><span class="line">        &#x2F;&#x2F;图片处理器，用于处理从磁盘缓存中读取到的图片。</span><br><span class="line">        Bitmap processedBitmap &#x3D; processor.process(bitmap);</span><br><span class="line">        &#x2F;&#x2F;处理图片</span><br><span class="line">        DisplayBitmapTask displayBitmapTask &#x3D; new DisplayBitmapTask(processedBitmap, imageLoadingInfo, engine,</span><br><span class="line">                LoadedFrom.MEMORY_CACHE);</span><br><span class="line">                &#x2F;&#x2F;构建图片实现的任务</span><br><span class="line">        LoadAndDisplayImageTask.runTask(displayBitmapTask, imageLoadingInfo.options.isSyncLoading(), handler, engine);</span><br><span class="line">                &#x2F;&#x2F;执行图片显示任务</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，在从本地读取到图片的显示逻辑还是很简单的，<code>run</code>方法核心只有四行代码，首先对图片进行相对应的处理，然后构建图片显示的任务，最后执行图片显示的任务就OK了。我们来看<code>DisplayBitmapTask</code>中具体做了什么：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">final class DisplayBitmapTask implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    private final Bitmap bitmap;</span><br><span class="line">    private final String imageUri;</span><br><span class="line">    private final ImageAware imageAware;</span><br><span class="line">    private final String memoryCacheKey;</span><br><span class="line">    private final BitmapDisplayer displayer;</span><br><span class="line">    private final ImageLoadingListener listener;</span><br><span class="line">    private final ImageLoaderEngine engine;</span><br><span class="line">    private final LoadedFrom loadedFrom;</span><br><span class="line"></span><br><span class="line">    public DisplayBitmapTask(Bitmap bitmap, ImageLoadingInfo imageLoadingInfo, ImageLoaderEngine engine,</span><br><span class="line">            LoadedFrom loadedFrom) &#123;</span><br><span class="line">        this.bitmap &#x3D; bitmap;</span><br><span class="line">        imageUri &#x3D; imageLoadingInfo.uri;</span><br><span class="line">        imageAware &#x3D; imageLoadingInfo.imageAware;</span><br><span class="line">        memoryCacheKey &#x3D; imageLoadingInfo.memoryCacheKey;</span><br><span class="line">        displayer &#x3D; imageLoadingInfo.options.getDisplayer();</span><br><span class="line">        listener &#x3D; imageLoadingInfo.listener;</span><br><span class="line">        this.engine &#x3D; engine;</span><br><span class="line">        this.loadedFrom &#x3D; loadedFrom;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        if (imageAware.isCollected()) &#123;&#x2F;&#x2F;如果要显示的图片已经被GC回收</span><br><span class="line">            &#x2F;&#x2F;回调onLoadingCancelled接口</span><br><span class="line">            listener.onLoadingCancelled(imageUri, imageAware.getWrappedView());</span><br><span class="line">        &#125; else if (isViewWasReused()) &#123;&#x2F;&#x2F;如果</span><br><span class="line">             &#x2F;&#x2F;回调onLoadingCancelled接口</span><br><span class="line">            listener.onLoadingCancelled(imageUri, imageAware.getWrappedView());</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">             &#x2F;&#x2F;正在显示图片的逻辑</span><br><span class="line">            displayer.display(bitmap, imageAware, loadedFrom);</span><br><span class="line">            engine.cancelDisplayTaskFor(imageAware);</span><br><span class="line">            listener.onLoadingComplete(imageUri, imageAware.getWrappedView(), bitmap);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;** Checks whether memory cache key (image URI) for current ImageAware is actual *&#x2F;</span><br><span class="line">    &#x2F;&#x2F;检查内存中当前图片的key是否是真实存在的</span><br><span class="line">    private boolean isViewWasReused() &#123;</span><br><span class="line">        String currentCacheKey &#x3D; engine.getLoadingUriForView(imageAware);</span><br><span class="line">        return !memoryCacheKey.equals(currentCacheKey);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面<code>run</code>方法中的逻辑也比较清晰，首先对是否能进行图片显示的环境做一定的判断，在当前环境可以显示图片的前提下，利用<code>BitmapDisplayer</code>中的<code>display</code>方法显示图片，然后通过<code>cancelDisplayTaskFor</code>方法将当前显示的图片从<code>cacheKeysForImageAwares</code>队列中移除。这里的<code>cacheKeysForImageAwares</code>指的是<code>ImageAware</code>与内存缓存<code>key</code>对应的<code>map</code>，<code>key</code> 为<code>ImageAware</code>的<code>id</code>，<code>value</code>为内存缓存的<code>key</code>。完成之后就回调<code>onLoadingComplete</code>方法。<br>但是注意到，在<code>ProcessAndDisplayImageTask</code>中，并没有直接将<code>displayBitmapTask</code>通过<code>start</code>或者是<code>run</code>方法将其执行，而是通过一个<code>LoadAndDisplayImageTask</code>中的<code>runTask</code>方法，我们来看其实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static void runTask(Runnable r, boolean sync, Handler handler, ImageLoaderEngine engine) &#123;</span><br><span class="line">    if (sync) &#123;</span><br><span class="line">        r.run();</span><br><span class="line">    &#125; else if (handler &#x3D;&#x3D; null) &#123;</span><br><span class="line">        engine.fireCallback(r);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        handler.post(r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从实现上来说，还是比较简单的。如果是同步加载的话，就直接调用<code>run</code>方法，否则（异步执行）就调用<code>handler</code>调用<code>post</code>方法将其投递到主线程中去执行，这个<code>handler</code>的实现在<code>ImageLoader</code>中。如果<code>handler</code>为空的话，就取消图片显示，直接处理善后工作。这个<code>handler</code>在<code>ImageLoader</code>中的实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private static Handler defineHandler(DisplayImageOptions options) &#123;</span><br><span class="line">    Handler handler &#x3D; options.getHandler();</span><br><span class="line">    if (options.isSyncLoading()) &#123;</span><br><span class="line">        handler &#x3D; null;</span><br><span class="line">    &#125; else if (handler &#x3D;&#x3D; null &amp;&amp; Looper.myLooper() &#x3D;&#x3D; Looper.getMainLooper()) &#123;</span><br><span class="line">        handler &#x3D; new Handler();</span><br><span class="line">    &#125;</span><br><span class="line">    return handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出来，handler的创建也只会在异步加载的时候才会创建，同步情况下不会创建handler。</p>
<h2 id="从网络上加载图片"><a href="#从网络上加载图片" class="headerlink" title="从网络上加载图片"></a>从网络上加载图片</h2><p>分析完本地加载图片后，我们来分析上面<code>displayImage</code>中缺失的代码片段2，即本地无法获取图片的图片加载逻辑，我们先来看其中的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public void displayImage(String uri, ImageAware imageAware, DisplayImageOptions options,</span><br><span class="line">            ImageSize targetSize, ImageLoadingListener listener, ImageLoadingProgressListener progressListener) &#123;</span><br><span class="line">    ...</span><br><span class="line">        Bitmap bmp &#x3D; configuration.memoryCache.get(memoryCacheKey);</span><br><span class="line">        if (bmp !&#x3D; null &amp;&amp; !bmp.isRecycled()) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F;这下面的代码就是在本地无法获取图片的情况下加载图片的逻辑</span><br><span class="line">            if (options.shouldShowImageOnLoading()) &#123;</span><br><span class="line">                imageAware.setImageDrawable(options.getImageOnLoading(configuration.resources));</span><br><span class="line">            &#125; else if (options.isResetViewBeforeLoading()) &#123;</span><br><span class="line">                imageAware.setImageDrawable(null);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ImageLoadingInfo imageLoadingInfo &#x3D; new ImageLoadingInfo(uri, imageAware, targetSize, memoryCacheKey,</span><br><span class="line">                    options, listener, progressListener, engine.getLockForUri(uri));</span><br><span class="line">            LoadAndDisplayImageTask displayTask &#x3D; new LoadAndDisplayImageTask(engine, imageLoadingInfo,</span><br><span class="line">                    defineHandler(options));</span><br><span class="line">            if (options.isSyncLoading()) &#123;</span><br><span class="line">                displayTask.run();</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                engine.submit(displayTask);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，在无法获取本地图片情况下加载图片的逻辑稍微比本地加载图片的逻辑稍微多一点，但实现上很多方法是相同的，我们一点一点来开始分析：</p>
<ol>
<li>首先利用<code>shouldShowImageOnLoading</code>方法判断在加载的过程中是否需要显示图片，当用户设置了<code>imageResOnLoading</code>占位图片资源id，或者设置了加载中占位图片drawable对象时其返回值为<code>ture</code>，即执行在图片加载过程中显示占位图片的逻辑。</li>
<li>在用户没有设置占位图片的情况下，会继续判断是否需要重设图片，若需要重设图片，就将图片设为null。</li>
<li>至于这里的<code>ImageLoadingInfo</code>(加载和显示图片任务需要的信息)和前面的实现一样，这里就不重复介绍了。</li>
<li>这里的<code>LoadAndDisplayImageTask</code>，为下载和显示图片任务，用于从网络、文件系统或者内存获取图片并解析，然后调用<code>DisplayBitmapTask</code>在<code>ImageAware</code>中显示图片。</li>
<li>在同步加载的情况下，直接运行<code>displayTask</code>。</li>
<li>异步加载的情况下，将<code>displayTask</code>提交到<code>taskDistributor</code>线程池中运行。<br>接下来，我们就具体分析<code>LoadAndDisplayImageTask</code>中的<code>run</code>方法。下面是<code>LoadAndDisplayImageTask</code>类中<code>run</code>的具体实现：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">    if (waitIfPaused()) return;</span><br><span class="line">    if (delayIfNeed()) return;</span><br><span class="line"></span><br><span class="line">    ---</span><br><span class="line">    暂时神略</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
可以看到，<code>LoadAndDisplayImageTask</code>中的<code>run()</code>方法里面的逻辑还是稍微有点复杂的。我们一点一点来分析；<br>首先看前面两个方法的实现，即3-4行的代码实现，他们在<code>LoadAndDisplayImageTask</code>类中的实现代码如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;主要用于判断当前线程是否被打断，被打断返回ture，否则返回isTaskNotActual()的返回值</span><br><span class="line">private boolean waitIfPaused() &#123;</span><br><span class="line">    AtomicBoolean pause &#x3D; engine.getPause();</span><br><span class="line">    if (pause.get()) &#123;</span><br><span class="line">        synchronized (engine.getPauseLock()) &#123;</span><br><span class="line">            if (pause.get()) &#123;</span><br><span class="line">                L.d(LOG_WAITING_FOR_RESUME, memoryCacheKey);</span><br><span class="line">                try &#123;</span><br><span class="line">                    engine.getPauseLock().wait();</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    L.e(LOG_TASK_INTERRUPTED, memoryCacheKey);</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">                L.d(LOG_RESUME_AFTER_PAUSE, memoryCacheKey);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return isTaskNotActual();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;主要用于判断是否需要预处理，不要要返回false，需要返回isTaskNotActual()的返回值</span><br><span class="line">private boolean delayIfNeed() &#123;</span><br><span class="line">    if (options.shouldDelayBeforeLoading()) &#123;</span><br><span class="line">        L.d(LOG_DELAY_BEFORE_LOADING, options.getDelayBeforeLoading(), memoryCacheKey);</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(options.getDelayBeforeLoading());</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            L.e(LOG_TASK_INTERRUPTED, memoryCacheKey);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return isTaskNotActual();</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;主要用于判断imageVire是否被回收和重用，满足其中一个条件返回ture，否则返回false</span><br><span class="line">private boolean isTaskNotActual() &#123;</span><br><span class="line">    return isViewCollected() || isViewReused();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;主要用于判断ImageView是否被GC回收了，回收了返回ture，否者返回false</span><br><span class="line">private boolean isViewCollected() &#123;</span><br><span class="line">    if (imageAware.isCollected()) &#123;</span><br><span class="line">        L.d(LOG_TASK_CANCELLED_IMAGEAWARE_COLLECTED, memoryCacheKey);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;主要用于判断imageView是否被重用，被重用返回true，否则返回false</span><br><span class="line">private boolean isViewReused() &#123;</span><br><span class="line">    String currentCacheKey &#x3D; engine.getLoadingUriForView(imageAware);</span><br><span class="line">    &#x2F;&#x2F; Check whether memory cache key (image URI) for current ImageAware is actual.</span><br><span class="line">    &#x2F;&#x2F; If ImageAware is reused for another task then current task should be cancelled.</span><br><span class="line">    boolean imageAwareWasReused &#x3D; !memoryCacheKey.equals(currentCacheKey);</span><br><span class="line">    if (imageAwareWasReused) &#123;</span><br><span class="line">        L.d(LOG_TASK_CANCELLED_IMAGEAWARE_REUSED, memoryCacheKey);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
看起来好像也有点复杂，但是并不难，我们直接一路看过去就好了。每个方法的作用我都已经在代码中添加了注释了，这里我们来整理一下思路：通过上面的源码，我们基本上可以确定他们的作用是什么了，但是为什么需要他们呢？我们试想这样一种场景，在使用ListView来显示图片时，在手指滑动的时候一般不会去加载图片，因为在这个过程中很多图片是没有必要加载的。这个时候我们就可以通过<code>PauseOnScrollListener(ImageLoader imageLoader, boolean pauseOnScroll, boolean pauseOnFling)</code>来控制在滑动过程中图片的加载。第一个参数用来控制手指按着滑动情况下的是否加载图片，第二个参数用来控制手指松开后时候加载图片。至于中间参数的参数和值的传递比较简单，这里就不全部给出来了，可以自行通过查看源码了解<code>pauseOnScroll</code>是如何改变<code>waitIfPaused</code>方法中<code>pause</code>的值的（默认为false）。<br>至于<code>isViewReused</code>的方法存在的意义就更好理解了，在ListView中存在一种复用的优化策略，即在ListView在滑动时，会复用Item，为了避免图片显示时的错位情况，在ImageLoader就通过<code>isViewReused</code>来解决这个问题。</li>
</ol>
<p>接下来我们继续看<code>LoadAndDisplayImageTask</code>中的<code>run()</code>方法中剩下的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">    ...</span><br><span class="line">    ReentrantLock loadFromUriLock &#x3D; imageLoadingInfo.loadFromUriLock;&#x2F;&#x2F;获取锁</span><br><span class="line">    L.d(LOG_START_DISPLAY_IMAGE_TASK, memoryCacheKey);</span><br><span class="line">    if (loadFromUriLock.isLocked()) &#123;   &#x2F;&#x2F;判断锁是否被持有</span><br><span class="line">        L.d(LOG_WAITING_FOR_IMAGE_LOADED, memoryCacheKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    loadFromUriLock.lock();&#x2F;加锁</span><br><span class="line">    Bitmap bmp;</span><br><span class="line">    try &#123;</span><br><span class="line">        checkTaskNotActual();&#x2F;&#x2F;判断当前请求是否是可实现的，（当imageView被GC回收或者此次请求的URL无法获取imageView时时为不可实现的请求）</span><br><span class="line"></span><br><span class="line">        bmp &#x3D; configuration.memoryCache.get(memoryCacheKey);&#x2F;&#x2F;尝试从内存中加载图片</span><br><span class="line">        if (bmp &#x3D;&#x3D; null || bmp.isRecycled()) &#123;</span><br><span class="line">            bmp &#x3D; tryLoadBitmap();&#x2F;&#x2F;尝试从文件中加载图片，如果没有再去网络中获取，然后将bitmap保存在文件系统中。</span><br><span class="line">            &#x2F;&#x2F;这个方法是重点，后面会进行讲到</span><br><span class="line">            if (bmp &#x3D;&#x3D; null) return; &#x2F;&#x2F; listener callback already was fired</span><br><span class="line"></span><br><span class="line">            checkTaskNotActual();</span><br><span class="line">            checkTaskInterrupted();&#x2F;&#x2F;用于判断当前任务有没有被打断，被打断直接抛出异常</span><br><span class="line"></span><br><span class="line">            if (options.shouldPreProcess()) &#123;&#x2F;&#x2F;默认为ture，表示缓存在内存之前没有要处理的程序</span><br><span class="line">                L.d(LOG_PREPROCESS_IMAGE, memoryCacheKey);</span><br><span class="line">                bmp &#x3D; options.getPreProcessor().process(bmp);&#x2F;&#x2F;对bitmap进行适当的剪裁</span><br><span class="line">                if (bmp &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    L.e(ERROR_PRE_PROCESSOR_NULL, memoryCacheKey);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (bmp !&#x3D; null &amp;&amp; options.isCacheInMemory()) &#123;&#x2F;&#x2F;如果有必要缓存到内存中的话</span><br><span class="line">                L.d(LOG_CACHE_IMAGE_IN_MEMORY, memoryCacheKey);</span><br><span class="line">                configuration.memoryCache.put(memoryCacheKey, bmp);&#x2F;&#x2F;将图片保存到内存缓存中去</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            loadedFrom &#x3D; LoadedFrom.MEMORY_CACHE;</span><br><span class="line">            L.d(LOG_GET_IMAGE_FROM_MEMORY_CACHE_AFTER_WAITING, memoryCacheKey);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (bmp !&#x3D; null &amp;&amp; options.shouldPostProcess()) &#123;</span><br><span class="line">            L.d(LOG_POSTPROCESS_IMAGE, memoryCacheKey);</span><br><span class="line">            bmp &#x3D; options.getPostProcessor().process(bmp);&#x2F;&#x2F;自定义的bitmap操作会在这里进行</span><br><span class="line">            if (bmp &#x3D;&#x3D; null) &#123;</span><br><span class="line">                L.e(ERROR_POST_PROCESSOR_NULL, memoryCacheKey);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        checkTaskNotActual();</span><br><span class="line">        checkTaskInterrupted();</span><br><span class="line">    &#125; catch (TaskCancelledException e) &#123;</span><br><span class="line">        fireCancelEvent(); &#x2F;&#x2F;解移除的监听 上面很多方法会抛出异常都需要这个方法来移除监听</span><br><span class="line">        return;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        loadFromUriLock.unlock();&#x2F;&#x2F;释放锁</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DisplayBitmapTask displayBitmapTask &#x3D; new DisplayBitmapTask(bmp, imageLoadingInfo, engine, loadedFrom); &#x2F;&#x2F;构建显示任务</span><br><span class="line">    runTask(displayBitmapTask, syncLoading, handler, engine);&#x2F;&#x2F;将图片显示到指定的imageView上</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码也有点多，但是在添加了先关的注解之后，详细阅读起来还是比较简单的。这里在梳理一下整个<code>LoadAndDisplayImageTask</code>中的<code>run</code>方法的相关逻辑。首先会判断当前是否是可以加载图片的状态，不可以加载图片的话就直接返回，什么都不做。在可以加载图片的前提下，会给以下的核心逻辑代码添加一个锁：【首先尝试从内存中获取图片，没有对应的图片就会从磁盘中寻找，如果磁盘中也找不到，那么就只能从网络中去需找，在找到图片后将其存在文件系统中，如果用户定义了图片的预处理，就会执行用户定义的图片预处理，如果需要缓存到内存就会缓存到内存中，继而执行用户定义的图片后处理（提前是用户定义了图片后处理），最后判断一下当前状态是否还可以显示图片，若当前状态不能显示图片就会直接抛出异常，在catch语句中移除相关的监听。如果当前状态还可以显示图片，在finally语句中释放锁 】以此保障多线程的可靠性，然后执行图片显示任务将图片显示到图片上，到此完成了整个图片的加载。用流程图表示如下：<br><img src="http://upload-images.jianshu.io/upload_images/2178834-16069ef078012739.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片加载流程"></p>
<p>下面我们来分析上面<code>run()</code>方法中最重要的一个方法<code>tryLoadBitmap（）</code>，他的实现也在<code>LoadAndDisplayImageTask</code>类中，实现代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">private Bitmap tryLoadBitmap() throws TaskCancelledException &#123;</span><br><span class="line">    Bitmap bitmap &#x3D; null;</span><br><span class="line">    try &#123;</span><br><span class="line">        File imageFile &#x3D; configuration.diskCache.get(uri);&#x2F;&#x2F;先判断文件中有没有该文件</span><br><span class="line">        if (imageFile !&#x3D; null &amp;&amp; imageFile.exists() &amp;&amp; imageFile.length() &gt; 0) &#123;&#x2F;&#x2F;如果文件中有该文件，就直接调用decodeImage去解码图片</span><br><span class="line">            L.d(LOG_LOAD_IMAGE_FROM_DISK_CACHE, memoryCacheKey);</span><br><span class="line">            loadedFrom &#x3D; LoadedFrom.DISC_CACHE;</span><br><span class="line"></span><br><span class="line">            checkTaskNotActual();&#x2F;&#x2F;判断当前是否具有加载图片的状态，这个方法在前面已经解析过了</span><br><span class="line">            bitmap &#x3D; decodeImage(Scheme.FILE.wrap(imageFile.getAbsolutePath()));&#x2F;&#x2F;解码图片</span><br><span class="line">        &#125;</span><br><span class="line">        if (bitmap &#x3D;&#x3D; null || bitmap.getWidth() &lt;&#x3D; 0 || bitmap.getHeight() &lt;&#x3D; 0) &#123;</span><br><span class="line">        &#x2F;&#x2F;表示文件中没有找到图片，就会指定到网络上获取bitmap，</span><br><span class="line">            L.d(LOG_LOAD_IMAGE_FROM_NETWORK, memoryCacheKey);</span><br><span class="line">            loadedFrom &#x3D; LoadedFrom.NETWORK;</span><br><span class="line"></span><br><span class="line">            String imageUriForDecoding &#x3D; uri;</span><br><span class="line">            if (options.isCacheOnDisk() &amp;&amp; tryCacheImageOnDisk()) &#123;</span><br><span class="line">            &#x2F;&#x2F;options.isCacheOnDisk()用来表是否需要将图片缓存到文件系统中，默认为fasle。</span><br><span class="line">                imageFile &#x3D; configuration.diskCache.get(uri);</span><br><span class="line">                if (imageFile !&#x3D; null) &#123;</span><br><span class="line">                    imageUriForDecoding &#x3D; Scheme.FILE.wrap(imageFile.getAbsolutePath());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; </span><br><span class="line"></span><br><span class="line">            checkTaskNotActual();</span><br><span class="line">            bitmap &#x3D; decodeImage(imageUriForDecoding);</span><br><span class="line"></span><br><span class="line">            if (bitmap &#x3D;&#x3D; null || bitmap.getWidth() &lt;&#x3D; 0 || bitmap.getHeight() &lt;&#x3D; 0) &#123;</span><br><span class="line">                fireFailEvent(FailType.DECODING_ERROR, null);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (IllegalStateException e) &#123;</span><br><span class="line">        fireFailEvent(FailType.NETWORK_DENIED, null);</span><br><span class="line">    &#125; catch (TaskCancelledException e) &#123;</span><br><span class="line">        throw e;</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        L.e(e);</span><br><span class="line">        fireFailEvent(FailType.IO_ERROR, e);</span><br><span class="line">    &#125; catch (OutOfMemoryError e) &#123;</span><br><span class="line">        L.e(e);</span><br><span class="line">        fireFailEvent(FailType.OUT_OF_MEMORY, e);</span><br><span class="line">    &#125; catch (Throwable e) &#123;</span><br><span class="line">        L.e(e);</span><br><span class="line">        fireFailEvent(FailType.UNKNOWN, e);</span><br><span class="line">    &#125;</span><br><span class="line">    return bitmap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码虽然看起来有点多，但是逻辑还是很清晰的，我在关键的地方都添加了注释，相信阅读起来很简单。这里再次梳理一下<code>tryLoadBitmap</code>的逻辑吧。首先从尝试从文件中去获取图片，如果能从文件中获取图片的话，就判断当前状态是否可以加载图片，然后通过<code>decodeImage</code>方法将图片解码成可以显示的格式。如果文件中没有要显示的图片，在设置了从网络获取图片的前提下就会利用<code>tryCacheImageOnDisk</code>方法从网络上获取图片，然后将图片解码成要显示的格式，可以参考下面的流程图：<br><img src="http://upload-images.jianshu.io/upload_images/2178834-96999153d13488db.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="tryLoadBitmap流程图"><br>在上面的流程中，我们对其中两个重要的方法来进一步的探究其实现，一个方法是<code>decodeImage</code>，另一个是<code>tryCacheImageOnDisk()</code>。着两个方法的实现源码如下，他们都在<code>LoadAndDisplayImageTask</code>类中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;解码图片</span><br><span class="line">private Bitmap decodeImage(String imageUri) throws IOException &#123;</span><br><span class="line">&#x2F;&#x2F;获取图片的</span><br><span class="line">    ViewScaleType viewScaleType &#x3D; imageAware.getScaleType();</span><br><span class="line">    ImageDecodingInfo decodingInfo &#x3D; new ImageDecodingInfo(memoryCacheKey, imageUri, uri, targetSize, viewScaleType,</span><br><span class="line">            getDownloader(), options);</span><br><span class="line">    return decoder.decode(decodingInfo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;** @return &lt;b&gt;true&lt;&#x2F;b&gt; - if image was downloaded successfully; &lt;b&gt;false&lt;&#x2F;b&gt; - otherwise *&#x2F;</span><br><span class="line">private boolean tryCacheImageOnDisk() throws TaskCancelledException &#123;</span><br><span class="line">    L.d(LOG_CACHE_IMAGE_ON_DISK, memoryCacheKey);</span><br><span class="line"></span><br><span class="line">    boolean loaded;</span><br><span class="line">    try &#123;</span><br><span class="line">        loaded &#x3D; downloadImage();</span><br><span class="line">        if (loaded) &#123;</span><br><span class="line">            int width &#x3D; configuration.maxImageWidthForDiskCache;</span><br><span class="line">            int height &#x3D; configuration.maxImageHeightForDiskCache;</span><br><span class="line">            if (width &gt; 0 || height &gt; 0) &#123;</span><br><span class="line">                L.d(LOG_RESIZE_CACHED_IMAGE_FILE, memoryCacheKey);</span><br><span class="line">                resizeAndSaveImage(width, height); &#x2F;&#x2F; TODO : process boolean result</span><br><span class="line">                &#x2F;&#x2F;解码成bitmap图片，并保存他。关于这个方法就不在深入了。</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        L.e(e);</span><br><span class="line">        loaded &#x3D; false;</span><br><span class="line">    &#125;</span><br><span class="line">    return loaded;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;负责下载图片，并将其保存到文件缓存中</span><br><span class="line">private boolean downloadImage() throws IOException &#123;</span><br><span class="line">    InputStream is &#x3D; getDownloader().getStream(uri, options.getExtraForDownloader());</span><br><span class="line">    if (is &#x3D;&#x3D; null) &#123;</span><br><span class="line">        L.e(ERROR_NO_IMAGE_STREAM, memoryCacheKey);</span><br><span class="line">        return false;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            return configuration.diskCache.save(uri, is, this);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            IoUtils.closeSilently(is);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里就不对上面的代码进行解释了，我们直接看<code>decode</code>方法在<code>BaseImageDecoder</code>中的具体实现，至于其他的方法，请参考注释。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Bitmap decode(ImageDecodingInfo decodingInfo) throws IOException &#123;</span><br><span class="line">    Bitmap decodedBitmap;</span><br><span class="line">    ImageFileInfo imageInfo;</span><br><span class="line"></span><br><span class="line">    InputStream imageStream &#x3D; getImageStream(decodingInfo);</span><br><span class="line">    if (imageStream &#x3D;&#x3D; null) &#123;</span><br><span class="line">        L.e(ERROR_NO_IMAGE_STREAM, decodingInfo.getImageKey());</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    try &#123;</span><br><span class="line">        imageInfo &#x3D; defineImageSizeAndRotation(imageStream, decodingInfo);</span><br><span class="line">        imageStream &#x3D; resetStream(imageStream, decodingInfo);</span><br><span class="line">        Options decodingOptions &#x3D; prepareDecodingOptions(imageInfo.imageSize, decodingInfo);</span><br><span class="line">        decodedBitmap &#x3D; BitmapFactory.decodeStream(imageStream, null, decodingOptions);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        IoUtils.closeSilently(imageStream);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (decodedBitmap &#x3D;&#x3D; null) &#123;</span><br><span class="line">        L.e(ERROR_CANT_DECODE_IMAGE, decodingInfo.getImageKey());</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        decodedBitmap &#x3D; considerExactScaleAndOrientatiton(decodedBitmap, decodingInfo, imageInfo.exif.rotation,</span><br><span class="line">                imageInfo.exif.flipHorizontal);</span><br><span class="line">    &#125;</span><br><span class="line">    return decodedBitmap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>综上，我们暂时分析完了<code>run()</code>方法中逻辑和主要方法。接下来我们继续分析异步的情况，这里再次贴出之前<code>displayImage</code>的主要流程代码。因为之前的代码隔得有点远了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public void displayImage(String uri, ImageAware imageAware, DisplayImageOptions options,</span><br><span class="line">ImageSize targetSize, ImageLoadingListener listener, ImageLoadingProgressListener progressListener) &#123;</span><br><span class="line">      ---</span><br><span class="line">Bitmap bmp &#x3D; configuration.memoryCache.get(memoryCacheKey);</span><br><span class="line">    if (bmp !&#x3D; null &amp;&amp; !bmp.isRecycled()) &#123;</span><br><span class="line">        if (options.shouldPostProcess()) &#123;</span><br><span class="line">           ...</span><br><span class="line">           if (options.isSyncLoading()) &#123;</span><br><span class="line">                displayTask.run();</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                engine.submit(displayTask);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            options.getDisplayer().display(bmp, imageAware, LoadedFrom.MEMORY_CACHE);</span><br><span class="line">            listener.onLoadingComplete(uri, imageAware.getWrappedView(), bmp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">       ...</span><br><span class="line">       缺失的代码片段2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们之前已经分析了<code>displayTask.run();</code>的主要流程，接下来我们分析异步的执行<code>engine.submit(displayTask);</code>的主要流程和方法，他的实现主要在<code>ImageLoaderEngine</code>中，<code>submit</code>的实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void submit(ProcessAndDisplayImageTask task) &#123;</span><br><span class="line">    initExecutorsIfNeed();</span><br><span class="line">    taskExecutorForCachedImages.execute(task);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法很简单，首先只有两个方法调用，第一行代码从名字分析就应该是用来初始化Executor的（有必要的话），然后执行将此次任务提交到线程池中运行。在线程池中的执行也会执行调用之前的run方法，这里就不再分析了。我们分析一下第一行代码，验证一下我们的猜想是不是正确的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private void initExecutorsIfNeed() &#123;</span><br><span class="line">    if (!configuration.customExecutor &amp;&amp; ((ExecutorService) taskExecutor).isShutdown()) &#123;</span><br><span class="line">        taskExecutor &#x3D; createTaskExecutor();</span><br><span class="line">    &#125;</span><br><span class="line">    if (!configuration.customExecutorForCachedImages &amp;&amp; ((ExecutorService) taskExecutorForCachedImages)</span><br><span class="line">            .isShutdown()) &#123;</span><br><span class="line">        taskExecutorForCachedImages &#x3D; createTaskExecutor();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面代码分析：首先判断当前的<code>taskExecutor</code>是不是关闭了，如果处于关闭状态就创建一个新<code>的Executor</code>，这里的<code>taskExecutor</code>指的是用与执行从源获取图片任务的线程池。然后判断<code>taskExecutorForCachedImages</code>是不是就绪，如果他被关闭的话就创建一个新的线程池<code>taskExecutorForCachedImages</code>，用于执行从缓存获取图片任务的线程池。综上，源码验证了我们之前的猜测，<code>initExecutorsIfNeed</code>方法的确是用来初始化相关线程池的。</p>
<h2 id="displayImage方法总结"><a href="#displayImage方法总结" class="headerlink" title="displayImage方法总结"></a>displayImage方法总结</h2><p>从上面的流程中，可以明显看出来，<code>displayImage</code>方法就是<code>imageLoader</code>加载图片的核心，我们在这里在来总结一下整个<code>displayImage</code>的逻辑，先将整个<code>displayImage</code>代码完整的贴上来：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">public void displayImage(String uri, ImageAware imageAware, DisplayImageOptions options,</span><br><span class="line">        ImageSize targetSize, ImageLoadingListener listener, ImageLoadingProgressListener progressListener) &#123;</span><br><span class="line">    checkConfiguration();</span><br><span class="line">    if (imageAware &#x3D;&#x3D; null) &#123;</span><br><span class="line">        throw new IllegalArgumentException(ERROR_WRONG_ARGUMENTS);</span><br><span class="line">    &#125;</span><br><span class="line">    if (listener &#x3D;&#x3D; null) &#123;</span><br><span class="line">        listener &#x3D; defaultListener;</span><br><span class="line">    &#125;</span><br><span class="line">    if (options &#x3D;&#x3D; null) &#123;</span><br><span class="line">        options &#x3D; configuration.defaultDisplayImageOptions;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (TextUtils.isEmpty(uri)) &#123;</span><br><span class="line">        engine.cancelDisplayTaskFor(imageAware);</span><br><span class="line">        listener.onLoadingStarted(uri, imageAware.getWrappedView());</span><br><span class="line">        if (options.shouldShowImageForEmptyUri()) &#123;</span><br><span class="line">            imageAware.setImageDrawable(options.getImageForEmptyUri(configuration.resources));</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            imageAware.setImageDrawable(null);</span><br><span class="line">        &#125;</span><br><span class="line">        listener.onLoadingComplete(uri, imageAware.getWrappedView(), null);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (targetSize &#x3D;&#x3D; null) &#123;</span><br><span class="line">        targetSize &#x3D; ImageSizeUtils.defineTargetSizeForView(imageAware, configuration.getMaxImageSize());</span><br><span class="line">    &#125;</span><br><span class="line">    String memoryCacheKey &#x3D; MemoryCacheUtils.generateKey(uri, targetSize);</span><br><span class="line">    engine.prepareDisplayTaskFor(imageAware, memoryCacheKey);</span><br><span class="line"></span><br><span class="line">    listener.onLoadingStarted(uri, imageAware.getWrappedView());</span><br><span class="line"></span><br><span class="line">    Bitmap bmp &#x3D; configuration.memoryCache.get(memoryCacheKey);</span><br><span class="line">    if (bmp !&#x3D; null &amp;&amp; !bmp.isRecycled()) &#123;</span><br><span class="line">        L.d(LOG_LOAD_IMAGE_FROM_MEMORY_CACHE, memoryCacheKey);</span><br><span class="line"></span><br><span class="line">        if (options.shouldPostProcess()) &#123;</span><br><span class="line">            ImageLoadingInfo imageLoadingInfo &#x3D; new ImageLoadingInfo(uri, imageAware, targetSize, memoryCacheKey,</span><br><span class="line">                    options, listener, progressListener, engine.getLockForUri(uri));</span><br><span class="line">            ProcessAndDisplayImageTask displayTask &#x3D; new ProcessAndDisplayImageTask(engine, bmp, imageLoadingInfo,</span><br><span class="line">                    defineHandler(options));</span><br><span class="line">            if (options.isSyncLoading()) &#123;</span><br><span class="line">                displayTask.run();</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                engine.submit(displayTask);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            options.getDisplayer().display(bmp, imageAware, LoadedFrom.MEMORY_CACHE);</span><br><span class="line">            listener.onLoadingComplete(uri, imageAware.getWrappedView(), bmp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (options.shouldShowImageOnLoading()) &#123;</span><br><span class="line">            imageAware.setImageDrawable(options.getImageOnLoading(configuration.resources));</span><br><span class="line">        &#125; else if (options.isResetViewBeforeLoading()) &#123;</span><br><span class="line">            imageAware.setImageDrawable(null);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ImageLoadingInfo imageLoadingInfo &#x3D; new ImageLoadingInfo(uri, imageAware, targetSize, memoryCacheKey,</span><br><span class="line">                options, listener, progressListener, engine.getLockForUri(uri));</span><br><span class="line">        LoadAndDisplayImageTask displayTask &#x3D; new LoadAndDisplayImageTask(engine, imageLoadingInfo,</span><br><span class="line">                defineHandler(options));</span><br><span class="line">        if (options.isSyncLoading()) &#123;</span><br><span class="line">            displayTask.run();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            engine.submit(displayTask);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将上面代码用流程图可以表示为以下的表现形式。<br><img src="http://ovec6nnof.bkt.clouddn.com/imagerLoader%E4%B8%AD%E7%9A%84dispalyer%E9%80%BB%E8%BE%91.svg" alt="displayImage"></p>
<p align="center">（原创图，敬请批评指正）</p>

<p>可以看到，在上面流程图算比较复杂，但是逻辑很清晰，基本上所有的功能集中在<code>displayImage</code>中进行调度使用，所以给我们分析<code>ImageLoader</code>降低了不少的难度。<br>至于上面流程图中没有具体体现的任务可以参考前面的分析。</p>
<p>针对上面三种显示图片的方法，最终都会通过调用<code>displayImage</code>来实现，只是对其中的参数进行了一定的设置，这里就不在详细介绍了，有兴趣的可以自己查阅源码。</p>
<h1 id="LRUCache和DisLruCacher分析"><a href="#LRUCache和DisLruCacher分析" class="headerlink" title="LRUCache和DisLruCacher分析"></a>LRUCache和DisLruCacher分析</h1><h2 id="LRUCache"><a href="#LRUCache" class="headerlink" title="LRUCache"></a>LRUCache</h2><p>LruCache是android 3.1所提供的一个缓存类，他是一个泛型类，他内部采用一个<code>LinkedHashMap</code>以强引用的方式存储外界的缓存对象，其提供了<code>get</code>和<code>put</code>方法来完成缓存的获取和添加属性，当缓存满时，LruCache会移除较早使用的缓存对象，然后在添加新的缓存对象。<br>构造方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public LruCache(int maxSize) &#123;</span><br><span class="line">       if (maxSize &lt;&#x3D; 0) &#123;</span><br><span class="line">           throw new IllegalArgumentException(&quot;maxSize &lt;&#x3D; 0&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">       this.maxSize &#x3D; maxSize;</span><br><span class="line">       this.map &#x3D; new LinkedHashMap&lt;K, V&gt;(0, 0.75f, true);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，<code>LruCache</code>的构造方法非常简单，只需要传入一个maxSize设置最大的缓存对象即可，然后实例化<code>map</code>对象。<br>这里也附上get和put的源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">public final V get(K key) &#123;</span><br><span class="line">    if (key &#x3D;&#x3D; null) &#123;</span><br><span class="line">        throw new NullPointerException(&quot;key &#x3D;&#x3D; null&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    V mapValue;</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">        mapValue &#x3D; map.get(key);</span><br><span class="line">        if (mapValue !&#x3D; null) &#123;</span><br><span class="line">            hitCount++;</span><br><span class="line">            return mapValue;</span><br><span class="line">        &#125;</span><br><span class="line">        missCount++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  V createdValue &#x3D; create(key);</span><br><span class="line">    if (createdValue &#x3D;&#x3D; null) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">        createCount++;</span><br><span class="line">        mapValue &#x3D; map.put(key, createdValue);</span><br><span class="line"></span><br><span class="line">        if (mapValue !&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F; There was a conflict so undo that last put</span><br><span class="line">            map.put(key, mapValue);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            size +&#x3D; safeSizeOf(key, createdValue);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (mapValue !&#x3D; null) &#123;</span><br><span class="line">        entryRemoved(false, key, createdValue, mapValue);</span><br><span class="line">        return mapValue;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        trimToSize(maxSize);</span><br><span class="line">        return createdValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">public final V put(K key, V value) &#123;</span><br><span class="line">    if (key &#x3D;&#x3D; null || value &#x3D;&#x3D; null) &#123;</span><br><span class="line">        throw new NullPointerException(&quot;key &#x3D;&#x3D; null || value &#x3D;&#x3D; null&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    V previous;</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">        putCount++;</span><br><span class="line">        size +&#x3D; safeSizeOf(key, value);</span><br><span class="line">        previous &#x3D; map.put(key, value);</span><br><span class="line">        if (previous !&#x3D; null) &#123;</span><br><span class="line">            size -&#x3D; safeSizeOf(key, previous);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (previous !&#x3D; null) &#123;</span><br><span class="line">        entryRemoved(false, key, previous, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    trimToSize(maxSize);</span><br><span class="line">    return previous;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更多的分析可以参考<a href="http://blog.csdn.net/xiaanming/article/details/27525741" target="_blank" rel="noopener">这里</a>。</p>
<h2 id="DisLruCache"><a href="#DisLruCache" class="headerlink" title="DisLruCache"></a>DisLruCache</h2><p>DisLruCache用于实现存储设置缓存，即磁盘缓存，他通过将缓存对象写入文件系统从而实现缓存的效果。<br>我们在这里对其创建，缓存添加和移除缓存进行简单的分析。<br>创建过程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private DiskLruCache(File directory, int appVersion, int valueCount, long maxSize) &#123;</span><br><span class="line"> ...简单的赋值，就不贴出来了</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中的四个参数分别是：</p>
<ul>
<li><code>directory</code>表示磁盘存在文件系统中的存储路径；</li>
<li><code>appVersion</code> 表示应用的版本号，一般设置1就可；</li>
<li><code>valueCount</code> 表示单个节点锁对应的数据的个数，一般设为1就可以了；</li>
<li><code>maxSize</code> 表示缓存的总大小，比如50MB，当缓存大小超过这个设置值后，DisLruCache会清除一些缓存从而保证总大小不大于这个设定值。<br>当然，<code>DiskLruCache</code>提供了<code>open</code>方法来创建自身：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public static DiskLruCache open(File directory, int appVersion, int valueCount, long maxSize)</span><br><span class="line">    throws IOException &#123;</span><br><span class="line">  if (maxSize &lt;&#x3D; 0) &#123;</span><br><span class="line">    throw new IllegalArgumentException(&quot;maxSize &lt;&#x3D; 0&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  if (valueCount &lt;&#x3D; 0) &#123;</span><br><span class="line">    throw new IllegalArgumentException(&quot;valueCount &lt;&#x3D; 0&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; If a bkp file exists, use it instead.</span><br><span class="line">  File backupFile &#x3D; new File(directory, JOURNAL_FILE_BACKUP);</span><br><span class="line">  if (backupFile.exists()) &#123;</span><br><span class="line">    File journalFile &#x3D; new File(directory, JOURNAL_FILE);</span><br><span class="line">    &#x2F;&#x2F; If journal file also exists just delete backup file.</span><br><span class="line">    if (journalFile.exists()) &#123;</span><br><span class="line">      backupFile.delete();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      renameTo(backupFile, journalFile, false);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
<li><em>DisLruCacher的缓存添加：*</em><br>DisLruCache的缓存操作通过Editor完成的，Editor表示一个缓存对象的编辑对象。在ImageLoader的运用，首先需要获取图片的URL所对用的Key，然后根据Key就可以通过<code>edit()</code>方法来获取Editor对象，如果这个缓存正在被编辑，那么edit会返回null，即DisLrucache不允许同时编辑一个缓存对象。之所以要把url转换成key，是因为url中可能有特殊字符，这将影响url在Adnroid中的直接使用，一般采用url的md5值作为key。</li>
</ul>
<p><strong>DisLruCacher的缓存查找：</strong><br>缓存查找过程也需要将url转换成key，然后通过<code>DisLrache</code>的get方法得到一个<code>snapshot</code>对象即可得到缓存的文件输入流，进而得到Bitmap对象。为了避免加载图片过程中导致的OOM问题，一般建议不直接加载原始图片，建议先对图片进行压缩之后在去加载。下面是<code>get</code>方法的实现逻辑：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public synchronized Value get(String key) throws IOException &#123;</span><br><span class="line">   checkNotClosed();</span><br><span class="line">   Entry entry &#x3D; lruEntries.get(key);</span><br><span class="line">   if (entry &#x3D;&#x3D; null) &#123;</span><br><span class="line">     return null;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   if (!entry.readable) &#123;</span><br><span class="line">     return null;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   for (File file : entry.cleanFiles) &#123;</span><br><span class="line">       &#x2F;&#x2F; A file must have been deleted manually!</span><br><span class="line">       if (!file.exists()) &#123;</span><br><span class="line">           return null;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   redundantOpCount++;</span><br><span class="line">   journalWriter.append(READ);</span><br><span class="line">   journalWriter.append(&#39; &#39;);</span><br><span class="line">   journalWriter.append(key);</span><br><span class="line">   journalWriter.append(&#39;\n&#39;);</span><br><span class="line">   if (journalRebuildRequired()) &#123;</span><br><span class="line">     executorService.submit(cleanupCallable);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   return new Value(key, entry.sequenceNumber, entry.cleanFiles, entry.lengths);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p><strong>DisLruCacher的缓存删除：</strong><br><code>DisLruCacher</code>提供了<code>remove</code>,<code>delete</code>方法来进行磁盘的删除操作。删除通过需要将url转换成key，然后从<code>lruEntries</code>的<code>LinkedHashMap</code>对象中获取该对象，在对象存在的前提下，删除文件中对应的文件，然后移除<code>lruEntries</code>对应的key值。代码实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public synchronized boolean remove(String key) throws IOException &#123;</span><br><span class="line">   checkNotClosed();</span><br><span class="line">   Entry entry &#x3D; lruEntries.get(key);</span><br><span class="line">   if (entry &#x3D;&#x3D; null || entry.currentEditor !&#x3D; null) &#123;</span><br><span class="line">     return false;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   for (int i &#x3D; 0; i &lt; valueCount; i++) &#123;</span><br><span class="line">     File file &#x3D; entry.getCleanFile(i);</span><br><span class="line">     if (file.exists() &amp;&amp; !file.delete()) &#123;</span><br><span class="line">       throw new IOException(&quot;failed to delete &quot; + file);</span><br><span class="line">     &#125;</span><br><span class="line">     size -&#x3D; entry.lengths[i];</span><br><span class="line">     entry.lengths[i] &#x3D; 0;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   redundantOpCount++;</span><br><span class="line">   journalWriter.append(REMOVE);</span><br><span class="line">   journalWriter.append(&#39; &#39;);</span><br><span class="line">   journalWriter.append(key);</span><br><span class="line">   journalWriter.append(&#39;\n&#39;);</span><br><span class="line"></span><br><span class="line">   lruEntries.remove(key);</span><br><span class="line"></span><br><span class="line">   if (journalRebuildRequired()) &#123;</span><br><span class="line">     executorService.submit(cleanupCallable);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   return true;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h1 id="杂谈"><a href="#杂谈" class="headerlink" title="杂谈"></a>杂谈</h1><p>下面是我对<code>imageLoader</code>源码分析之后的一些感悟和一些总结，有一些还是面试时被问到的问题，这里一并记录下来。</p>
<h2 id="ImageLoader运用的设计模式"><a href="#ImageLoader运用的设计模式" class="headerlink" title="ImageLoader运用的设计模式"></a>ImageLoader运用的设计模式</h2><p>从源码分析上来看，最明显的就是建造者模式和单例模式，这两种模式在实际项目中也是运行最广的设计模式。还使用了工厂模式，装饰者模式，代理模式，策略模式等等。<a href="https://github.com/mingjunli/JavaDesignPatterns" target="_blank" rel="noopener">设计模式参考</a></p>
<h2 id="当ListView显示图片，滚动时ImageLoader是如何避免OOM的？"><a href="#当ListView显示图片，滚动时ImageLoader是如何避免OOM的？" class="headerlink" title="当ListView显示图片，滚动时ImageLoader是如何避免OOM的？"></a>当ListView显示图片，滚动时ImageLoader是如何避免OOM的？</h2><p>首先是对缓存进行管理，具体管理内存的方法是LruCache，实现算法是LRU：通过优先淘汰最近最少使用的缓存对象，保证总缓存大小不高于限定值。</p>
<h2 id="LRUCacher算法的具体实现"><a href="#LRUCacher算法的具体实现" class="headerlink" title="LRUCacher算法的具体实现"></a>LRUCacher算法的具体实现</h2><p>他内部采用一个LinkedhashMap以强引用的方式存储外界的缓存对象，其提供了get和put方法来完成缓存的获取和添加操作，当缓存满时，LRUcacher会移除较早使用的缓存对象，然后再添加新的缓存对象。</p>
<h2 id="ImagerLoader的为什么会被淘汰"><a href="#ImagerLoader的为什么会被淘汰" class="headerlink" title="ImagerLoader的为什么会被淘汰"></a>ImagerLoader的为什么会被淘汰</h2><ul>
<li>首先相对于Gilde来说，ImagerLoader的配置相对繁琐，需要对其中的参数有比较详细的了解才能比较好的驾驭ImageLoader，而Gilde简单易用，没有繁琐复杂的配置；</li>
<li>Gilde中的内存管理比ImageLoader做的更好，虽然ImageLoader也说有三层缓存，但是实际上是两层，一个磁盘，一个内存缓存。而Gilde中的内存管理做到了两级内存缓存，更加可靠；</li>
<li>在网络请求方面，ImageLoader采用的是HttpConnection，而Gilde默认采用更加高效的okhttp，虽然两者都支持自定义下载器，但是明显Gilde的支持更好。</li>
</ul>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul>
<li><a href="https://github.com/nostra13/Android-Universal-Image-Loader" target="_blank" rel="noopener">官方github</a></li>
<li><a href="http://a.codekk.com/detail/Android/huxian99/Android%20Universal%20Image%20Loader%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90" target="_blank" rel="noopener">Android Universal Image Loader 源码分析</a></li>
<li><a href="http://blog.csdn.net/xiaanming/article/details/26810303" target="_blank" rel="noopener">universal-imager-Loader完全解析</a></li>
<li>《android开发艺术探索》</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://reoger.tk/2017/08/30/%E6%96%87%E6%A1%A3%E6%9F%A5%E7%9C%8B%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="reoger">
      <meta itemprop="description" content="reoger">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="reoger的记录">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/08/30/%E6%96%87%E6%A1%A3%E6%9F%A5%E7%9C%8B%E5%99%A8/" class="post-title-link" itemprop="url">文档查看器</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2017-08-30 12:52:40 / 修改时间：12:55:00" itemprop="dateCreated datePublished" datetime="2017-08-30T12:52:40+08:00">2017-08-30</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="原型参考界面"><a href="#原型参考界面" class="headerlink" title="原型参考界面"></a>原型参考界面</h2><iframe src="https://modao.cc/app/N1EtppyLzE5qVlcEzY1FvdEvE65lYLn/embed" width="488" height="900" allowTransparency="true" frameborder="0"></iframe>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://reoger.tk/2017/08/28/android%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="reoger">
      <meta itemprop="description" content="reoger">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="reoger的记录">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/08/28/android%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/" class="post-title-link" itemprop="url">android面试准备</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-08-28 13:35:40" itemprop="dateCreated datePublished" datetime="2017-08-28T13:35:40+08:00">2017-08-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-12 22:55:47" itemprop="dateModified" datetime="2020-04-12T22:55:47+08:00">2020-04-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">面试</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="android四大组件"><a href="#android四大组件" class="headerlink" title="android四大组件"></a>android四大组件</h1><h2 id="activity的生命周期"><a href="#activity的生命周期" class="headerlink" title="activity的生命周期"></a>activity的生命周期</h2><p><img src="https://gss1.bdstatic.com/9vo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike92%2C5%2C5%2C92%2C30/sign=c070b79dcb177f3e0439f45f11a650a2/1c950a7b02087bf41b6972c2f0d3572c11dfcf17.jpg" alt="activity的生命周期图"></p>
<h2 id="activity的四种启动模式"><a href="#activity的四种启动模式" class="headerlink" title="activity的四种启动模式"></a>activity的四种启动模式</h2><p>Standard（默认）、singleTop（栈顶复用）、singleTask（栈内复用）、singleInstance（单实例）。<br>当然，不但可以通过在AndroidManifest.xml中声明launchMode，也可以通过指定Activity的Flags来设置启动模式。例如：<br>FLAG_ACTIVITY_NEW_TASK 相当于singleTask模式；<br>FLAG_ACTIVITY_SINGLE_TOP 相当于singleTop模式；<br>FLAG_ACTIVITY_CLEAR_TOP 标记的activity在同一个任务栈中所有位于它上面的activity都要出栈；<br>FLAY_ACTIVITY_EXCLUDE_FROM_RECENTS 标记的activity不会出现在历史的activity列表中。</p>
<h2 id="activity的四种状态"><a href="#activity的四种状态" class="headerlink" title="activity的四种状态"></a>activity的四种状态</h2><p>runing、paused、stopped、kille</p>
<h2 id="activity的启动方式"><a href="#activity的启动方式" class="headerlink" title="activity的启动方式"></a>activity的启动方式</h2><p>显式和隐式启动。其中隐式启动的匹配规则：<br>intentFilter中过滤信息有action、category、data。<br>Intent中的action能够和过滤规则中的任何一个action相同即可；<br>Intent中所有的category都必须和过滤过则中的某一个category相同；<br>Intent中的data能够和过滤规则中的任何一个data相同即可。<br>在隐式启动的时候，可以用packageManager的resolveActivity或者Activity的resolveActivity方法先判断是否有activity相匹配，避免异常发生。</p>
<h2 id="activity的启动流程"><a href="#activity的启动流程" class="headerlink" title="activity的启动流程"></a>activity的启动流程</h2><p>参考<a href="http://blog.csdn.net/singwhatiwanna/article/details/18154335" target="_blank" rel="noopener">这里</a></p>
<h2 id="activity异常停止时保存数据的方法"><a href="#activity异常停止时保存数据的方法" class="headerlink" title="activity异常停止时保存数据的方法"></a>activity异常停止时保存数据的方法</h2><p>可以在onSaveInstanceState（在onStop之前被调用）中将要保存的数据保存起来，可以通过Bundle进行临时保存，然后在onCreate中的bundle中取出来进行恢复，但是oncreate中进行数据恢复要注意判空，也可以在onRestoreInstanceState（）取出数据进行恢复（这里就不要判空，因为只要回调这个方法就一定不为空）。<a href="http://blog.csdn.net/reoger/article/details/51354658" target="_blank" rel="noopener">参考。</a></p>
<h2 id="Activity、Windows、View三者的区别和联系。"><a href="#Activity、Windows、View三者的区别和联系。" class="headerlink" title="Activity、Windows、View三者的区别和联系。"></a>Activity、Windows、View三者的区别和联系。</h2><p>Activity是控制单元，通过attach方法创建window对象；window是承载模型，负责承载视图；view是要显示的视图，必须依附于window；<br>Window是一个抽象类，他的具体实现是phoneWindow，Android中所有的视图都是通过window来呈现的，不管是activity、Dialog还是Toast，他们的视图实际上都是附加在window上的，因为window实际是view的直接管理者。<br>最后总结一句话：activity像一个工匠（控制单元），window向窗户（承载模型），View像窗花（显示视图）。</p>
<h2 id="activity间通过Intent传递数据的大小限制"><a href="#activity间通过Intent传递数据的大小限制" class="headerlink" title="activity间通过Intent传递数据的大小限制"></a>activity间通过Intent传递数据的大小限制</h2><p>肯定是有限制的，大约大1m（1020k）左右。但是官方并没有给出说明。 </p>
<h2 id="Fragment的生命周期"><a href="#Fragment的生命周期" class="headerlink" title="Fragment的生命周期"></a>Fragment的生命周期</h2><p><img src="http://img.my.csdn.net/uploads/201211/29/1354170699_6619.png" alt="fragment生命周期图"></p>
<h2 id="添加fragment的步骤。"><a href="#添加fragment的步骤。" class="headerlink" title="添加fragment的步骤。"></a>添加fragment的步骤。</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;步骤1、创建待添加的的fragment实例</span><br><span class="line">MyFragment m &#x3D; new MyFragment();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;步骤2、开始一个事务</span><br><span class="line">FragmentManager fragmentManager &#x3D; getFragmentManager(); &#x2F;&#x2F;获取fragment对象</span><br><span class="line">FragmentTransaction fragmentTransaction &#x3D; fragmentManager.beginTransaction(); &#x2F;&#x2F;利用fragment开启事务</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;步骤3、向容器内加入碎片,可以通过add或者replace方法实现。</span><br><span class="line">fragmentTransaction.add(R.id.fragment, m);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;步骤4、提交事务</span><br><span class="line">fragmentTransaction.commit();</span><br></pre></td></tr></table></figure>

<h2 id="添加Fragment时方法"><a href="#添加Fragment时方法" class="headerlink" title="添加Fragment时方法"></a>添加Fragment时方法</h2><p>一般有两种方法添加碎片，即通过replace和add方法，下面是两种方法的区别：<br>通过add方法添加的fragment，每个fragment都只能添加一次。因此如果想达到切换的效果需要通过fragment的hide和show方法结合使用。将要显示的show出来，将其他hide起来，这个过程fragment生命周期没有变化。<br>通过replace方法添加fragment，每个fragmnet可以添加任意次，因为每一次添加都会先将之前的fragmemnt移除，然后在添加。因此切换fragment，每次都会执行上一和fragment的onDstoryView，新的Fragemnt的onCreateView、onStart、onResume方法。</p>
<h2 id="Activity和Fragment之间的区别。"><a href="#Activity和Fragment之间的区别。" class="headerlink" title="Activity和Fragment之间的区别。"></a>Activity和Fragment之间的区别。</h2><p>1．  Fragment显得更加灵活，可以在xml文件中添加<fragment>，动态的替换一部分界面，activity则不行；<br>2．  Fragment不需要在manfest中申明，而activity需要。</p>
<h2 id="Activity与Fragment通信方案。"><a href="#Activity与Fragment通信方案。" class="headerlink" title="Activity与Fragment通信方案。"></a>Activity与Fragment通信方案。</h2><ol>
<li>handler：该方案存在的缺点：<br>Fragment对具体的Activity存在耦合，不利于Fragment复用<br>不利于维护，若想删除相应的Activity，Fragment也得改动<br>没法获取Activity的返回数据</li>
<li>广播方案，缺点：<br>用广播解决此问题有点大材小用了，个人感觉广播的意图是用在一对多，接收广播者是未知的情况<br>广播性能肯定会差<br>传播数据有限制（必须得实现序列化接口才可以）</li>
<li>EventBus方案：<br>EventBus是用反射机制实现的，性能上会有问题<br>EventBus难于维护代码<br>没法获取Activity的返回数据</li>
<li>接口方案<br>假如项目很大了，Activity与Fragment的数量也会增加</li>
</ol>
<h2 id="Service的生命周期。"><a href="#Service的生命周期。" class="headerlink" title="Service的生命周期。"></a>Service的生命周期。</h2><p>Service的生命周期分为两种，一种是直接利用startCommand启动，另一种是通过bindService来启动。具体如图所示。值得注意的是，在已经启动的service，我们重新启动的时候，不会执行onCreate方法，而是直接执行onStartCommand方法。<br><img src="https://developer.android.google.cn/images/service_lifecycle.png" alt="服务生命周期"><br>左图显示了使用 startService() 所创建的服务的生命周期，右图显示了使用 bindService() 所创建的服务的生命周期。</p>
<h2 id="Service和Thread的区别"><a href="#Service和Thread的区别" class="headerlink" title="Service和Thread的区别"></a>Service和Thread的区别</h2><p>Service是安卓中系统的组件，它运行在独立进程的主线程中，不可以执行耗时操作。Thread是程序执行的最小单元，分配CPU的基本单位，可以开启子线程执行耗时操作;<br>Service在不同Activity中可以获取自身实例，可以方便的对Service进行操作。Thread在不同的Activity中难以获取自身实例，如果Activity被销毁，Thread实例就很难再获取得到。</p>
<h2 id="Broadcast-Receiver的种类"><a href="#Broadcast-Receiver的种类" class="headerlink" title="Broadcast Receiver的种类"></a>Broadcast Receiver的种类</h2><ul>
<li>普通广播</li>
<li>有序广播</li>
<li>本地广播</li>
<li>Sticky广播</li>
</ul>
<h2 id="注册广播有几种方式？他们有什么区别？"><a href="#注册广播有几种方式？他们有什么区别？" class="headerlink" title="注册广播有几种方式？他们有什么区别？"></a>注册广播有几种方式？他们有什么区别？</h2><p>广播注册分为静态注册和动态注册，其中的静态注册的广播在应用安装时由系统自动完成注册，具体来说是由PMS来完成整个注册过程。<br>静态注册属于常驻型广播，也就是说当应用程序关闭后，如果有信息广播来，程序也会被系统调用自动运行（在android 3.1以后就可能不成立了，加入了一个<a href="http://www.jianshu.com/p/92ccb8ca2ea5" target="_blank" rel="noopener">flag位</a>）。动态注册不是常驻型广播，也就是说广播跟随程序的生命周期。</p>
<h2 id="Broadcast-Receiver实现机制"><a href="#Broadcast-Receiver实现机制" class="headerlink" title="Broadcast Receiver实现机制"></a>Broadcast Receiver实现机制</h2><ol>
<li>自定义广播类继承BroadcastReceiver，复写onReceiver()</li>
<li>通过Binder机制向AMS进行注册广播</li>
<li>广播发送者通过Binder机制向AMS发送广播</li>
<li>AMS查找符合相应条件的广播发送到BroadcastReceiver相应的循环队列中<br>消息队列执行拿到广播，回调BroadcastReceiver的onReceiver()</li>
</ol>
<h2 id="LocalBroadcastManager特点"><a href="#LocalBroadcastManager特点" class="headerlink" title="LocalBroadcastManager特点"></a>LocalBroadcastManager特点</h2><ul>
<li>本地广播只能在自身App内传播，不必担心泄漏隐私数据</li>
<li>本地广播不允许其他App对你的App发送该广播，不必担心安全漏洞被利用</li>
<li>本地广播比全局广播更高效</li>
<li>以上三点都是源于其内部是用Handler实现的</li>
</ul>
<h2 id="ContentProvider是如何实现数据共享的。"><a href="#ContentProvider是如何实现数据共享的。" class="headerlink" title="ContentProvider是如何实现数据共享的。"></a>ContentProvider是如何实现数据共享的。</h2><p>在android中如果想就将自己应用的数据（一般多位数据库中的数据）提供给第三方应用，那么我们只能通过ContentPrivider来实现。<br>ContentProvider是应用程序之间共享的接口，使用的时候首先自定义一个类继承ContentProvider，然后覆写query、insert、update、delete等方法，因为其是四大组件之一，因此必须在AndroidManifest文件中进行注册，把自己的数据通过uri的形式共享出去。第三方可以通过ContentResplver来访问该Provider。</p>
<h2 id="Application的生命周期？"><a href="#Application的生命周期？" class="headerlink" title="Application的生命周期？"></a>Application的生命周期？</h2><p>onCreate() –&gt; 创建application  –&gt; onTerminate() –&gt; 结束。<br>其中，在application中，可能会回调<code>onConfigurationChanged()</code>（在设备配置发生改变的时候调用）、<code>onLowMemory()</code>（手机内存低时调用））、<code>OnTrimMemory()</code>（在操作系统清理内存的时候时候调用）。</p>
<h1 id="View相关面试题"><a href="#View相关面试题" class="headerlink" title="View相关面试题"></a>View相关面试题</h1><h2 id="简述View的事件分发机制。"><a href="#简述View的事件分发机制。" class="headerlink" title="简述View的事件分发机制。"></a>简述View的事件分发机制。</h2><p>当一个点击事件产生后，他的传递过程应该是：Activity –&gt; windos –&gt; View;<br>顶级View接到事件后，就会按照事件分发机制去分发事件，具体如下图所示。<br>值得注意的是，ViewGroup默认不拦截任何事件，而子View中没有OnIntercepterTouchEvent方法，一旦有事件传递给他，那么他的onTouchEvent就会马上调用。某个View一旦决定拦截事件，那么这一个事件序列都只能由他来处理。<br>简单来说：点击事件分发过程如下 dispatchTouchEvent—-&gt;OnTouchListener的onTouch方法—-&gt;onTouchEvent–&gt;OnClickListener的onClick方法。也就是说，我们平时调用的setOnClickListener，优先级是最低的，所以，onTouchEvent或OnTouchListener的onTouch方法如果返回true，则不响应onClick方法。<br><img src="./img/view%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6.png" alt="Touch事件传递机制流程图"></p>
<h2 id="view测量的宽-高和实际上的宽-高是一样的吗？"><a href="#view测量的宽-高和实际上的宽-高是一样的吗？" class="headerlink" title="view测量的宽/高和实际上的宽/高是一样的吗？"></a>view测量的宽/高和实际上的宽/高是一样的吗？</h2><p>不一定一样，虽然在大部分情况下是一样的，但是在某些情况下会导致两者的值不相同。<br>在View的默认实现中，View的测量宽/高和最终的宽/高是相等的，只不过测量宽/高形成于measure过程，而最终宽/高形成与View的layout过程，即两者的赋值时机不同，测量宽/高的赋值时机要稍微早一点。当我们重写layout方法时，可以导致测量的宽/高和实际的宽/高不同（虽然没有什么具体的含义，但是证明了view测量的宽/高和实际的宽/高是可以不相同的）。</p>
<h2 id="在activity启动的时候就需要获取某个View的宽-高，该怎么做？"><a href="#在activity启动的时候就需要获取某个View的宽-高，该怎么做？" class="headerlink" title="在activity启动的时候就需要获取某个View的宽/高，该怎么做？"></a>在activity启动的时候就需要获取某个View的宽/高，该怎么做？</h2><p>注意，我们一定不能在onCreate、onStart、onResume中去获取。因为View的measure过程和Activity的生命周期方法不是同步的执行的，因此无法保证Activity在某个生命周期方法中这个View已经测量完毕了。<br>我们可以在onWindowFocusChanged方法中获取；我们也可以通过view.post(runnable)将runnable投递到消息队列的尾部，然后等待Looper调用此runnable获取View的高和宽；我们也可以使用ViewTreeObserver的众多回调来获取View的高，例如使用onGlodalLayoutListener这个接口。最后，我们当然也可以手动对view进行measure来得到View的宽/高。</p>
<h2 id="自定义View要注意哪些地方？"><a href="#自定义View要注意哪些地方？" class="headerlink" title="自定义View要注意哪些地方？"></a>自定义View要注意哪些地方？</h2><p>让view支持wrap_content；<br>直接继承View或者ViewGroup的控件，如果不在onMeasure中对wrap_content做特殊的处理，那么当外界在布局中使用wrap_content时就无法达到预期的效果。<br>让view支持padding和margin；<br>直接继承view的话，如果不在draw方法中处理paddding，那么padding属性是无法起作用的。另外，直接继承ViewGroup的控件需要在onMeasure和onLayout中考虑padding、<br>和子元素margin对其造成的影响，不然将会导致这两个属性失效。<br>  尽量不要在View中使用handler，view中如果有线程或者动画，一定要及时停止，否则可能会造成内存泄露；<br>  View带有滑动嵌套的时候，要注意处理滑动冲突。</p>
<h2 id="自定义view的步骤。"><a href="#自定义view的步骤。" class="headerlink" title="自定义view的步骤。"></a>自定义view的步骤。</h2><p>简单来说，主要有三大步骤：</p>
<ul>
<li>onMeasure</li>
<li>onLayout</li>
<li>onDraw<br>具体详细，可以参考<a href="http://blog.csdn.net/qq_30379689/article/details/54588736" target="_blank" rel="noopener">博客</a></li>
</ul>
<h1 id="动画相关"><a href="#动画相关" class="headerlink" title="动画相关"></a>动画相关</h1><h2 id="Android中的三种动画。"><a href="#Android中的三种动画。" class="headerlink" title="Android中的三种动画。"></a>Android中的三种动画。</h2><p>Android中的动画有三种：View动画、帧动画和属性动画。<br> View动画的作用对象是View，他支持4中动画效果：分别是平移动画（TranslateAnimation）、缩放动画（ScaleAnimation）、旋转动画（RotateAnimation）和透明度动画（AlphaAnimation）。<br>帧动画是顺序播放一组预先定义好的图片，类似于电影播放。<br>属性动画是在API 11新加入的特性，属性动画可以对任何对象做动画，甚至可以没有对象。除了动画对象进行了扩展以外，属性动画的动画效果也进行了加强，不像View动画只支持四种动画。</p>
<h2 id="可以对任意属性做动画吗？"><a href="#可以对任意属性做动画吗？" class="headerlink" title="可以对任意属性做动画吗？"></a>可以对任意属性做动画吗？</h2><p>可以。如果想对Object的属性abd做动画，如果想让动画生效，要同时满足两个条件：<br>object必须要提供setAbd方法，如果动画的时候没有传递初始值，那么还要提供getAbd方法，因为系统要去取abd属性的初始值（如果这个条件不满足，程序直接Crash）；<br>object的setAbd对属性adc所做的改变必须能够通过某种方法反映出来，比如会带来UI的改变之类的（如果这条不满足，动画无效果但不会Crash）。<br>针对上面的两个条件，google官方告诉我们三种解决方案：<br>给你的对象加上get和set方法，如果有权限的话；<br>用一个类来包装原始对象，间接为其提供get和set方法；<br>采用ValueAnimator，监听动画过程，自己实现属性的改变。</p>
<h2 id="使用动画的注意事项。"><a href="#使用动画的注意事项。" class="headerlink" title="使用动画的注意事项。"></a>使用动画的注意事项。</h2><p>在开发的过程中尽量少用帧动画，避免OOM；<br>在activity退出时及时停止动画，避免内存泄露；<br>在android3.0以下的系统中使用属性动画需做好适配工作；<br>在view动画中，view只是对view的影像做动画，并没有真正的改变view的状态；<br>使用动画的时候，建议开启硬件加速（在声明文件中添加android:hardwareAccelerated=”true”属性即可），提高动画的流畅性。</p>
<h2 id="怎么为activity设置切换效果，怎么给ViewGroup子元素添加子元素的出场动画？"><a href="#怎么为activity设置切换效果，怎么给ViewGroup子元素添加子元素的出场动画？" class="headerlink" title="怎么为activity设置切换效果，怎么给ViewGroup子元素添加子元素的出场动画？"></a>怎么为activity设置切换效果，怎么给ViewGroup子元素添加子元素的出场动画？</h2><p>Activity有默认的切换效果，但是这个效果我们可以自定义的，主要用到overriderPendingTransition()这个方法，这个方法必须在startActivity或者finish()之后调用才能生效。至于Fragment的切换效果，我们可以通过setCustormAnimation方法来添加切换动画。<br>至于在ViewGroup中为子元素出场添加动画，可以在xml中对布局的LayoutAnimation引用相应的动画资源文件即可，或者我们也可以在java中利用LayoutAnimationController将获取到的动画资源文件设置到viewGroup中即可。</p>
<h2 id="动画中的差值器和估值器怎么理解？"><a href="#动画中的差值器和估值器怎么理解？" class="headerlink" title="动画中的差值器和估值器怎么理解？"></a>动画中的差值器和估值器怎么理解？</h2><p>时间插值器（TimeInterpolator）的作用是根据时间流逝的百分比来计算出当前属性值改变的百分比，系统预置的有LinearInterpolator（线性插值器：匀速动画），<br>AccelerateDecelerateInterpolator（加速减速插值器：动画两头慢中间快），<br>DecelerateInterpolator(减速插值器：动画越来越慢）。<br>估值器（TypeEvaluator）的作用是根据当前属性改变的百分比来计算改变后的属性值。系统预置有IntEvaluator 、FloatEvaluator 、ArgbEvaluator。<br>具体来说 对于一个作用在view上改变其宽度属性、持续40ms的属性动画来说，就是当时间t=20ms时，时间流逝了50%，那么view的宽度属性应该改变了多少呢？这个就由Interpolator和Evaluator的算法来决定。</p>
<h2 id="滑动冲突是如何产生的，该如何避免？"><a href="#滑动冲突是如何产生的，该如何避免？" class="headerlink" title="滑动冲突是如何产生的，该如何避免？"></a>滑动冲突是如何产生的，该如何避免？</h2><p>在界面中只有有内外两层同时可以滑动，这个时候就产生了滑动冲突。例如，scrollView嵌套一个listView，因为listView和scrollView都是可以滑动的，这个时候就出现了滑动冲突。<br>常见的解决滑动冲突的方法有两种：外部拦截和内部拦截。<br>外部拦截法是指点击事件都先经过父容器的拦截处理（ACTION_DOWN不能被消耗），如果父容器需要此事件就拦截，如果不需要此事件就不拦截，这样就可以解决滑动冲突问题，这种方法比较符合点击事件的分发机制。外部拦截法需要重写父容器中的onIntercepetTouchEvent方法，在内部做相应的拦截即可。<br>外部拦截法是指父容器不拦截任何事件，所有的事件都传递给子元素，如果子元素需要此事件就直接消耗掉，否则就交给父容器进行处理，这种方法和Android分发机制不一致，需要配合requetDisallowInterceptTounchEvent方法才能正常工作，使用起来较外部拦截法稍显复杂。</p>
<h1 id="通信机制"><a href="#通信机制" class="headerlink" title="通信机制"></a>通信机制</h1><h2 id="IPC指什么？android中实现IPC有哪些"><a href="#IPC指什么？android中实现IPC有哪些" class="headerlink" title="IPC指什么？android中实现IPC有哪些"></a>IPC指什么？android中实现IPC有哪些</h2><p>IPC(Inter-Process Communication)，含义为进程间通信或者跨进程通信，是指两个进程之间进行数据交换的过程。<br>Android中主要通过Bundler(用于android四大组键间的进程间通信)、文件共享、AIDL、Messenger、ContentProvider和Socket来进行进程间通信。</p>
<h2 id="Binder指什么？"><a href="#Binder指什么？" class="headerlink" title="Binder指什么？"></a>Binder指什么？</h2><p>直观的说，binder是android中的一个类，他实现了IBinder接口。从IPC角度来说，Binder是Android中的一种跨进程通信方式；从android应用层来说，Binder是客户端和服务端进行通信的媒介，当bindService的时候，服务端会返回一个包含了服务端业务调用的Binder对象，通过这个Binder对象，客户端就可以获取服务端提供的服务或者数据，这里的服务包括普通服务和基于AIDL的服务。</p>
<h2 id="Binder机制"><a href="#Binder机制" class="headerlink" title="Binder机制"></a>Binder机制</h2><p>参考<a href="http://www.mamicode.com/info-detail-1513074.html" target="_blank" rel="noopener">这里</a>.</p>
<h2 id="进程间通信中可以使用sharedPreferences吗？"><a href="#进程间通信中可以使用sharedPreferences吗？" class="headerlink" title="进程间通信中可以使用sharedPreferences吗？"></a>进程间通信中可以使用sharedPreferences吗？</h2><p>不能。虽然从本质上来将，sharedPreferences也属于文件的一种，但是由于喜用对他的读/写有一定的缓存策略，即在内存中会有一份sharedPreferences文件的缓存，因此在多进程模式下，系统对他的读/写就变得不可靠，当面对高并发的读/写访问，sharedPreferences有很大的几率会丢失数据，因此，不建议在进程间中使用sharedPreferences。</p>
<h2 id="AIDL支持的数据类型有哪些？"><a href="#AIDL支持的数据类型有哪些？" class="headerlink" title="AIDL支持的数据类型有哪些？"></a>AIDL支持的数据类型有哪些？</h2><p>除short以外的基本数据类型（int、long、char、boolean、double等）;<br>String和CharSequence;<br>ArrayList、HashMap：里面的每个元素都必须被AIDL支持。<br>Parcelable： 所有实现了Parcelable接口的对象。<br>AIDL： 所有的AIDL接口本身也可以在AIDL文件中使用。</p>
<h2 id="handler原理"><a href="#handler原理" class="headerlink" title="handler原理"></a>handler原理</h2><p> Handler创建的时会采用当前线程Looper来构建内部的消息循环系统，如果当前线程没有Looper，那么就会报错。Handler创建完毕后，这个时候其内部的Looper以及MessageQueue就可以和Handler一起协同工作了，然后通过Handler的post方法将一个Runnable投递到Handler内部的Looper去处理，也可以通过Handler的send方法发送一个消息，这个消息同样会在Looper中去处理。其实post方法最终也是通过send方法完成的。Send方法被调用时，MessageQueue的enqueueMessage方法将这个消息放入消息队列中，然后Looper发现有新消息到来时，就会处理这个消息，最终消息中的Runnable或者Handler的handlerMessage方法就会被调用。注意，Looper是运行在创建Handler所在的线程中，这样依赖Handler中的业务逻辑就被切换到创建Handler所在的线程去执行了。<br><img src="http://ovec6nnof.bkt.clouddn.com/hanlder.png" alt="handler原理"></p>
<h2 id="AsyncTask的工作原理。"><a href="#AsyncTask的工作原理。" class="headerlink" title="AsyncTask的工作原理。"></a>AsyncTask的工作原理。</h2><p> AsyncTask是对Thread和Handler的组合包装，方便我们在后台线程中执行操作，然后将结构发送给主线程，从而在主线程中进行UI更新等操作。<br>  实现原理，AsyncTask中有两个线程和一个Handler，其中一个线程池（SerialExecuor）用于任务的排队，另一个线程池（THREAD_POOL_EXECUTOR）用于真正的执行任务。InternalHandler用于将要执行的环境从线程池切换到主线程。关于AsynchTask有以下几点需要注意：AsyncTask的对象必须在主线程中创建；execute方法必须在UI线程中调用；一个axyncTask对象只能执行一次，即执行一次execute方法；在android 1.6之前AsyncTask是串行执行任务的，而在android 1.6的时候开始采用线程池里处理并行任务，但在android 3.0以后，为了避免并发错误，asyncTask又采用了一个线程来穿行执行任务，同时也提供一个串行执行任务的方法executeOnExecutor方法。</p>
<h2 id="HandlerThread是什么？简述原理并举出一个应用的例子。"><a href="#HandlerThread是什么？简述原理并举出一个应用的例子。" class="headerlink" title="HandlerThread是什么？简述原理并举出一个应用的例子。"></a>HandlerThread是什么？简述原理并举出一个应用的例子。</h2><p>HandlerThread是一种可以使用Handler的Thread。他的实现也很简单，就是在run方法中通过Looper.prepare()来创建消息队列，并通过Looper.loop()来开启消息循环，这样在实际的使用中就允许在HandlerThread中创建Handler了。<br>HandlerThread在Android中的一个具体的使用场景是IntentService。IntentService封装了HandlerThread和Handler。</p>
<h2 id="IntentService使用和原理。"><a href="#IntentService使用和原理。" class="headerlink" title="IntentService使用和原理。"></a>IntentService使用和原理。</h2><p>IntentService是一种特殊的Service，他继承了Service并且他是一个抽象类，因此必须创建他的子类才能使用IntentService。IntentService可用于执行后台耗时的任务，当任务执行后他会自动停止，同时由于IntentService是服务的原因，这导致他的优先级比单纯的线程要高很多，所以IntentService比较适合执行一些高优先级的后台任务。<br>原理上来说，IntentService封装了Handler和Handler。在onCreate方法中创建一个HadnlerThread，然后使用它的Looper来构建一个Handler对象mServicehandler,这样通过mServiceHandler发送的消息最终都会在HandlerThread中执行。而在OnStart方法中，IntentService仅仅只是通过mServiceHandler发送了一个消息，这个消息会在HandlerThread中被处理。</p>
<h1 id="android中的线程与线程池"><a href="#android中的线程与线程池" class="headerlink" title="android中的线程与线程池"></a>android中的线程与线程池</h1><h2 id="Android中的线程池有什么优点？"><a href="#Android中的线程池有什么优点？" class="headerlink" title="Android中的线程池有什么优点？"></a>Android中的线程池有什么优点？</h2><p>可以重用线程池中的线程，避免因为线程的创建和销毁所带来的性能开销；<br>能有效控制线程池的最大并发数，避免大量的线程之间因互相抢夺资源而导致的阻塞现象；<br>能够对线程进行简单的管理，并提供定时执行已经指定间隔循环执行等功能。<br><a href="http://blog.csdn.net/Reoger/article/details/77145627" target="_blank" rel="noopener">ThreadPoolExecutor</a>是线程池的真正实现。</p>
<h1 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h1><h2 id="什么是ANR，产生的条件有那些"><a href="#什么是ANR，产生的条件有那些" class="headerlink" title="什么是ANR，产生的条件有那些"></a>什么是ANR，产生的条件有那些</h2><p>ANR即Application not responding，应用程序无响应。<br>产生条件：在Ui线程中5s无响应，在broadcastReceiver中10s无相应，或者在service中20s无相应都会导致ANR。<br>解决方法：运行在主线程里的任何方法都尽可能少做事情，耗时的操作应该放在子线程中进行操作，然后通过hander或者其他方法来通知主线程。<br>应用程序应该避免在broadcastReceiver里做耗时的操作或者计算，代替的是，如果想用Internt广播需要执行一个耗时的动作的话，应用程序应该启动一个servicer。</p>
<h2 id="造成ANR的主要原因"><a href="#造成ANR的主要原因" class="headerlink" title="造成ANR的主要原因"></a>造成ANR的主要原因</h2><p>主线程被IO操作阻塞</p>
<ul>
<li>Activity的所有生命周期回调都是执行在主线程的</li>
<li>Service默认执行在主线程中</li>
<li>BoardcastReceiver的回调onReceive()执行在主线程中</li>
<li>AsyncTask的回调除了doInBackground，其他都是在主线程中<br>没有使用子线程Looper的Handler的handlerMessage，post(Runnable)都是执行在主线程中</li>
</ul>
<h2 id="OOM指什么？什么时候会出现OOM。"><a href="#OOM指什么？什么时候会出现OOM。" class="headerlink" title="OOM指什么？什么时候会出现OOM。"></a>OOM指什么？什么时候会出现OOM。</h2><p>OOM指Out of memory（内存溢出），当前占用内存加上我们申请的内存资源超过了Dalvik虚拟机的最大内存限制就会抛出Out of memory异常<br>出现OOM的大部分情况都是内存泄露引起的、也有可能是操作系统本身内存就不足了。<br>这里只介绍内存泄露。</p>
<h2 id="内存泄露出现与避免"><a href="#内存泄露出现与避免" class="headerlink" title="内存泄露出现与避免"></a>内存泄露出现与避免</h2><p>总的来说，出现内存泄露的原因是本来应该被GC回收的资源，因为某种原因不能被回收，而导致内存越来越小，进而导致内存泄露，最终可能会导致OOM。<br>  出现内存泄露一般来自于两个原因：没有即使释放分配的内存（Cursor没有及时关闭）；<br>当应用不再需要这个对象，却没有释放该对象的所有引用。<br>检测内存泄露可以通过android studio的monitors工具，生成hprof文件，我们可以通过分析这个文件来分析内存泄露。当然，在android studio中分析内存泄露不是很直观，专业一点的工具就是MAT，我们可以将我们得到的hporf文件导入到MAT中进行分析。<br>当然，我们也可以通过在android项目中使用leakCanary来检测内存泄露。当应用程序出现内存泄露的时候，leakCanary会在通知栏通知我们，而且会提示我们内存泄露的相关信息，可以让我们迅速定给到内存泄露的的位置和原因。</p>
<h2 id="具体说明什么时候出现内存泄露"><a href="#具体说明什么时候出现内存泄露" class="headerlink" title="具体说明什么时候出现内存泄露"></a>具体说明什么时候出现内存泄露</h2><ol>
<li>Static 变量没有及时清空<br>但在类中定义了静态的Activity变量，把当前运行的Activity实例赋值给给这个静态常量。如果这个静态变量在activity的生命周期结束后没有清空，即会导致内存泄露；</li>
<li>注册了没有及时解注册<br>如动态注册中，如果我们在activity中注册了广播，在activity销毁之前就应该解注册，否则就会出现内存泄露；</li>
<li>资源或者属性动画没有及时关闭<br>在一类属性动画中，可以无线循环播放，如果在activity中播放此类动画且在activity生命周期中没有停止动画，那么动画会一直播放下去，尽管我们已经看不到效果了。至于资源回收典型的例子就是数据的Cursor了，当操作完数据库没有及时关闭Cursor也可能会导致内存泄露；</li>
<li>静态类或者内部类导致的内存泄露<br>这类导致的内存泄露究其原因也是因为static变量没有及时回收，这里不做介绍；</li>
<li>Handler或者AsyncTask导致的内存泄露<br>我们试想一种情况，在我们的activity结束之后，handler又给Ui线程发送了一个消息，或者是在activity结束之后，我们的AsynchTask任务才执行完。这两种情况都会导致activity实例无法被回收，导致内存泄露。</li>
</ol>
<h2 id="如何处理应用可能存在的crash"><a href="#如何处理应用可能存在的crash" class="headerlink" title="如何处理应用可能存在的crash"></a>如何处理应用可能存在的crash</h2><p>一般实现Thread类中UncaughtExceptionHandler对象，在发生崩溃时，系统会调用UncaughtExceptionHandler的uncaughtException方法，在uncaughtException方法中可以捕获到异常信息，可以选择把异常信息存储到SD卡中，然后在合适的时机通过网络将crash信息上传到服务器，这样就可以分析crash的原因了。当然，在crash发生时，我们可以先弹出一个对话框告诉用户crash了，然后在退出。</p>
<h1 id="新技术"><a href="#新技术" class="headerlink" title="新技术"></a>新技术</h1><h2 id="kotlin语言的优势"><a href="#kotlin语言的优势" class="headerlink" title="kotlin语言的优势"></a>kotlin语言的优势</h2><ul>
<li>简洁性<br>例如在<code>kotlin</code>中的数据类会自动获得所需的<code>getter、setters、toString</code>。</li>
<li>安全性<br>对象不能为空，避免出现空指针异常。</li>
<li>更优雅，遵循Effective Java设计</li>
</ul>
<ol>
<li>类默认不可继承</li>
<li>更有效的使用构建器模式</li>
<li>默认提供单利模版</li>
<li>重载必须使用<code>Override</code></li>
</ol>
<ul>
<li>完全兼容Java</li>
</ul>
<h1 id="开源库源码解析"><a href="#开源库源码解析" class="headerlink" title="开源库源码解析"></a>开源库源码解析</h1><h2 id="gile相关问题"><a href="#gile相关问题" class="headerlink" title="gile相关问题"></a><strong>gile相关问题</strong></h2><h2 id="如何使用OkHttp进行异步网络请求，并根据请求结果刷新UI"><a href="#如何使用OkHttp进行异步网络请求，并根据请求结果刷新UI" class="headerlink" title="如何使用OkHttp进行异步网络请求，并根据请求结果刷新UI"></a>如何使用OkHttp进行异步网络请求，并根据请求结果刷新UI</h2><p>##介绍一下OkHttp的整个异步请求流程<br>  前面两个问题都比较简单，具体可以参考<a href="http://reoger.tk/categories/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/">博客</a>中的解答。</p>
<p>##OkHttp对于网络请求都有哪些优化，如何实现的</p>
<h2 id="OkHttp框架中都用到了哪些设计模式"><a href="#OkHttp框架中都用到了哪些设计模式" class="headerlink" title="OkHttp框架中都用到了哪些设计模式"></a>OkHttp框架中都用到了哪些设计模式</h2><p>建造者模式、</p>
<h2 id="Okhttp的优势与劣势"><a href="#Okhttp的优势与劣势" class="headerlink" title="Okhttp的优势与劣势"></a>Okhttp的优势与劣势</h2><p>Android 开发中是可以直接使用现成的api进行网络请求的。是Square公司开源的针对Java和Android程序，封装的一个高性能http请求库，它的职责跟HttpUrlConnection 是一样的，支持同步、异步，而且 OkHttp 又封装了线程池，封装了数据转换，封装了参数使用、错误处理等，api使用起来更加方便。可以把它理解成是一个封装之后的类似HttpUrlConnection的东西，但是在使用的时候仍然需要自己再做一层封装，这样才能像使用一个框架一样更加顺手。</p>
<h2 id="Volley-VS-OkHttp"><a href="#Volley-VS-OkHttp" class="headerlink" title="Volley VS OkHttp"></a>Volley VS OkHttp</h2><p>volley不支持Post大数据，所以不适合上传文件。<br>okhttp支持同步、异步，封装了线程池，参数使用、错误处理等。<br>volley封装的扩展性强，支持HttpClient、HttpUrlConnection， 甚至支持OkHttp，而且Volley里面也封装了ImageLoader。<br>Okhttp基于NIO和OKio，所以性能上要比Volley更快，功能更加齐全，只是使用需要进一步的封装。</p>
<hr>
<h2 id="Gilde相关问题"><a href="#Gilde相关问题" class="headerlink" title="Gilde相关问题"></a><strong>Gilde相关问题</strong></h2><h1 id="更多的android面试资料"><a href="#更多的android面试资料" class="headerlink" title="更多的android面试资料"></a>更多的android面试资料</h1><ul>
<li><a href="https://github.com/GeniusVJR/LearningNotes" target="_blank" rel="noopener">https://github.com/GeniusVJR/LearningNotes</a></li>
<li><a href="https://github.com/Reoger/android-interview-questions-cn" target="_blank" rel="noopener">https://github.com/Reoger/android-interview-questions-cn</a></li>
<li><a href="http://www.jianshu.com/p/13786463635d" target="_blank" rel="noopener">http://www.jianshu.com/p/13786463635d</a></li>
<li><a href="https://mp.weixin.qq.com/s/bvB2U0-6ZJ1j06iVV4NmjQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/bvB2U0-6ZJ1j06iVV4NmjQ</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://reoger.tk/2017/08/19/gilde%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="reoger">
      <meta itemprop="description" content="reoger">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="reoger的记录">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/08/19/gilde%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/" class="post-title-link" itemprop="url">glide原理解读</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-08-19 18:50:00" itemprop="dateCreated datePublished" datetime="2017-08-19T18:50:00+08:00">2017-08-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-12 22:57:22" itemprop="dateModified" datetime="2020-04-12T22:57:22+08:00">2020-04-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/" itemprop="url" rel="index"><span itemprop="name">源码解读</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>glide是一个快速，高效的开源媒体管理和Android的图像加载框架，将媒体解码，内存，磁盘缓存和资源池封装成一个简单易于使用的接口。</p>
</blockquote>
<p>相对于同为图片加载的ImageLoader、Picasso来说，他支持的图片格式更加齐全（包括video、GIF、SVG等），支持缩略请求，内存管理也更加优秀。所以现在对其源码进行一个比较简单的分析。</p>
<h1 id="源码导入"><a href="#源码导入" class="headerlink" title="源码导入"></a>源码导入</h1><p>本次源码解析均基于<code>3.7.0</code>的版本。在<code>build.gradle</code>中添加如下的依赖：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compile &#39;com.github.bumptech.glide:glide:3.7.0&#39;</span><br></pre></td></tr></table></figure>
<p>点击同步，然后我们就可以开始我们的源码解析之旅了。<br>如果想看更多的版本信息，可以去他的<a href="https://github.com/bumptech/glide" target="_blank" rel="noopener">github主页</a>进行查看选择。</p>
<h1 id="简单使用示例"><a href="#简单使用示例" class="headerlink" title="简单使用示例"></a>简单使用示例</h1><p>相信使用过gilde来加载图片，对于gilde的使用都很清楚吧。下面是加载一张图片到ImageView中的关键代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ImageView imageView &#x3D; (ImageView) findViewById(R.id.imageView);</span><br><span class="line">Glide.with(this).load(R.mipmap.ic_launcher).into(imageView);</span><br></pre></td></tr></table></figure>
<p>  下面我就上面的简单的使用进行源码分析。</p>
<h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Glide.with(this).load(R.mipmap.ic_launcher).into(imageView);</span><br></pre></td></tr></table></figure>

<h2 id="总体设计图"><a href="#总体设计图" class="headerlink" title="总体设计图"></a>总体设计图</h2><p><img src="http://ovec6nnof.bkt.clouddn.com/19-11-17.jpg" alt="资料来源网络"><br><a algin="center" >资料来源于网络</a></p>
<h2 id="Glide-with"><a href="#Glide-with" class="headerlink" title="Glide.with()"></a>Glide.with()</h2><p>我们首先来看Glide中的第一步，with方法的实现。源码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public static RequestManager with(Context context) &#123;</span><br><span class="line">        RequestManagerRetriever retriever &#x3D; RequestManagerRetriever.get();</span><br><span class="line">        return retriever.get(context);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">public static RequestManager with(Activity activity) &#123;</span><br><span class="line">        RequestManagerRetriever retriever &#x3D; RequestManagerRetriever.get();</span><br><span class="line">        return retriever.get(activity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">public static RequestManager with(FragmentActivity activity) &#123;</span><br><span class="line">        RequestManagerRetriever retriever &#x3D; RequestManagerRetriever.get();</span><br><span class="line">        return retriever.get(activity);</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">@TargetApi(Build.VERSION_CODES.HONEYCOMB)</span><br><span class="line">public static RequestManager with(android.app.Fragment fragment) &#123;</span><br><span class="line">        RequestManagerRetriever retriever &#x3D; RequestManagerRetriever.get();</span><br><span class="line">        return retriever.get(fragment);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"> public static RequestManager with(Fragment fragment) &#123;</span><br><span class="line">        RequestManagerRetriever retriever &#x3D; RequestManagerRetriever.get();</span><br><span class="line">        return retriever.get(fragment);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，with有很多中重载，我们可以在with中传入Context，Activity、Fragment等等参数。但是在这些重载方法中，实现的逻辑大都差不多，首先是构建一个RequestManagerRetriever对象，然后调用get方法。那么我们先来看看RequestManagerRetriever.get();构建出来的对象的作用是什么。<br>继续看源码<code>RequestManagerRetriever.get()</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;** The singleton instance of RequestManagerRetriever. *&#x2F;</span><br><span class="line">private static final RequestManagerRetriever INSTANCE &#x3D; new RequestManagerRetriever();</span><br><span class="line"></span><br><span class="line">public static RequestManagerRetriever get() &#123;</span><br><span class="line">    return INSTANCE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Visible for testing.</span><br><span class="line">RequestManagerRetriever() &#123;</span><br><span class="line">    handler &#x3D; new Handler(Looper.getMainLooper(), this &#x2F;* Callback *&#x2F;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过上面的源码我们可以看到，<code>RequestManagerRetriever.get()</code>返回的就是一个静态的RequestManagerRetriever对象，这个对象初始化的时候就是只是创建了一个Handler。那么这个Handler什么时候触发，我们后面在讲。<br>我们注意到在<code>with()</code>方法中，我们最后返回的是<code>retriever.get(activity)</code>或者<code>retriever.get(fragment)</code>，具体实现如下代码所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public RequestManager get(FragmentActivity activity) &#123;</span><br><span class="line">    if (Util.isOnBackgroundThread()) &#123;&#x2F;&#x2F;如果是在后台线程</span><br><span class="line">        return get(activity.getApplicationContext());</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        assertNotDestroyed(activity);</span><br><span class="line">        FragmentManager fm &#x3D; activity.getSupportFragmentManager();</span><br><span class="line">        return supportFragmentGet(activity, fm);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public RequestManager get(Context context) &#123;</span><br><span class="line">    if (context &#x3D;&#x3D; null) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;You cannot start a load on a null Context&quot;);</span><br><span class="line">    &#125; else if (Util.isOnMainThread() &amp;&amp; !(context instanceof Application)) &#123;</span><br><span class="line">        if (context instanceof FragmentActivity) &#123;</span><br><span class="line">            return get((FragmentActivity) context);</span><br><span class="line">        &#125; else if (context instanceof Activity) &#123;</span><br><span class="line">            return get((Activity) context);</span><br><span class="line">        &#125; else if (context instanceof ContextWrapper) &#123;</span><br><span class="line">            return get(((ContextWrapper) context).getBaseContext());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return getApplicationManager(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以发现，如果当前是在后台线程的话，get()方法会返回一个<code>get(activity.getApplicationContext())</code>。我们继续来看<code>getApplicationManager(context)</code>的实现逻辑：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">private RequestManager getApplicationManager(Context context) &#123;</span><br><span class="line">    &#x2F;&#x2F; Either an application context or we&#39;re on a background thread.</span><br><span class="line">    if (applicationManager &#x3D;&#x3D; null) &#123;</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            if (applicationManager &#x3D;&#x3D; null) &#123;</span><br><span class="line">                &#x2F;&#x2F; Normally pause&#x2F;resume is taken care of by the fragment we add to the fragment or activity.</span><br><span class="line">                &#x2F;&#x2F; However, in this case since the manager attached to the application will not receive lifecycle</span><br><span class="line">                &#x2F;&#x2F; events, we must force the manager to start resumed using ApplicationLifecycle.</span><br><span class="line">                applicationManager &#x3D; new RequestManager(context.getApplicationContext(),</span><br><span class="line">                        new ApplicationLifecycle(), new EmptyRequestManagerTreeNode());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return applicationManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，getApplicationManager方法通过使用双重锁的单例模式通过<code>RequestManager</code>来实例化一个<code>applicationManager</code>,并将当作返回值。关于这个<code>applicationManager</code>我们稍后在做讨论。<br>在当前线程不是在主线程时，而且在<code>get()</code>方法中传入的不是Application对象时，会根据传入的对象来调用<code>RequestManagerRetriever</code>中重载的<code>get()</code>方法。<br>以传入的对象是Activity为例子，那么调用的就是<code>get((Activity) context)</code>，下面是该方法的实现逻辑：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">@TargetApi(Build.VERSION_CODES.HONEYCOMB)</span><br><span class="line">public RequestManager get(Activity activity) &#123;</span><br><span class="line">    if (Util.isOnBackgroundThread() || Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.HONEYCOMB) &#123;</span><br><span class="line">        return get(activity.getApplicationContext());</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        assertNotDestroyed(activity);&#x2F;&#x2F;判断activity是否已经销毁了</span><br><span class="line">        android.app.FragmentManager fm &#x3D; activity.getFragmentManager();</span><br><span class="line">        return fragmentGet(activity, fm);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@TargetApi(Build.VERSION_CODES.HONEYCOMB)</span><br><span class="line">RequestManager fragmentGet(Context context, android.app.FragmentManager fm) &#123;</span><br><span class="line">    RequestManagerFragment current &#x3D; getRequestManagerFragment(fm);</span><br><span class="line">    RequestManager requestManager &#x3D; current.getRequestManager();</span><br><span class="line">    if (requestManager &#x3D;&#x3D; null) &#123;</span><br><span class="line">        requestManager &#x3D; new RequestManager(context, current.getLifecycle(), current.getRequestManagerTreeNode());</span><br><span class="line">        current.setRequestManager(requestManager);</span><br><span class="line">    &#125;</span><br><span class="line">    return requestManager;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1)</span><br><span class="line">RequestManagerFragment getRequestManagerFragment(final android.app.FragmentManager fm) &#123;</span><br><span class="line">    RequestManagerFragment current &#x3D; (RequestManagerFragment) fm.findFragmentByTag(FRAGMENT_TAG);</span><br><span class="line">    if (current &#x3D;&#x3D; null) &#123;</span><br><span class="line">        current &#x3D; pendingRequestManagerFragments.get(fm);</span><br><span class="line">        if (current &#x3D;&#x3D; null) &#123;</span><br><span class="line">            current &#x3D; new RequestManagerFragment();</span><br><span class="line">            pendingRequestManagerFragments.put(fm, current);</span><br><span class="line">            fm.beginTransaction().add(current, FRAGMENT_TAG).commitAllowingStateLoss();</span><br><span class="line">            handler.obtainMessage(ID_REMOVE_FRAGMENT_MANAGER, fm).sendToTarget();</span><br><span class="line">            &#x2F;&#x2F;这里handler发送了一个消息，这里就是handler发送消息的时机</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return current;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;这里就是handler回调的时机，主要用于移除容器中的对象。</span><br><span class="line">@Override</span><br><span class="line">public boolean handleMessage(Message message) &#123;</span><br><span class="line">    boolean handled &#x3D; true;</span><br><span class="line">    Object removed &#x3D; null;</span><br><span class="line">    Object key &#x3D; null;</span><br><span class="line">    switch (message.what) &#123;</span><br><span class="line">        case ID_REMOVE_FRAGMENT_MANAGER:</span><br><span class="line">            android.app.FragmentManager fm &#x3D; (android.app.FragmentManager) message.obj;</span><br><span class="line">            key &#x3D; fm;</span><br><span class="line">            removed &#x3D; pendingRequestManagerFragments.remove(fm);</span><br><span class="line">            break;</span><br><span class="line">        case ID_REMOVE_SUPPORT_FRAGMENT_MANAGER:</span><br><span class="line">            FragmentManager supportFm &#x3D; (FragmentManager) message.obj;</span><br><span class="line">            key &#x3D; supportFm;</span><br><span class="line">            removed &#x3D; pendingSupportRequestManagerFragments.remove(supportFm);</span><br><span class="line">            break;</span><br><span class="line">        default:</span><br><span class="line">            handled &#x3D; false;</span><br><span class="line">    &#125;</span><br><span class="line">    if (handled &amp;&amp; removed &#x3D;&#x3D; null &amp;&amp; Log.isLoggable(TAG, Log.WARN)) &#123;</span><br><span class="line">        Log.w(TAG, &quot;Failed to remove expected request manager fragment, manager: &quot; + key);</span><br><span class="line">    &#125;</span><br><span class="line">    return handled;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总的来说，这里逻辑还是比较简单。首先在<code>get()</code>方法中，判断是否在后台线程且判断以下当前的版本。如果不是在后台线程且当前版本低于11，那么就会先判断当前activity是否销毁了，然后调用<code>ragmentGet(activity, fm)</code>方法。在<code>ragmentGet(activity, fm)</code>方法中，首先会调用<code>getRequestManagerFragment(fm)</code>来创建<code>RequestManagerFragment</code>对象，在<code>getRequestManagerFragment</code>方法中，首先创建一个<code>RequestManagerFragment</code>，然后将该对象放入到一个名为<code>pendingRequestManagerFragments的hashMap</code>对象中，然后通过<code>handler</code>发送一个消息。<br>在<code>handleMessage</code>中，收到这个消息之后，就会将<code>RequestManagerFragment</code>从<code>pendingRequestManagerFragments的hashMap</code>中移除。</p>
<p>这里有没有想这么一个问题，为什么要存在<code>pendingRequestManagerFragments</code>这么一个容器呢？当我们创建一个<code>RequestManagerFragment</code>之后，马上将其添加到<code>pendingRequestManagerFragments</code>中，然后运行<code>commitAllowingStateLoss</code>方法之后，又马上通过<code>Handler</code>发送一个消息让其从<code>pendingRequestManagerFragments</code>容器中移除，竟然如此，那何不如直接new一个<code>RequestManagerFragment</code>，然后直接提交就好了，何必用这个容器呢？以我的理解，这个<code>gilde</code>开发者为了增加gilde的可靠性而设计的，梳理第25-36行的逻辑如下：首先通过<code>findFragmentByTag</code>来查找<code>RequestManagerFragment</code>，若其返回空，继续下面的逻辑，否则直接返回找到的<code>RequestManagerFragment</code>对象。在<code>findFragmentByTag</code>返回空的情况下，会继续用<code>get()</code>方法来从容器中查找<code>RequestManagerFragment</code>对象，如果还是空就重新创建一个<code>RequestManagerFragment</code>，并将其添加到<code>pendingRequestManagerFragments</code>容器中,然后执行<code>commitAllowingStateLoss</code>方法，随后通过handler发送消息将<code>pendingRequestManagerFragments</code>容器中的该条记录移除。那么为什么要用<code>pendingRequestManagerFragments</code>呢？道理很简单，避免快速多次调用<code>getRequestManagerFragment</code>时，重复创建<code>RequestManagerFragment</code>对象。试想一下，当我们运行完第30行的时候，第二个<code>getRequestManagerFragment</code>请求已经到了，这个时候，第二个请求需要的<code>RequestManagerFragment</code>，就可以通过<code>get()</code>方法获取，而不要去重新创建。当运行完第31行时，第二个<code>getRequestManagerFragment</code>就可以直接通过<code>findFragmentByTag</code>方法获取。这种情况是可能产生的，设想这样一种情况：当我们在Activity A和B都同时有<code>Gilde.with()</code>,我们在进入activity A后秒切ACtivity B就可能会导致上面所说的情况，只是可能性比较低，但毕竟是可能的，所以<code>gilde</code>开发团队就用了一个容器来存储当前的<code>RequestManagerFragment</code>对象，进一步提高其性能。<br>关于<code>commitAllowingStateLoss</code>方法，这里我们不做详细的讨论，具体可参考<a href="https://jucongyuan.com/2015/02/25/%E4%BB%8E%E6%BA%90%E7%A0%81%E7%9C%8Bcommit%E5%92%8CcommitAllowingStateLoss%E6%96%B9%E6%B3%95%E5%8C%BA%E5%88%AB/" target="_blank" rel="noopener">这里</a>。<br>然后在<code>fragmentGet</code>方法中也会调用<code>RequestManager</code>方法。似曾相识是吧，没错，我们在<code>getApplicationManager</code>方法中也调用了这个方法！！那么下面来看看这个方法究竟做了写什么吧。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">public RequestManager(Context context, Lifecycle lifecycle, RequestManagerTreeNode treeNode) &#123;</span><br><span class="line">    this(context, lifecycle, treeNode, new RequestTracker(), new ConnectivityMonitorFactory());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">RequestManager(Context context, final Lifecycle lifecycle, RequestManagerTreeNode treeNode,</span><br><span class="line">        RequestTracker requestTracker, ConnectivityMonitorFactory factory) &#123;</span><br><span class="line">    this.context &#x3D; context.getApplicationContext();</span><br><span class="line">    this.lifecycle &#x3D; lifecycle;</span><br><span class="line">    this.treeNode &#x3D; treeNode;</span><br><span class="line">    this.requestTracker &#x3D; requestTracker;</span><br><span class="line">    this.glide &#x3D; Glide.get(context); &#x2F;&#x2F;创建一个Glide对象</span><br><span class="line">    this.optionsApplier &#x3D; new OptionsApplier();</span><br><span class="line"></span><br><span class="line">    ConnectivityMonitor connectivityMonitor &#x3D; factory.build(context,</span><br><span class="line">            new RequestManagerConnectivityListener(requestTracker));</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; If we&#39;re the application level request manager, we may be created on a background thread. In that case we</span><br><span class="line">    &#x2F;&#x2F; cannot risk synchronously pausing or resuming requests, so we hack around the issue by delaying adding</span><br><span class="line">    &#x2F;&#x2F; ourselves as a lifecycle listener by posting to the main thread. This should be entirely safe.</span><br><span class="line">    if (Util.isOnBackgroundThread()) &#123;</span><br><span class="line">        new Handler(Looper.getMainLooper()).post(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                lifecycle.addListener(RequestManager.this);&#x2F;&#x2F;将生命周期进行绑定</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        lifecycle.addListener(this);&#x2F;&#x2F;绑定生命周期</span><br><span class="line">    &#125;</span><br><span class="line">    lifecycle.addListener(connectivityMonitor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;单例模式创建Gilde对象</span><br><span class="line"> public static Glide get(Context context) &#123;</span><br><span class="line">        if (glide &#x3D;&#x3D; null) &#123;</span><br><span class="line">            synchronized (Glide.class) &#123;</span><br><span class="line">                if (glide &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    Context applicationContext &#x3D; context.getApplicationContext();</span><br><span class="line">                    List&lt;GlideModule&gt; modules &#x3D; new ManifestParser(applicationContext).parse();</span><br><span class="line"></span><br><span class="line">                    GlideBuilder builder &#x3D; new GlideBuilder(applicationContext);</span><br><span class="line">                    for (GlideModule module : modules) &#123;</span><br><span class="line">                        module.applyOptions(applicationContext, builder);</span><br><span class="line">                    &#125;</span><br><span class="line">                    glide &#x3D; builder.createGlide();</span><br><span class="line">                    for (GlideModule module : modules) &#123;</span><br><span class="line">                        module.registerComponents(applicationContext, glide);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return glide;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;在这里进行一系列的初始化，    </span><br><span class="line"> Glide createGlide() &#123;</span><br><span class="line">        if (sourceService &#x3D;&#x3D; null) &#123;</span><br><span class="line">            final int cores &#x3D; Math.max(1, Runtime.getRuntime().availableProcessors());</span><br><span class="line">            sourceService &#x3D; new FifoPriorityThreadPoolExecutor(cores);</span><br><span class="line">        &#125;</span><br><span class="line">        if (diskCacheService &#x3D;&#x3D; null) &#123;</span><br><span class="line">            diskCacheService &#x3D; new FifoPriorityThreadPoolExecutor(1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        MemorySizeCalculator calculator &#x3D; new MemorySizeCalculator(context);</span><br><span class="line">        if (bitmapPool &#x3D;&#x3D; null) &#123;</span><br><span class="line">            if (Build.VERSION.SDK_INT &gt;&#x3D; Build.VERSION_CODES.HONEYCOMB) &#123;</span><br><span class="line">                int size &#x3D; calculator.getBitmapPoolSize();</span><br><span class="line">                bitmapPool &#x3D; new LruBitmapPool(size);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                bitmapPool &#x3D; new BitmapPoolAdapter();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (memoryCache &#x3D;&#x3D; null) &#123;</span><br><span class="line">            memoryCache &#x3D; new LruResourceCache(calculator.getMemoryCacheSize());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (diskCacheFactory &#x3D;&#x3D; null) &#123;</span><br><span class="line">            diskCacheFactory &#x3D; new InternalCacheDiskCacheFactory(context);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (engine &#x3D;&#x3D; null) &#123;</span><br><span class="line">            engine &#x3D; new Engine(memoryCache, diskCacheFactory, diskCacheService, sourceService);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (decodeFormat &#x3D;&#x3D; null) &#123;</span><br><span class="line">            decodeFormat &#x3D; DecodeFormat.DEFAULT;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return new Glide(engine, memoryCache, bitmapPool, context, decodeFormat);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>不难看出，在<code>RequestManager</code>构造方法中，对生命周期进行了绑定，并绑定了监听。然后通过<code>Glide.get(context);</code>创建一个Gilde对象，在<code>Glide.get(）</code>方法中，<br>这里<code>createGlide</code>方法中，我们通过<code>new Gidle</code>创建了一个Gilde对象,简单介绍以下其中的四个参数,他们都是在createGlide中生成的。</p>
<ul>
<li>MemoryCache 内存缓存</li>
<li>BitmapPool 图片池</li>
<li>DecodeFormat 图片格式</li>
<li>Engine 引擎类<br>我们对其值的获取和计算也进行一个简单的了解：我们首先来看memoryCacher的大小是由<code>calculator.getMemoryCacheSize()</code>计算，来看其实现：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;首先是其调用MemorySizeCalculator的构造方法，最终会回调到如下构造方法中</span><br><span class="line"> MemorySizeCalculator(Context context, ActivityManager activityManager, ScreenDimensions screenDimensions) &#123;</span><br><span class="line">        this.context &#x3D; context;</span><br><span class="line">        final int maxSize &#x3D; getMaxSize(activityManager);</span><br><span class="line"></span><br><span class="line">        final int screenSize &#x3D; screenDimensions.getWidthPixels() * screenDimensions.getHeightPixels()</span><br><span class="line">                * BYTES_PER_ARGB_8888_PIXEL;(宽*高*4)</span><br><span class="line"></span><br><span class="line">        int targetPoolSize &#x3D; screenSize * BITMAP_POOL_TARGET_SCREENS;(宽*高*4*4)</span><br><span class="line">        int targetMemoryCacheSize &#x3D; screenSize * MEMORY_CACHE_TARGET_SCREENS;(宽*高*4*2)</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;判断是否超过最大值,否则就等比缩小</span><br><span class="line">        if (targetMemoryCacheSize + targetPoolSize &lt;&#x3D; maxSize) &#123;</span><br><span class="line">            memoryCacheSize &#x3D; targetMemoryCacheSize;</span><br><span class="line">            bitmapPoolSize &#x3D; targetPoolSize;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            int part &#x3D; Math.round((float) maxSize &#x2F; (BITMAP_POOL_TARGET_SCREENS + MEMORY_CACHE_TARGET_SCREENS));</span><br><span class="line">            memoryCacheSize &#x3D; part * MEMORY_CACHE_TARGET_SCREENS;</span><br><span class="line">            bitmapPoolSize &#x3D; part * BITMAP_POOL_TARGET_SCREENS;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#x2F;&#x2F;该方法主要用于计算最大内存。如果是低配手机就每个进程可用的最大内存乘以0.33,否则就每个进程可用的最大内存乘以0.4</span><br><span class="line">private static int getMaxSize(ActivityManager activityManager) &#123;</span><br><span class="line">        final int memoryClassBytes &#x3D; activityManager.getMemoryClass() * 1024 * 1024;</span><br><span class="line">        &#x2F;&#x2F;每个进程可用的最大内存</span><br><span class="line">        final boolean isLowMemoryDevice &#x3D; isLowMemoryDevice(activityManager);</span><br><span class="line">        return Math.round(memoryClassBytes</span><br><span class="line">                * (isLowMemoryDevice ? LOW_MEMORY_MAX_SIZE_MULTIPLIER : MAX_SIZE_MULTIPLIER));</span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;这里直接返回已经在构造函数中计算好的内容缓存。</span><br><span class="line">   public int getMemoryCacheSize() &#123;</span><br><span class="line">        return memoryCacheSize;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
从上面的代码可以分析出来，内容缓存memoryCacheSize的大小一般为屏幕的宽<em>高</em>4*2，当然，也有可能等比例缩小。<br>然后图片池BitmapPool的计算就比较简单了。在<code>createGlide</code>中计算BitmapPool的方法为：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> if (bitmapPool &#x3D;&#x3D; null) &#123;</span><br><span class="line">        if (Build.VERSION.SDK_INT &gt;&#x3D; Build.VERSION_CODES.HONEYCOMB) &#123;</span><br><span class="line">            int size &#x3D; calculator.getBitmapPoolSize();</span><br><span class="line">            bitmapPool &#x3D; new LruBitmapPool(size);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            bitmapPool &#x3D; new BitmapPoolAdapter();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
可以看出来，<code>bitmapPool</code>在android3.0以后用<code>calculator.getBitmapPoolSize()</code>进行计算，这个值在前面的<code>MemorySizeCalculator</code>已经计算出来了，而在MemorySizeCalculator中只是将其返回。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public int getBitmapPoolSize() &#123;</span><br><span class="line">      return bitmapPoolSize;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
可以分析出来，图片池用的是targetPoolSize(即一般是缓存大小是屏幕的宽<em>高</em>4*4)。<br>接下来是DecodeFormat 图片格式<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;GlideBuilder中的createGlide方法</span><br><span class="line">decodeFormat &#x3D; DecodeFormat.DEFAULT;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;public enum DecodeFormat </span><br><span class="line"> public static final DecodeFormat DEFAULT &#x3D; PREFER_RGB_565;</span><br></pre></td></tr></table></figure>
即默认的图片格式是PREFER_RGB_565；</li>
</ul>
<p>最后一个Engine引擎类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;GlideBuilder中的createGlide方法</span><br><span class="line">if (engine &#x3D;&#x3D; null) &#123;</span><br><span class="line">engine &#x3D; new Engine(memoryCache, diskCacheFactory, diskCacheService, sourceService);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>engine里面的主要参数：</strong></p>
<ul>
<li>内存缓存 memoryCache</li>
<li>本地缓存 diskCacheFactory</li>
<li>处理源资源的线程池 sourceService</li>
<li>处理本地缓存的线程池 diskCacheService<br>第一个参数就是我们前面已经计算出来的<code>memoryCache</code>，这里就不在介绍，加下来介绍第二个参数diskCacheFactory：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;GlideBuilder中的createGlide方法</span><br><span class="line">  if (diskCacheFactory &#x3D;&#x3D; null) &#123;</span><br><span class="line">            diskCacheFactory &#x3D; new InternalCacheDiskCacheFactory(context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;InternalCacheDiskCacheFactory中的方法</span><br><span class="line">public InternalCacheDiskCacheFactory(Context context) &#123;</span><br><span class="line">        this(context, DiskCache.Factory.DEFAULT_DISK_CACHE_DIR, DiskCache.Factory.DEFAULT_DISK_CACHE_SIZE);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;DiskCache接口中的内容</span><br><span class="line"> interface Factory &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;250 MB of cache. </span><br><span class="line">    int DEFAULT_DISK_CACHE_SIZE &#x3D; 250 * 1024 * 1024;</span><br><span class="line">    String DEFAULT_DISK_CACHE_DIR &#x3D; &quot;image_manager_disk_cache&quot;;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;Returns a new disk cache, or &#123;@code null&#125; if no disk cache could be created.</span><br><span class="line">    DiskCache build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的代码我们不难看出：<strong>默认大小为250m,默认目录:image_manager_disk_cache</strong>。</p>
<p>接下来，我们继续看：<br>sourceService 处理源资源的线程池</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;GlideBuilder中的createGlide方法</span><br><span class="line">if (sourceService &#x3D;&#x3D; null) &#123;</span><br><span class="line">        final int cores &#x3D; Math.max(1, Runtime.getRuntime().availableProcessors());</span><br><span class="line">        sourceService &#x3D; new FifoPriorityThreadPoolExecutor(cores);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#x2F;&#x2F;下面的方法都是在FifoPriorityThreadPoolExecutor类中，且该类继承ThreadPoolExecutor</span><br><span class="line">public FifoPriorityThreadPoolExecutor(int poolSize) &#123;</span><br><span class="line">    this(poolSize, UncaughtThrowableStrategy.LOG);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public FifoPriorityThreadPoolExecutor(int poolSize, UncaughtThrowableStrategy uncaughtThrowableStrategy) &#123;</span><br><span class="line">    this(poolSize, poolSize, 0, TimeUnit.MILLISECONDS, new DefaultThreadFactory(),</span><br><span class="line">        uncaughtThrowableStrategy);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public FifoPriorityThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAlive, TimeUnit timeUnit,</span><br><span class="line">        ThreadFactory threadFactory, UncaughtThrowableStrategy uncaughtThrowableStrategy) &#123;</span><br><span class="line">    super(corePoolSize, maximumPoolSize, keepAlive, timeUnit, new PriorityBlockingQueue&lt;Runnable&gt;(), threadFactory);</span><br><span class="line">    this.uncaughtThrowableStrategy &#x3D; uncaughtThrowableStrategy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过上面的源码，我们不难分析出diskCacheService其实一个线程池，里面的核心线程数为可用的处理器的个数。</p>
<p>最后是处理本地缓存的线程池 diskCacheService的实现，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;GlideBuilder中的createGlide方法</span><br><span class="line">if (diskCacheService &#x3D;&#x3D; null) &#123;</span><br><span class="line">        diskCacheService &#x3D; new FifoPriorityThreadPoolExecutor(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>核心线程数为1，最多的线程也为1。至于FifoPriorityThreadPoolExecutor方法的实现，可以参考前面的代码。</p>
<p>到这里，我们的with方法的实现就解析的差不多了。最后总结一下<code>with</code>方法的实现逻辑：<br>with方法可以传入不同的参数，根据不同的参数和线程环境来绑定不同的生命周期。如果在子线程且SDK&gt;=11即android3.0以后，则绑定的是Application的生命周期;如传入的是Activity且在主线程，则将gilde和activity的生命周期绑定（通过创建一个无界面的Fragment，让请求和Activity的生命周期同步），然后添加监听。</p>
<h2 id="load方法"><a href="#load方法" class="headerlink" title="load方法"></a>load方法</h2><p>通过的，load方法也有很多的重载。load在RequestManager类中的实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public DrawableTypeRequest&lt;String&gt; load(String string) &#123;</span><br><span class="line">    return (DrawableTypeRequest&lt;String&gt;) fromString().load(string);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public DrawableTypeRequest&lt;Uri&gt; load(Uri uri) &#123;</span><br><span class="line">    return (DrawableTypeRequest&lt;Uri&gt;) fromUri().load(uri);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public DrawableTypeRequest&lt;File&gt; load(File file) &#123;</span><br><span class="line">    return (DrawableTypeRequest&lt;File&gt;) fromFile().load(file);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public DrawableTypeRequest&lt;Integer&gt; load(Integer resourceId) &#123;</span><br><span class="line">    return (DrawableTypeRequest&lt;Integer&gt;) fromResource().load(resourceId);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Deprecated</span><br><span class="line">public DrawableTypeRequest&lt;URL&gt; load(URL url) &#123;</span><br><span class="line">    return (DrawableTypeRequest&lt;URL&gt;) fromUrl().load(url);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Deprecated</span><br><span class="line">public DrawableTypeRequest&lt;byte[]&gt; load(byte[] model, final String id) &#123;</span><br><span class="line">    return (DrawableTypeRequest&lt;byte[]&gt;) load(model).signature(new StringSignature(id));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public DrawableTypeRequest&lt;byte[]&gt; load(byte[] model) &#123;</span><br><span class="line">    return (DrawableTypeRequest&lt;byte[]&gt;) fromBytes().load(model);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public &lt;T&gt; DrawableTypeRequest&lt;T&gt; load(T model) &#123;</span><br><span class="line">    return (DrawableTypeRequest&lt;T&gt;) loadGeneric(getSafeClass(model)).load(model);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，load也有很多的重载方法，具体的作用和参数就不做说明了。通过源码我们可以看到，无论是那个load的重载，最终都会返回一个<code>DrawableTypeRequest</code> 对象(继承自DrawableRequestBuilder类）<br>我们不可能将所有的load方法分析一篇，这里我就以load(URL url)这个方法为例进行说明，至于其他的load方法，可以自行去理解。<br>首先，我们在<code>RequestManager.java</code>中，我们我们看到load的实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">@Deprecated</span><br><span class="line">public DrawableTypeRequest&lt;URL&gt; load(URL url) &#123;</span><br><span class="line">    return (DrawableTypeRequest&lt;URL&gt;) fromUrl().load(url);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Deprecated</span><br><span class="line">public DrawableTypeRequest&lt;URL&gt; fromUrl() &#123;</span><br><span class="line">    return loadGeneric(URL.class);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private &lt;T&gt; DrawableTypeRequest&lt;T&gt; loadGeneric(Class&lt;T&gt; modelClass) &#123;</span><br><span class="line">    ModelLoader&lt;T, InputStream&gt; streamModelLoader &#x3D; Glide.buildStreamModelLoader(modelClass, context);</span><br><span class="line">    ModelLoader&lt;T, ParcelFileDescriptor&gt; fileDescriptorModelLoader &#x3D;</span><br><span class="line">            Glide.buildFileDescriptorModelLoader(modelClass, context);</span><br><span class="line">    if (modelClass !&#x3D; null &amp;&amp; streamModelLoader &#x3D;&#x3D; null &amp;&amp; fileDescriptorModelLoader &#x3D;&#x3D; null) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;Unknown type &quot; + modelClass + &quot;. You must provide a Model of a type for&quot;</span><br><span class="line">                + &quot; which there is a registered ModelLoader, if you are using a custom model, you must first call&quot;</span><br><span class="line">                + &quot; Glide#register with a ModelLoaderFactory for your custom model class&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return optionsApplier.apply(</span><br><span class="line">            new DrawableTypeRequest&lt;T&gt;(modelClass, streamModelLoader, fileDescriptorModelLoader, context,</span><br><span class="line">                    glide, requestTracker, lifecycle, optionsApplier));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过上面的源码，我们发现加载图片UR这一个load方法中的逻辑是非常简单的，只是简单的调用<code>fromUrl().load(url)</code>方法（先调用<code>fromUrl()</code>,后调用<code>load(url)</code>，典型的build模式）。而<code>fromUrl()</code>的代码也是非常简单的，只是调用了<code>loadGeneric(URL.class)</code>这么一个方法。然后继续来看<code>loadGeneric(URL.class)</code>方法，这个方法也比较简单，用<code>Glide.buildStreamModelLoader</code>和<code>Glide.buildFileDescriptorModelLoader()</code>来获得<code>ModeiLoade</code>对象，这里面的具体实现就不做详细的讨论了，比较复杂，或许等我以后弄清楚了会加上。<br>在<code>loadGeneric(URL.class)</code>方法中，我们返回的是<code>DrawableTypeRequest</code>对象，所以最后创建了一个<code>DrawableTypeRequest</code>对象，并将相关参数应用到这个<code>DrawableTypeRequest</code>对象上，那么我们对<code>DrawableTypeRequest</code>这个对象就有必要进行以下分析了。<br>以下是<code>DrawableTypeRequest.java</code>的源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">public class DrawableTypeRequest&lt;ModelType&gt; extends DrawableRequestBuilder&lt;ModelType&gt; implements DownloadOptions &#123;</span><br><span class="line">    private final ModelLoader&lt;ModelType, InputStream&gt; streamModelLoader;</span><br><span class="line">    private final ModelLoader&lt;ModelType, ParcelFileDescriptor&gt; fileDescriptorModelLoader;</span><br><span class="line">    private final RequestManager.OptionsApplier optionsApplier;</span><br><span class="line"></span><br><span class="line">    private static &lt;A, Z, R&gt; FixedLoadProvider&lt;A, ImageVideoWrapper, Z, R&gt; buildProvider(Glide glide,</span><br><span class="line">            ModelLoader&lt;A, InputStream&gt; streamModelLoader,</span><br><span class="line">            ModelLoader&lt;A, ParcelFileDescriptor&gt; fileDescriptorModelLoader, Class&lt;Z&gt; resourceClass,</span><br><span class="line">            Class&lt;R&gt; transcodedClass,</span><br><span class="line">            ResourceTranscoder&lt;Z, R&gt; transcoder) &#123;</span><br><span class="line">        if (streamModelLoader &#x3D;&#x3D; null &amp;&amp; fileDescriptorModelLoader &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (transcoder &#x3D;&#x3D; null) &#123;</span><br><span class="line">            transcoder &#x3D; glide.buildTranscoder(resourceClass, transcodedClass);</span><br><span class="line">        &#125;</span><br><span class="line">        DataLoadProvider&lt;ImageVideoWrapper, Z&gt; dataLoadProvider &#x3D; glide.buildDataProvider(ImageVideoWrapper.class,</span><br><span class="line">                resourceClass);</span><br><span class="line">        ImageVideoModelLoader&lt;A&gt; modelLoader &#x3D; new ImageVideoModelLoader&lt;A&gt;(streamModelLoader,</span><br><span class="line">                fileDescriptorModelLoader);</span><br><span class="line">        return new FixedLoadProvider&lt;A, ImageVideoWrapper, Z, R&gt;(modelLoader, transcoder, dataLoadProvider);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DrawableTypeRequest(Class&lt;ModelType&gt; modelClass, ModelLoader&lt;ModelType, InputStream&gt; streamModelLoader,</span><br><span class="line">            ModelLoader&lt;ModelType, ParcelFileDescriptor&gt; fileDescriptorModelLoader, Context context, Glide glide,</span><br><span class="line">            RequestTracker requestTracker, Lifecycle lifecycle, RequestManager.OptionsApplier optionsApplier) &#123;</span><br><span class="line">        super(context, modelClass,</span><br><span class="line">                buildProvider(glide, streamModelLoader, fileDescriptorModelLoader, GifBitmapWrapper.class,</span><br><span class="line">                        GlideDrawable.class, null),</span><br><span class="line">                glide, requestTracker, lifecycle);</span><br><span class="line">        this.streamModelLoader &#x3D; streamModelLoader;</span><br><span class="line">        this.fileDescriptorModelLoader &#x3D; fileDescriptorModelLoader;</span><br><span class="line">        this.optionsApplier &#x3D; optionsApplier;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Attempts to always load the resource as a &#123;@link android.graphics.Bitmap&#125;, even if it could actually be animated.</span><br><span class="line">     *</span><br><span class="line">     * @return A new request builder for loading a &#123;@link android.graphics.Bitmap&#125;</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public BitmapTypeRequest&lt;ModelType&gt; asBitmap() &#123;</span><br><span class="line">        return optionsApplier.apply(new BitmapTypeRequest&lt;ModelType&gt;(this, streamModelLoader,</span><br><span class="line">                fileDescriptorModelLoader, optionsApplier));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Attempts to always load the resource as a &#123;@link com.bumptech.glide.load.resource.gif.GifDrawable&#125;.</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     *     If the underlying data is not a GIF, this will fail. As a result, this should only be used if the model</span><br><span class="line">     *     represents an animated GIF and the caller wants to interact with the GIfDrawable directly. Normally using</span><br><span class="line">     *     just an &#123;@link com.bumptech.glide.DrawableTypeRequest&#125; is sufficient because it will determine whether or</span><br><span class="line">     *     not the given data represents an animated GIF and return the appropriate animated or not animated</span><br><span class="line">     *     &#123;@link android.graphics.drawable.Drawable&#125; automatically.</span><br><span class="line">     * &lt;&#x2F;p&gt;</span><br><span class="line">     *</span><br><span class="line">     * @return A new request builder for loading a &#123;@link com.bumptech.glide.load.resource.gif.GifDrawable&#125;.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public GifTypeRequest&lt;ModelType&gt; asGif() &#123;</span><br><span class="line">        return optionsApplier.apply(new GifTypeRequest&lt;ModelType&gt;(this, streamModelLoader, optionsApplier));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * &#123;@inheritDoc&#125;</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public &lt;Y extends Target&lt;File&gt;&gt; Y downloadOnly(Y target) &#123;</span><br><span class="line">        return getDownloadOnlyRequest().downloadOnly(target);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * &#123;@inheritDoc&#125;</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public FutureTarget&lt;File&gt; downloadOnly(int width, int height) &#123;</span><br><span class="line">        return getDownloadOnlyRequest().downloadOnly(width, height);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private GenericTranscodeRequest&lt;ModelType, InputStream, File&gt; getDownloadOnlyRequest() &#123;</span><br><span class="line">        return optionsApplier.apply(new GenericTranscodeRequest&lt;ModelType, InputStream, File&gt;(File.class, this,</span><br><span class="line">                streamModelLoader, InputStream.class, File.class, optionsApplier));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过注释，我们大概也可以猜到这个类是用来做什么的。<br><code>DrawableTypeRequest</code>是一个用于创建加载请求的类，该加载方法可以直接加载动画的GIF或者Bitmap drawable格式的图片。他提供了两个的方法<code>asBitmap()</code>和<code>asGif()</code>来强制指定加载静态图片和GIF图片。通过观察这两个方法的实现，发现他们的实现其实是通过创建<code>BitmapTypeRequest</code>和<code>GifTypeRequest</code>来实现的，当然默认的实现还是通过创建<code>DrawableTypeRequest</code>实现的。<br>但是我们发现，在<code>DrawableTypeRequest</code>这个类中，并没有<code>load</code>这个方法，而在<code>RequestManager.java</code>中的<code>loadGeneric</code>方法中，最后返回的是<code>DrawableTypeRequest</code>对象，这就说明在<code>DrawableTypeRequest</code>肯定存在load方法的实现，我们在上面的代码中无法直接看到其方法的存在，那其实现很可能存在其父类中。通过上面的代码可知，<code>RequestManager</code>的父类是<code>DrawableRequestBuilder</code>。至于其父类<code>DrawableRequestBuilder</code>的实现，这里就不全部贴出来了，只贴出<code>load</code>方法的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line"> public DrawableRequestBuilder&lt;ModelType&gt; load(ModelType model) &#123;</span><br><span class="line">     super.load(model);</span><br><span class="line">     return this;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>当然，在<code>DrawableRequestBuilder</code>中，<code>load()</code>只是其中的一个方法而已，在这个类中，还定义了<code>gilde</code>常用的一些API方法，例如<code>error()</code>,<code>placeholder()</code>,<code>crossFade()</code>等等，至于其实现，可以参照源码去了解。下面继续来对<code>load()</code>方法进一步的深入，可以看到<code>load</code>方法调用了父类的<code>load</code>方法，接下来我们查看 其父类<code>GenericRequesBuilder.java</code>中<code>load</code>方法的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public GenericRequestBuilder&lt;ModelType, DataType, ResourceType, TranscodeType&gt; load(ModelType model) &#123;</span><br><span class="line">     this.model &#x3D; model;</span><br><span class="line">     isModelSet &#x3D; true;</span><br><span class="line">     return this;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，最终<code>load()</code>方法的实现很简单，只是设置了加载的类型，然后就返回了<code>this</code>，当然，这个<code>this</code>最终就变成了<code>DrawableTypeRequest</code>对象。到此,<code>load</code>方法基本流程已经差不多了，下面将分析<code>into()</code>方法的实现。</p>
<h2 id="into"><a href="#into" class="headerlink" title="into()"></a>into()</h2><p>前面的三个方法最终都是为了最后这个into方法做准备，所以搞懂<code>into</code>方法，对gilde源码的理解是非常非常重要的，下面我们进行<code>into</code>方法的解析。<br>首先，我们直接调用的<code>into</code>方法的实现是在<code>DrawableRequestBuilder</code>中实现的，具体实现的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * &#123;@inheritDoc&#125;</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> *     Note - If no transformation is set for this load, a default transformation will be applied based on the</span><br><span class="line"> *     value returned from &#123;@link android.widget.ImageView#getScaleType()&#125;. To avoid this default transformation,</span><br><span class="line"> *     use &#123;@link #dontTransform()&#125;.</span><br><span class="line"> * &lt;&#x2F;p&gt;</span><br><span class="line"> *</span><br><span class="line"> * @param view &#123;@inheritDoc&#125;</span><br><span class="line"> * @return &#123;@inheritDoc&#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Override</span><br><span class="line">public Target&lt;GlideDrawable&gt; into(ImageView view) &#123;</span><br><span class="line">    return super.into(view);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出了，在<code>DrawableRequestBuilder</code>中，其实并没有对<code>into</code>方法进行实现，只是简单的将其实现抛给了父类<code>into</code>方法。前面就分析过，<code>GenericRequestBuilder</code>就是<code>DrawableRequestBuilder</code>的父类，下面就<code>into</code>方法的实现进行解析。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public Target&lt;TranscodeType&gt; into(ImageView view) &#123;</span><br><span class="line">        Util.assertMainThread();&#x2F;&#x2F;判断是否在主线程</span><br><span class="line">        if (view &#x3D;&#x3D; null) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;You must pass in a non null View&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (!isTransformationSet &amp;&amp; view.getScaleType() !&#x3D; null) &#123;</span><br><span class="line">            switch (view.getScaleType()) &#123;</span><br><span class="line">                case CENTER_CROP:</span><br><span class="line">                    applyCenterCrop();</span><br><span class="line">                    break;</span><br><span class="line">                case FIT_CENTER:</span><br><span class="line">                case FIT_START:</span><br><span class="line">                case FIT_END:</span><br><span class="line">                    applyFitCenter();</span><br><span class="line">                    break;</span><br><span class="line">                &#x2F;&#x2F;$CASES-OMITTED$</span><br><span class="line">                default:</span><br><span class="line">                    &#x2F;&#x2F; Do nothing.</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return into(glide.buildImageViewTarget(view, transcodeClass));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>参考资料：</p>
<ul>
<li><a href="http://www.10tiao.com/html/169/201704/2650822526/1.html" target="_blank" rel="noopener">http://www.10tiao.com/html/169/201704/2650822526/1.html</a></li>
<li><a href="http://blog.csdn.net/yulyu/article/details/60331803" target="_blank" rel="noopener">http://blog.csdn.net/yulyu/article/details/60331803</a></li>
<li><a href="http://www.lightskystreet.com/2015/10/12/glide_source_analysis/" target="_blank" rel="noopener">http://www.lightskystreet.com/2015/10/12/glide_source_analysis/</a></li>
<li><a href="http://blog.csdn.net/guolin_blog/article/details/53939176" target="_blank" rel="noopener">http://blog.csdn.net/guolin_blog/article/details/53939176</a></li>
<li><a href="http://blog.csdn.net/guolin_blog/article/details/54895665" target="_blank" rel="noopener">http://blog.csdn.net/guolin_blog/article/details/54895665</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://reoger.tk/2017/08/19/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="reoger">
      <meta itemprop="description" content="reoger">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="reoger的记录">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/08/19/hello-world/" class="post-title-link" itemprop="url">Hello World</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-08-19 11:04:44" itemprop="dateCreated datePublished" datetime="2017-08-19T11:04:44+08:00">2017-08-19</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/5/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">reoger</p>
  <div class="site-description" itemprop="description">reoger</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">56</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">33</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">reoger</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
